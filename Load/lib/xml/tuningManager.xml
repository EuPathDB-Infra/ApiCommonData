<tuningConfig>

  <tuningTable name="apidb.SequenceAlias">
    <externalDependency name="dots.NaSequenceImp"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.SequenceAlias&1 NOLOGGING AS
SELECT ens.source_id, LOWER(ens.source_id) AS lowercase_source_id
FROM dots.ExternalNaSequence ens
UNION
SELECT ens.source_id, LOWER(ens.source_id) AS lowercase_source_id
FROM dots.VirtualSequence ens
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SequenceAlias_idx&1 ON apidb.SequenceAlias&1(lowercase_source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.GoTermSummary">
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.AaFeatureImp"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.GoAssociation"/>
    <externalDependency name="dots.GoAssociationInstance"/>
    <externalDependency name="dots.GoAssociationInstanceLoe"/>
    <externalDependency name="dots.GoAssocInstEvidCode"/>
    <externalDependency name="sres.GoEvidenceCode"/>
    <externalDependency name="sres.GoRelationship"/>
    <externalDependency name="sres.GoTerm"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GoTermSummary&1 NOLOGGING AS
SELECT gf.source_id,
       decode(ga.is_not, 0, '', 1, 'not', ga.is_not) as is_not,
                 gt.go_id, o.ontology, gt.name AS go_term_name,
                  gail.name AS source, gec.name as evidence_code
FROM dots.GeneFeature gf, dots.Transcript t,
     dots.TranslatedAaFeature taf, dots.GoAssociation ga,
     sres.GoTerm gt, dots.GoAssociationInstance gai,
     dots.GoAssociationInstanceLoe gail,
     dots.GoAssocInstEvidCode gaiec, sres.GoEvidenceCode gec,
     (SELECT gr.child_term_id AS go_term_id,
             DECODE(gp.name, 'biological_process', 'Biological Process',
                             'molecular_function', 'Molecular Function',
                             'cellular_component', 'Cellular Component',
                              gp.name)
             AS ontology
      FROM sres.GoRelationship gr, sres.GoTerm gp
      WHERE gr.parent_term_id = gp.go_term_id
        AND gp.go_id in ('GO:0008150','GO:0003674','GO:0005575')) o
WHERE gf.na_feature_id = t.parent_id
  AND t.na_feature_id = taf.na_feature_id
  AND taf.aa_sequence_id = ga.row_id
  AND ga.table_id = (SELECT table_id
                     FROM core.TableInfo
                     WHERE name = 'TranslatedAASequence')
  AND ga.go_term_id = gt.go_term_id
  AND ga.go_association_id = gai.go_association_id
  AND gai.go_assoc_inst_loe_id = gail.go_assoc_inst_loe_id
  AND gai.go_association_instance_id
      = gaiec.go_association_instance_id
  AND gaiec.go_evidence_code_id = gec.go_evidence_code_id
  AND gt.go_term_id = o.go_term_id(+)
ORDER BY o.ontology, gt.go_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GoTermSum_sourceId_idx&1 ON apidb.GoTermSummary&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.PdbSimilarity">
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.AaFeatureImp"/>
    <externalDependency name="dots.AaSequenceImp"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.PdbSimilarity&1 NOLOGGING AS
SELECT gf.source_id, eas.source_id AS pdb_chain, eas.description AS pdb_title,
       substr(eas.source_id, 1,
              instr(eas.source_id, '_', -1) - 1)
         AS pdb_id,
       s.pvalue_mant, s.pvalue_exp, 
       SUBSTR(tn.name, 1, 100) AS taxon,
       ROUND( (s.number_identical / s.total_match_length) * 100)
         AS percent_identity,
       ROUND( (s.total_match_length / tas.length) * 100)
         AS percent_plasmo_coverage,
       s.score, eas.taxon_id as pdb_taxon_id, tas.taxon_id as gene_taxon_id
FROM dots.TranslatedAaFeature taf,
     dots.TranslatedAaSequence tas, core.TableInfo tas_ti,
     dots.Similarity s, core.TableInfo eas_ti,
     dots.ExternalAaSequence eas,
     sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
     sres.TaxonName tn, dots.Transcript t, dots.GeneFeature gf
WHERE taf.aa_sequence_id = tas.aa_sequence_id
  AND tas_ti.name = 'TranslatedAASequence'
  AND tas_ti.table_id = s.query_table_id
  AND s.query_id = tas.aa_sequence_id
  AND eas_ti.name = 'ExternalAASequence'
  AND eas_ti.table_id = s.subject_table_id
  AND s.subject_id = eas.aa_sequence_id
  AND tn.name_class = 'scientific name'
  AND eas.external_database_release_id
      = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ed.name in ('PDBProteinSequences_RSRC','PDB protein sequences')
  AND eas.taxon_id = tn.taxon_id
  AND t.na_feature_id = taf.na_feature_id
  AND gf.na_feature_id = t.parent_id
ORDER BY taf.source_id, eas.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.PdbSim_sourceId_ix&1
ON apidb.PdbSimilarity&1 (source_id, score DESC)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SequencePieceClosure">
    <externalDependency name="dots.SequencePiece"/>
    <sql>
      <![CDATA[
        create table apidb.SequencePieceClosure&1 nologging as
        select sp.*, 1 as edge_level from dots.SequencePiece sp
      ]]>
    </sql>
    <sql>
      <![CDATA[
        /* known issue: this should be run not just once, but iteratively
           until it doesn't create new records.  Currently (7/2008),
           SequencePieces aren't nested even once. */
        insert into apidb.SequencePieceClosure&1
                    (edge_level, virtual_na_sequence_id, piece_na_sequence_id,
                     distance_from_left, strand_orientation, modification_date)
        select 2, higher.virtual_na_sequence_id, lower.piece_na_sequence_id,
               higher.distance_from_left
               + case
                   when nvl(higher.strand_orientation, '+') = '+'
                   then lower.distance_from_left
                   else higher_piece.length - lower_piece.length - lower.distance_from_left
                 end as distance_from_left,
               case
                 when nvl(higher.strand_orientation, '+') = nvl(lower.strand_orientation, '+')
                 then '+'
                 else '-'
               end as strand_orientation,
               sysdate
        from apidb.SequencePieceClosure&1 higher, apidb.SequencePieceClosure&1 lower,
             dots.NaSequence higher_piece, dots.NaSequence lower_piece
        where higher.piece_na_sequence_id = lower.virtual_na_sequence_id
          and higher.piece_na_sequence_id = higher_piece.na_sequence_id
          and lower.piece_na_sequence_id = lower_piece.na_sequence_id
          and (higher.virtual_na_sequence_id, lower.piece_na_sequence_id)
              not in (select virtual_na_sequence_id, piece_na_sequence_id
                      from apidb.SequencePieceClosure&1)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.FeatureLocation">
    <internalDependency name="apidb.SequencePieceClosure"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.NaLocation"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
create table apidb.FeatureLocation&1 NOLOGGING as
select case
         when nf.subclass_view = 'GeneFeature'
              and db.name in ('GLEAN predictions', 'GlimmerHMM predictions',
                              'TigrScan', 'TwinScan predictions',
                              'TwinScanEt predictions', -- not 'tRNAscan-SE',
                              'P. falciparum Evigan Gene Models','Evigan_RSRC',
                              'Pfalciparum workshop annotations reviewed and changed',
                              'Sanger P. falciparum old annotations','Pfalciparum_old_annotations_RSRC',
                              'Old annotation for ME49',
                              'Tbrucei427_AutoMAGI_Annotations_RSRC')
           then 'GenePrediction'
         else nf.subclass_view
       end as feature_type,
       nf.source_id as feature_source_id, ns.source_id as sequence_source_id,
       nf.na_sequence_id, nf.na_feature_id,
       least(nl.start_min, nl.start_max, nl.end_min, nl.end_max) as start_min,
       greatest(nl.start_min, nl.start_max, nl.end_min, nl.end_max) as end_max,
       nl.is_reversed, nf.parent_id, nf.sequence_ontology_id,
       cast (null as number) as is_top_level, ef.coding_start, ef.coding_end,
       nf.external_database_release_id,
       cast(apidb.project_id(tn.name) as varchar2(20)) as project_id
from dots.NaFeature nf, dots.NaLocation nl, dots.NaSequence ns,
     dots.ExonFeature ef, sres.TaxonName tn,
     (select edr.external_database_release_id, ed.name
      from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      where edr.external_database_id = ed.external_database_id) db
where nf.na_feature_id = nl.na_feature_id
  and nf.external_database_release_id = db.external_database_release_id(+)
  and nf.na_sequence_id = ns.na_sequence_id
  and nl.na_feature_id = ef.na_feature_id(+)
  and ns.taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
union
select -- virtual feature locations mapped through SequencePiece
       case
         when nf.subclass_view = 'GeneFeature'
              and  db.name in ('GLEAN predictions', 'GlimmerHMM predictions',
                          'TigrScan', 'TwinScan predictions',
                          'TwinScanEt predictions', -- not 'tRNAscan-SE',
                          'P. falciparum Evigan Gene Models','Evigan_RSRC',
                          'Pfalciparum workshop annotations reviewed and changed',
                          'Old annotation for ME49',
                          'Tbrucei427_AutoMAGI_Annotations_RSRC')
           then 'GenePrediction'
         else nf.subclass_view
       end as feature_type,
       nf.source_id as feature_source_id, scaffold.source_id as sequence_source_id,
       sp.virtual_na_sequence_id, nf.na_feature_id,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - greatest(nl.start_min, nl.start_max, nl.end_min, nl.end_max)+ 1
           else sp.distance_from_left + least(nl.start_min, nl.start_max, nl.end_min, nl.end_max)
       end as start_min,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - least(nl.start_min, nl.start_max, nl.end_min, nl.end_max) + 1
         else sp.distance_from_left + greatest(nl.start_min, nl.start_max, nl.end_min, nl.end_max)
       end as end_max,
       case
         when sp.strand_orientation in ('-', '-1')
         then decode(nvl(nl.is_reversed, 0),
                     0, 1,  1, 0,  1)
         else nl.is_reversed
       end as is_reversed,
       nf.parent_id, nf.sequence_ontology_id,
       cast (null as number) as is_top_level,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - coding_start + 1
           else sp.distance_from_left + ef.coding_start
       end as coding_start,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - coding_end + 1
         else sp.distance_from_left + coding_end
       end as coding_end, nf.external_database_release_id,
       cast(apidb.project_id(tn.name) as varchar2(20)) as project_id
from dots.NaFeature nf, dots.NaLocation nl, dots.NaSequence contig,
     apidb.SequencePieceClosure sp, dots.NaSequence scaffold, dots.ExonFeature ef,
     sres.TaxonName tn,
     (select edr.external_database_release_id, ed.name
      from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      where edr.external_database_id = ed.external_database_id) db
where nf.na_feature_id = nl.na_feature_id
  and nf.external_database_release_id = db.external_database_release_id(+)
  and nf.na_sequence_id = contig.na_sequence_id
  and nf.na_sequence_id = sp.piece_na_sequence_id
  and sp.virtual_na_sequence_id = scaffold.na_sequence_id
  and nl.na_feature_id = ef.na_feature_id(+)
  and contig.taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
update apidb.FeatureLocation&1
set is_top_level = 1
      ]]>
    </sql>
    <sql>
      <![CDATA[
update apidb.FeatureLocation&1
set is_top_level = 0
where na_sequence_id in (select piece_na_sequence_id from dots.SequencePiece)
      ]]>
    </sql>
    <sql>
      <![CDATA[
commit
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.featloc_ix&1 on apidb.FeatureLocation&1
             (feature_type, na_sequence_id, start_min, end_max, is_reversed, feature_source_id, na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.featloc2_ix&1 on apidb.FeatureLocation&1
             (na_sequence_id, start_min, end_max, is_reversed, sequence_ontology_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.fl_seq_st_end_feat_idx&1
      on apidb.FeatureLocation&1 (na_sequence_id,start_min,end_max,na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.featloc3_ix&1 on apidb.FeatureLocation&1
             (na_feature_id, na_sequence_id, is_top_level)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.featloc4_ix&1 on apidb.FeatureLocation&1
             (feature_type, is_top_level, na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.featloc5_ix&1
on apidb.FeatureLocation&1 
(na_sequence_id, feature_type, start_min, end_max, parent_id, na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.featloc6_ix&1 on apidb.FeatureLocation&1 (feature_source_id, is_top_level, na_sequence_id, is_reversed)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.GeneId">
    <internalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GeneId&1 NOLOGGING AS
SELECT id, gene, unique_mapping,
       SUBSTR(apidb.tab_to_string(CAST(COLLECT(union_member order by union_member) AS apidb.varchartab),'; '), 1, 80) as union_member, 
       SUBSTR(apidb.tab_to_string(CAST(COLLECT(database_name order by database_name) AS apidb.varchartab),'; '), 1, 80) as database_name
FROM (SELECT substr(t.protein_id, 1, instr(t.protein_id, '.') - 1) AS id,
             gf.source_id AS gene,
             'Transcript.protein_id before dot' as union_member, ed.name as database_name, cast (null as NUMBER) as unique_mapping
      FROM dots.Transcript t, dots.GeneFeature gf,
           sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      WHERE t.parent_id = gf.na_feature_id
        AND substr(t.protein_id, 1, instr(t.protein_id, '.') - 1) IS NOT NULL
        AND gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT t.protein_id AS id,
             gf.source_id AS gene,
             'Transcript.protein_id' as union_member, ed.name as database_name, cast (null as NUMBER) as unique_mapping
      FROM dots.Transcript t, dots.GeneFeature gf,
           sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      WHERE t.parent_id = gf.na_feature_id
        AND t.protein_id IS NOT NULL
        AND gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT dr.primary_identifier AS id, 
             gf.source_id AS gene,
             'DbRef.primary_identifier' as union_member, ed.name as database_name, cast (null as NUMBER) as unique_mapping
      FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
           sres.ExternalDatabase ed
      WHERE dr.primary_identifier IS NOT NULL
        AND gf.na_feature_id = drnf.na_feature_id
        AND drnf.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
              = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND ed.name not in ('Pf_Phenotype_DBRefs_RSRC','Pb_RMgm_Phenotype_DBRefs_RSRC','Pc_Phenotype_DBRefs_RSRC','Pv_Phenotype_DBRefs_RSRC')
        AND ed.name != 'Pf_PathwayMappings_Hagai_RSRC'
        AND ed.name != 'Links to Pathway Maps'
        AND ed.name != 'Phenotype DBRefs'
        AND ed.name != 'MPMP'
        AND ed.name != 'Pf_BRENDAMapping_RSRC'
        AND ed.name != 'Pf_SGPPMapping_RSRC'
        AND ed.name not in ('Pubmed DBRefs','Pb_Pubmed_DBRefs_RSRC','Pc_Pubmed_DBRefs_RSRC','Pf_Pubmed_DBRefs_RSRC','Pk_Pubmed_DBRefs_RSRC','Pv_Pubmed_DBRefs_RSRC','Py_Pubmed_DBRefs_RSRC')
        AND ed.name not in ('Entrez DBRefs','DBRefs_RSRC','Pk_Entrez_DBRefs_RSRC','Pv_Entrez_DBRefs_RSRC','Py_Entrez_DBRefs_RSRC', 'Pf_Entrez_DBRefs_RSRC')
        AND ed.name != 'PMID'
     UNION
      SELECT dr.secondary_identifier AS id, 
             gf.source_id AS gene,
             'DbRef.secondary_identifier' as union_member, ed.name as database_name, cast (null as NUMBER) as unique_mapping
      FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
           sres.ExternalDatabase ed
      WHERE dr.secondary_identifier IS NOT NULL
        AND gf.na_feature_id = drnf.na_feature_id
        AND drnf.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
              = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND ed.name IN ('NRDB_gb_dbXRefBySeqIdentity',
                        'NRDB_pdb_dbXRefBySeqIdentity',
                        'NRDB_ref_dbXRefBySeqIdentity',
                        'NRDB_sp_dbXRefBySeqIdentity',
                        'Predicted protein structures','Pf_predictedProteinStructures_RSRC',
                        'GenBank')
     UNION
      SELECT dr.primary_identifier AS id, 
             gf.source_id AS gene,
             'genbank DbRef.primary_identifier' as union_member, ed.name as database_name, cast (null as NUMBER) as unique_mapping
      FROM dots.GeneFeature gf, dots.Transcript t, dots.dbrefNaSequence drns,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
            sres.ExternalDatabase ed
      WHERE gf.na_feature_id = t.parent_id
        AND t.na_sequence_id = drns.na_sequence_id
        AND drns.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND ed.name = 'GenBank'
     UNION
      SELECT pred_loc.feature_source_id AS id,
             gene_loc.feature_source_id AS gene,
             'overlapping predicted gene source_id' as union_member, ed.name as database_name, cast (null as NUMBER) as unique_mapping
      FROM apidb.FeatureLocation gene_loc, apidb.FeatureLocation pred_loc,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      WHERE pred_loc.feature_type = 'GenePrediction'
        AND gene_loc.feature_type = 'GeneFeature'
        AND pred_loc.na_sequence_id = gene_loc.na_sequence_id
        AND gene_loc.start_min <= pred_loc.end_max
        AND gene_loc.end_max >= pred_loc.start_min
        AND pred_loc.is_reversed = gene_loc.is_reversed
        AND pred_loc.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT ng.name AS alias, gf.source_id AS gene,
             'NaGene' as union_member, ed.name as database_name, cast (null as NUMBER) as unique_mapping
      FROM dots.GeneFeature gf, dots.NaFeatureNaGene nfng, dots.NaGene ng,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      WHERE gf.na_feature_id = nfng.na_feature_id
        AND ng.na_gene_id = nfng.na_gene_id
        AND gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
 UNION
  SELECT source_id AS alias, source_id AS gene,
         'same ID' as union_member, ed.name as database_name, cast (null as NUMBER) as unique_mapping
  FROM dots.GeneFeature gf,
       sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
  WHERE gf.external_database_release_id = edr.external_database_release_id
    AND edr.external_database_id = ed.external_database_id
 UNION
     SELECT n.name AS alias, gf.source_id AS gene,
         'gene name' as union_member, d.name as database_name, cast (null as NUMBER) as unique_mapping
      from apidb.GeneFeatureName n, dots.genefeature gf, sres.externaldatabaserelease r, sres.externaldatabase d
      where n.na_feature_id = gf.na_feature_id
      and gf.external_database_release_id =r.external_database_release_id
      and r.external_database_id = d.external_database_id
      and n.is_preferred = 1
)
GROUP BY id, gene, unique_mapping
      ]]>
    </sql>
    <sql>
      <![CDATA[
update apidb.GeneId&1
set unique_mapping = 1
where lower(id) in (select lower_id
                    from (select distinct lower(id) as lower_id, gene
                          from GeneId&1) case_independent_mapping
                    group by lower_id
                    having count(*) = 1)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneId_gene_idx&1 ON apidb.GeneId&1 (gene, id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneId_id_idx&1 ON apidb.GeneId&1 (id, gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneId_uniqid_idx&1 ON apidb.GeneId&1 (unique_mapping, id, gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneId_lowid_idx&1 ON apidb.GeneId&1 (lower(id), gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneId_uniqlowid_idx&1 ON apidb.GeneId&1 (unique_mapping, lower(id), gene)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SequenceId">
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.SequenceOntology"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.SequenceId&1 NOLOGGING AS
SELECT DISTINCT substr(id, 1, 50) as id, substr(sequence, 1, 50) AS sequence
FROM (
  SELECT lower(source_id) as id, source_id as sequence
  FROM dots.NaSequence ns, sres.SequenceOntology so
  WHERE ns.sequence_ontology_id = so.sequence_ontology_id
    AND so.term_name in ('contig', 'supercontig', 'chromosome','mitochondrial_chromosome','plastid_sequence','cloned_genomic','apicoplast_chromosome')
UNION
  SELECT LOWER(dr.primary_identifier) AS id, ns.source_id AS sequence
  FROM dots.NaSequence ns, dots.DbRefNaSequence drnf,
       sres.DbRef dr, sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase ed
  WHERE dr.primary_identifier IS NOT NULL
    AND ns.na_sequence_id = drnf.na_sequence_id
    AND drnf.db_ref_id = dr.db_ref_id
    AND dr.external_database_release_id
          = edr.external_database_release_id
    AND edr.external_database_id = ed.external_database_id
)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SequenceId_sequence_idx&1 ON apidb.SequenceId&1 (sequence)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SequenceId_id_idx&1 ON apidb.SequenceId&1 (id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.EpitopeSummary">
    <externalDependency name="dots.AaFeatureImp"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.AaSequenceDbRef"/>
    <externalDependency name="dots.AaSequenceImp"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.EpitopeSummary&1 NOLOGGING AS
SELECT gf.source_id, dr.primary_identifier AS iedb_id,
       al.start_min||'-'||al.end_max AS location,
       mas.sequence, 
       SUBSTR(tn.name, 1, 100) AS name,
       DECODE(ef.type, 'Not Full Set Not on Blast Hit', 'Low',
                       'Not Full Set On Blast Hit', 'Medium',
                       'Full Set Not on Blast Hit', 'Medium',
                       'Full Set On Blast Hit', 'High',
                       'unknown epitope type') AS confidence
FROM dots.GeneFeature gf, dots.Transcript t,
     dots.TranslatedAaFeature taf, dots.MotifAaSequence mas,
     dots.TranslatedAaSequence tas, dots.EpitopeFeature ef,
     dots.AaLocation al, dots.AaSequenceDbRef asdr,
     sres.DbRef dr, sres.ExternalDatabaseRelease edr,
     sres.ExternalDatabase ed, Sres.TaxonName tn
WHERE t.parent_id = gf.na_feature_id
  AND taf.na_feature_id = t.na_feature_id
  AND taf.aa_sequence_id = tas.aa_sequence_id
  AND tas.aa_sequence_id = ef.aa_sequence_id
  AND ef.aa_feature_id = al.aa_feature_id
  AND ef.motif_aa_sequence_id = mas.aa_sequence_id
  AND mas.aa_sequence_id = asdr.aa_sequence_id
  AND asdr.db_ref_id = dr.db_ref_id
  AND tas.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
  AND ef.external_database_release_id
      = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ed.name in ('Pf_IEDB_Epitopes_RSRC','Pb_IEDB_Epitopes_RSRC','Pc_IEDB_Epitopes_RSRC','Pk_IEDB_Epitopes_RSRC','Pv_IEDB_Epitopes_RSRC','Py_IEDB_Epitopes_RSRC','Lbraziliensis_IEDB_Epitopes_RSRC','Linfantum_IEDB_Epitopes_RSRC','LmajorFriedlin_IEDB_Epitopes_RSRC','Tbrucei927_IEDB_Epitopes_RSRC','Tbrucei427_IEDB_Epitopes_RSRC','Tbruceigambiense_IEDB_Epitopes_RSRC','TcruziEsmeraldoLike_IEDB_Epitopes_RSRC','TcruziNonEsmeraldoLike_IEDB_Epitopes_RSRC','Links to IEDB epitopes')
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Epi_srcId_ix&1 ON apidb.EpitopeSummary&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.GeneCentromereDistance">
    <internalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="sres.SequenceOntology"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GeneCentromereDistance&1 NOLOGGING AS
SELECT gfl.feature_source_id AS gene,
       LEAST(ABS(mfl.start_min - gfl.end_max),
             ABS(mfl.end_max - gfl.start_min)) AS centromere_distance,
       gfl.sequence_source_id AS genomic_sequence
FROM apidb.FeatureLocation gfl, apidb.FeatureLocation mfl,
     sres.SequenceOntology so
WHERE gfl.na_sequence_id = mfl.na_sequence_id
  AND mfl.feature_type = 'Miscellaneous'
  AND gfl.feature_type = 'GeneFeature'
  AND mfl.sequence_ontology_id = so.sequence_ontology_id
  AND so.term_name = 'centromere'
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GCent_loc_ix&1
       ON apidb.GeneCentromereDistance&1 (genomic_sequence, centromere_distance)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SageTagAnalysisAttributes">
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="rad.Analysis"/>
    <externalDependency name="rad.AnalysisInput"/>
    <externalDependency name="rad.AnalysisResultImp"/>
    <externalDependency name="rad.Assay"/>
    <externalDependency name="rad.CompositeElementImp"/>
    <externalDependency name="rad.CompositeElementResultImp"/>
    <externalDependency name="rad.LogicalGroup"/>
    <externalDependency name="rad.LogicalGroupLink"/>
    <externalDependency name="rad.Protocol"/>
    <externalDependency name="rad.Quantification"/>
    <intermediateTable name="apidb.SageTagInfo"/>
    <intermediateTable name="apidb.SageTagGenomicOccurrence"/>
    <intermediateTable name="apidb.SageTagLibraryTotal"/>
    <intermediateTable name="apidb.SageTagQuantificationTotal"/>

    <sql>
      <![CDATA[
create table apidb.SageTagInfo NOLOGGING as
select st.composite_element_id, dtr.analysis_id, dtr.float_value as dtr_tag_count,
       substr(st.tag, 1, 30) as sequence, r.tag_count, r.quantification_id, dtr.table_id
from dots.SageTagFeature stf, rad.DataTransformationResult dtr, rad.SageTag st, rad.SageTagResult r
where st.composite_element_id = dtr.row_id
  and st.composite_element_id = stf.source_id
  and st.composite_element_id = r.composite_element_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create table apidb.SageTagGenomicOccurrence NOLOGGING as
select source_id, count(*) as occurrence
from dots.SageTagFeature
group by source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create table apidb.SageTagLibraryTotal NOLOGGING as
select dt.analysis_id, sum(float_value) as total_count
from rad.DataTransformationResult dt, rad.Analysis a, rad.Protocol p
where dt.analysis_id = a.analysis_id
  and a.protocol_id = p.protocol_id
  and p.name = 'Normalization of SAGE tag frequencies to a target total intensity'
group by dt.analysis_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create table apidb.SageTagQuantificationTotal nologging as
select quantification_id, sum(tag_count) as total_raw_count
from rad.SageTagResult
group by quantification_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create table apidb.SageTagAnalysisAttributes&1 NOLOGGING as
select sti.analysis_id, max(sti.dtr_tag_count) as tag_count,
       max(ct.occurrence) as occurrence, sti.sequence,
       sti.composite_element_id, a.name as library_name,
       library_total.total_count as library_total_tag_count,
       (max(sti.dtr_tag_count) * 100) / library_total.total_count
         as library_tag_percentage,
       sti.tag_count as raw_count, tot.total_raw_count,
       100 *(sti.tag_count / tot.total_raw_count ) as raw_percent
from apidb.SageTagInfo sti, apidb.SageTagGenomicOccurrence ct,
     apidb.SageTagLibraryTotal library_total, SageTagQuantificationTotal tot,
     core.TableInfo ti, rad.AnalysisInput ai, rad.LogicalGroup lg,
     rad.LogicalGroupLink ll, rad.Assay a, core.TableInfo quant_ti,
     rad.Quantification q
where ti.name = 'SAGETag'
  and quant_ti.name = 'Assay'
  and sti.table_id = ti.table_id
  and q.quantification_id = sti.quantification_id
  and tot.quantification_id = sti.quantification_id
  and ct.source_id = sti.composite_element_id
  and sti.analysis_id = ai.analysis_id
  and ai.logical_group_id = lg.logical_group_id
  and lg.logical_group_id = ll.logical_group_id
  and ll.row_id = a.assay_id
  and a.name = q.name
  and ll.table_id = quant_ti.table_id
  and sti.analysis_id = library_total.analysis_id
group by sti.analysis_id, sti.sequence, sti.composite_element_id,
         a.name, library_total.total_count,
         q.name, sti.tag_count, tot.total_raw_count
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.staa_ix&1 on apidb.SageTagAnalysisAttributes&1 (analysis_id, composite_element_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.staa_tag_ix&1 on apidb.SageTagAnalysisAttributes&1 (composite_element_id, analysis_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SageTagGene">
    <internalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="apidb.SageTagAnalysisAttributes"/>
    <externalDependency name="rad.DataTransformationResult"/>
    <externalDependency name="dots.SageTagFeature"/>
    <intermediateTable name="apidb.SageTagGeneFivePrime"/>
    <intermediateTable name="apidb.SageTagGeneThreePrime"/>
    <sql>
      <![CDATA[
create table apidb.SageTagGeneFivePrime NOLOGGING as
   select '5' as direction, g.feature_source_id AS gene_source_id,
          s.feature_source_id as tag_source_id,
             min (case
                    when g.is_reversed = 1 and s.end_max - g.end_max < 0
                      then 0
                    when g.is_reversed = 1 and s.end_max - g.end_max >= 0
                      then s.end_max - g.end_max
                    when g.is_reversed = 0 and g.start_min - s.start_min < 0
                      then 0
                    when g.is_reversed = 0 and g.start_min - s.start_min >= 0
                      then g.start_min - s.start_min
                  end) as distance,
           dr.analysis_id, max(dr.float_value) as tag_count,
           max(ct.occurrence) as occurrence,
           g.na_feature_id as gene_feature_id, s.na_feature_id as tag_feature_id,
           case when s.is_reversed = g.is_reversed then 0
                else 1
           end as antisense
      from apidb.FeatureLocation g, apidb.FeatureLocation s,
           rad.DataTransformationResult dr,
           (select source_id , count(*) as occurrence
            from dots.SageTagFeature
            group by source_id) ct
      where g.feature_type = 'GeneFeature'
        and s.feature_type = 'SAGETagFeature'
        and g.na_sequence_id = s.na_sequence_id
        and s.feature_source_id = dr.row_id
        and dr.row_id = ct.source_id
        and (case
               when g.is_reversed = 0
                 then g.start_min - s.start_min
               else s.end_max - g.end_max
             end <= 1000
            and case
                  when g.is_reversed = 0
                    then g.end_max - s.end_max
                  else s.start_min - g.start_min
                end >= 0)
      group by g.feature_source_id, s.feature_source_id, dr.analysis_id,
               g.na_feature_id, s.na_feature_id,
               case when s.is_reversed = g.is_reversed then 0
                    else 1
               end
      ]]>
    </sql>
    <sql>
      <![CDATA[
create table apidb.SageTagGeneThreePrime NOLOGGING as
      select '3' as direction, g.feature_source_id AS gene_source_id,
             s.feature_source_id as tag_source_id,
             min (case
                    when g.is_reversed = 1 and g.start_min - s.start_min < 0
                      then 0
                    when g.is_reversed = 1 and g.start_min - s.start_min  >= 0
                      then g.start_min - s.start_min
                    when g.is_reversed = 0 and s.end_max - g.end_max < 0
                      then 0
                    when g.is_reversed = 0 and s.end_max - g.end_max >= 0
                      then s.end_max - g.end_max
                  end) as distance,
           dr.analysis_id, max(dr.float_value) as tag_count,
           max(ct.occurrence) as occurrence,
           g.na_feature_id as gene_feature_id, s.na_feature_id as tag_feature_id,
           case when s.is_reversed = g.is_reversed then 0
                else 1
           end as antisense
      from apidb.FeatureLocation g, apidb.FeatureLocation s,
           rad.DataTransformationResult dr,
           (select source_id , count(*) as occurrence
            from dots.SageTagFeature
            group by source_id) ct
            where g.feature_type = 'GeneFeature'
              and s.feature_type = 'SAGETagFeature'
              and g.na_sequence_id = s.na_sequence_id
              and s.feature_source_id = dr.row_id
              and dr.row_id = ct.source_id
              and (case
                     when g.is_reversed = 0
                       then s.end_max - g.end_max
                     else g.start_min - s.start_min end <= 1000
                  and
                   case
                     when g.is_reversed = 0
                       then s.start_min - g.start_min
                     else g.end_max - s.end_max
                   end >= 0)
            group by g.feature_source_id, s.feature_source_id, dr.analysis_id,
                     g.na_feature_id, s.na_feature_id,
                     case when s.is_reversed = g.is_reversed then 0
                          else 1
                     end
      ]]>
    </sql>
    <sql>
      <![CDATA[
create table apidb.SageTagGene&1 NOLOGGING as
select t.direction, t.gene_source_id, t.tag_source_id, t.distance,
       t.analysis_id, t.occurrence, t.gene_feature_id, t.tag_feature_id,
       t.tag_count, t.antisense,
       case
         when t.antisense = 0 then t.tag_count
         else 0
       end as sense_count,
       case
         when t.antisense = 0 then 0
         else t.tag_count
       end as antisense_count, 
       libs.library_name
from
  (select * from apidb.SageTagGeneFivePrime
   union all
   select * from apidb.SageTagGeneThreePrime) t,
  (select distinct(analysis_id), library_name from apidb.SageTagAnalysisAttributes) libs
  where t.analysis_id = libs.analysis_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.stg_ix&1
on apidb.SageTagGene&1 (gene_source_id, direction, distance, tag_source_id, tag_feature_id, antisense)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="apidb.GeneAttributes">
    <internalDependency name="apidb.GeneId"/>
    <internalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="apidb.GenomicSequence"/>
    <internalDependency name="apidb.TaxonSpecies"/>
    <externalDependency name="apidb.AaSequenceAttribute"/>
    <externalDependency name="apidb.Profile"/>
    <externalDependency name="apidb.ProfileSet"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.AaFeatureImp"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.AaSequenceEnzymeClass"/>
    <externalDependency name="dots.AaSequenceImp"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="dots.GeneInstance"/>
    <externalDependency name="dots.GoAssociation"/>
    <externalDependency name="dots.GoAssociationInstance"/>
    <externalDependency name="dots.GoAssociationInstanceLoe"/>
    <externalDependency name="dots.GoAssocInstEvidCode"/>
    <externalDependency name="dots.NaFeatureComment"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.NaSequenceImp"/> 
    <externalDependency name="dots.SequenceGroup"/>
    <externalDependency name="rad.Analysis"/>
    <externalDependency name="rad.AnalysisInput"/>
    <externalDependency name="rad.AnalysisResultImp"/>
    <externalDependency name="rad.CompositeElementImp"/>
    <externalDependency name="rad.LogicalGroup"/>
    <externalDependency name="rad.Protocol"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.EnzymeClass"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.GoEvidenceCode"/>
    <externalDependency name="sres.GoRelationship"/>
    <externalDependency name="sres.GoTerm"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <intermediateTable name="apidb.GoTermList"/>
    <intermediateTable name="apidb.GeneGoAttributes"/>
    <intermediateTable name="apidb.DerisiExpn"/>
    <intermediateTable name="apidb.WinzelerExpn"/>
    <intermediateTable name="apidb.ToxoExpn"/>
    <intermediateTable name="apidb.GeneProteinAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GoTermList NOLOGGING AS
SELECT *
FROM (  -- work around sometime Oracle bug ORA-00942
      SELECT source_id, ontology, source,
             apidb.tab_to_string(CAST(COLLECT(name order by name) AS apidb.varchartab), ', ')
               AS go_terms
      FROM (SELECT DISTINCT gf.source_id, o.ontology, gt.name,
                        DECODE(gail.name, 'Interpro', 'predicted', 'annotated')
                              AS source
            FROM dots.GeneFeature gf, dots.Transcript t,
                 dots.TranslatedAaFeature taf, dots.GoAssociation ga,
                 sres.GoTerm gt, dots.GoAssociationInstance gai,
                 dots.GoAssociationInstanceLoe gail,
                 dots.GoAssocInstEvidCode gaiec, sres.GoEvidenceCode gec,
                 (SELECT gr.child_term_id AS go_term_id, gp.name AS ontology
                  FROM sres.GoRelationship gr, sres.GoTerm gp
                  WHERE gr.parent_term_id = gp.go_term_id
                    AND gp.go_id in ('GO:0008150','GO:0003674','GO:0005575')) o
            WHERE gf.na_feature_id = t.parent_id
              AND t.na_feature_id = taf.na_feature_id
              AND taf.aa_sequence_id = ga.row_id
              AND ga.table_id = (SELECT table_id
                                 FROM core.TableInfo
                                 WHERE name = 'TranslatedAASequence')
              AND ga.go_term_id = gt.go_term_id
              AND ga.go_association_id = gai.go_association_id
              AND gai.go_assoc_inst_loe_id = gail.go_assoc_inst_loe_id
              AND gai.go_association_instance_id
                  = gaiec.go_association_instance_id
              AND gaiec.go_evidence_code_id = gec.go_evidence_code_id
              AND gt.go_term_id = o.go_term_id)
      GROUP BY source_id, ontology, source)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GeneGoAttributes NOLOGGING AS
SELECT DISTINCT gene.source_id,
       substr(annotated_go_component.go_terms, 1, 300) AS annotated_go_component,
       substr(annotated_go_function.go_terms, 1, 300) AS annotated_go_function,
       substr(annotated_go_process.go_terms, 1, 300) AS annotated_go_process,
       substr(predicted_go_component.go_terms, 1, 300) AS predicted_go_component,
       substr(predicted_go_function.go_terms, 1, 300) AS predicted_go_function,
       substr(predicted_go_process.go_terms, 1, 300) AS predicted_go_process
FROM (SELECT DISTINCT gene AS source_id FROM apidb.GeneId) gene,
     (SELECT * FROM apidb.GoTermList
      WHERE source = 'annotated' AND ontology = 'cellular_component')
       annotated_go_component,
     (SELECT * FROM apidb.GoTermList
      WHERE source = 'annotated' AND ontology = 'molecular_function')
       annotated_go_function,
     (SELECT * FROM apidb.GoTermList
      WHERE source = 'annotated' AND ontology = 'biological_process')
       annotated_go_process,
     (SELECT * FROM apidb.GoTermList
      WHERE source = 'predicted' AND ontology = 'cellular_component')
       predicted_go_component,
     (SELECT * FROM apidb.GoTermList
      WHERE source = 'predicted' AND ontology = 'molecular_function')
       predicted_go_function,
     (SELECT * FROM apidb.GoTermList
      WHERE source = 'predicted' AND ontology = 'biological_process')
       predicted_go_process
WHERE gene.source_id = annotated_go_component.source_id(+)
  AND 'annotated' = annotated_go_component.source(+)
  AND 'cellular_component' = annotated_go_component.ontology(+)
  AND gene.source_id = annotated_go_function.source_id(+)
  AND 'annotated' = annotated_go_function.source(+)
  AND 'molecular_function' = annotated_go_function.ontology(+)
  AND gene.source_id = annotated_go_process.source_id(+)
  AND 'annotated' = annotated_go_process.source(+)
  AND 'biological_process' = annotated_go_process.ontology(+)
  AND gene.source_id = predicted_go_component.source_id(+)
  AND 'predicted' = predicted_go_component.source(+)
  AND 'cellular_component' = predicted_go_component.ontology(+)
  AND gene.source_id = predicted_go_function.source_id(+)
  AND 'predicted' = predicted_go_function.source(+)
  AND 'molecular_function' = predicted_go_function.ontology(+)
  AND gene.source_id = predicted_go_process.source_id(+)
  AND 'predicted' = predicted_go_process.source(+)
  AND 'biological_process' = predicted_go_process.ontology(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneGoAttr_sourceId ON apidb.GeneGoAttributes (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.DerisiExpn NOLOGGING AS
SELECT gene.source_id, expn.derisi_max_level, derisi_max_pct,
       derisi_max_timing, derisi_min_timing, derisi_min_level,
       max_fold_induction as derisi_max_fold_induction
FROM (SELECT DISTINCT gene AS source_id from apidb.GeneId) gene,
     (SELECT * FROM (SELECT p.source_id,
                            p.max_expression AS derisi_max_level,
                            p.equiv_max AS derisi_max_timing,
                            p.equiv_min AS derisi_min_timing,
                            p.min_expression AS derisi_min_level,
                            p.ind_ratio as max_fold_induction,
                            row_number() over (partition by p.source_id order by p.ind_ratio desc) row_number
                     FROM apidb.Profile p, apidb.ProfileSet ps
                     WHERE ps.name like 'DeRisi % Smoothed'
                       AND p.profile_set_id = ps.profile_set_id)
      WHERE row_number = 1) expn,
     (SELECT p.source_id, max(p.max_percentile) as derisi_max_pct
      FROM apidb.Profile p, apidb.ProfileSet ps
      WHERE ps.name like 'DeRisi % Smoothed'
        AND p.profile_set_id = ps.profile_set_id
      GROUP BY p.source_id) percentile
WHERE gene.source_id = expn.source_id(+)
  AND gene.source_id = percentile.source_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Derisi_sourceId ON apidb.DerisiExpn (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.WinzelerExpn NOLOGGING AS
SELECT gene.source_id, expn.winzeler_max_level, winzeler_max_pct,
       winzeler_max_timing, winzeler_min_timing, winzeler_min_level
FROM (SELECT DISTINCT gene AS source_id from apidb.GeneId) gene,
     (SELECT p.source_id,
             p.max_expression AS winzeler_max_level,
             p.max_percentile AS winzeler_max_pct,
             p.time_of_max_expr AS winzeler_max_timing,
             p.time_of_min_expr AS winzeler_min_timing,
             p.min_expression AS winzeler_min_level
      FROM apidb.Profile p, apidb.ProfileSet ps, core.TableInfo ti
      WHERE ps.name = 'winzeler_cc_sorbExp'
        AND ti.name = 'GeneFeature'
        AND p.profile_set_id = ps.profile_set_id
        AND ti.table_id = p.subject_table_id) expn
WHERE gene.source_id = expn.source_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Winzeler_sourceId ON apidb.WinzelerExpn (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.ToxoExpn NOLOGGING AS
select g.source_id, 
       type3_type1_fold_change,
       type3_type2_fold_change,
       type2_type1_fold_change
From dots.genefeature g, 
     (select gf.source_id, dr.fold_change as type3_type1_fold_change
      from rad.analysis a, rad.differentialexpression dr, 
           core.tableinfo t, dots.genefeature gf
      where a.analysis_id = dr.analysis_id
       and dr.table_id = t.table_id
       and dr.row_id = gf.na_feature_id
       and t.name = 'GeneFeature'
       and a.name = 'Type3vsType1') type3vstype1,
 (select gf.source_id, dr.fold_change as type3_type2_fold_change
      from rad.analysis a, rad.differentialexpression dr, 
           core.tableinfo t, dots.genefeature gf
      where a.analysis_id = dr.analysis_id
       and dr.table_id = t.table_id
       and dr.row_id = gf.na_feature_id
       and t.name = 'GeneFeature'
       and a.name = 'Type3vsType2') type3vstype2,
 (select gf.source_id, dr.fold_change as type2_type1_fold_change
      from rad.analysis a, rad.differentialexpression dr, 
           core.tableinfo t, dots.genefeature gf
      where a.analysis_id = dr.analysis_id
       and dr.table_id = t.table_id
       and dr.row_id = gf.na_feature_id
       and t.name = 'GeneFeature'
       and a.name = 'Type2vsType1') type2vstype1
where g.source_id = type3vstype1.source_id
 and g.source_id = type3vstype2.source_id
 and g.source_id = type2vstype1.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Toxo_sourceId ON apidb.ToxoExpn (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GeneProteinAttributes NOLOGGING AS
SELECT gene.source_id,
       protein.tm_count, protein.molecular_weight,
       protein.isoelectric_point, protein.min_molecular_weight,
       protein.max_molecular_weight, protein.hydropathicity_gravy_score,
       protein.aromaticity_score, protein.cds_length, protein.protein_length,
       protein.ec_numbers,
       protein.signalp_scores, protein.signalp_peptide, protein.aa_sequence_id
FROM (SELECT DISTINCT gene AS source_id from apidb.GeneId) gene,
     (SELECT gf.source_id, taf.na_feature_id, tas.aa_sequence_id,tas.molecular_weight,
             tas.length AS protein_length,
             greatest(taf.translation_start, taf.translation_stop)
             - least(taf.translation_start, taf.translation_stop) + 1 AS cds_length,
             asa.isoelectric_point,
             asa.min_molecular_weight, asa.max_molecular_weight,
             asa.hydropathicity_gravy_score,
             asa.aromaticity_score,
             NVL(transmembrane.tm_domains, 0) AS tm_count,
             ec.ec_numbers,
             sigp.scores as signalp_scores,
             substr(sigp.pep, 1, 200) as signalp_peptide
      FROM  dots.GeneFeature gf, dots.Transcript t,
            dots.TranslatedAaFeature taf,
            dots.TranslatedAaSequence tas,
            apidb.AaSequenceAttribute asa,
            (SELECT aa_sequence_id, max(tm_domains) AS tm_domains
             FROM (SELECT tmaf.aa_sequence_id, COUNT(*) AS tm_domains
                   FROM dots.TransmembraneAaFeature tmaf, dots.AaLocation al
                   WHERE tmaf.aa_feature_id = al.aa_feature_id
                   GROUP BY tmaf.aa_sequence_id) tms
             GROUP BY tms.aa_sequence_id) transmembrane,
            (SELECT aa_sequence_id,
                    SUBSTR(apidb.tab_to_string(CAST(COLLECT(ec_number order by ec_number)
                                               AS apidb.varchartab), '; '),
                           1, 300)
                      AS ec_numbers
             FROM (SELECT DISTINCT asec.aa_sequence_id,
                          ec.ec_number || ' (' || ec.description || ')' AS ec_number
                   FROM dots.aaSequenceEnzymeClass asec, sres.enzymeClass ec
                   WHERE ec.enzyme_class_id = asec.enzyme_class_id)
             GROUP BY aa_sequence_id) ec,
             (SELECT spf.aa_sequence_id,'NN Sum: ' || ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) ||
              ', NN D: ' || round(((spf.means_score + spf.maxy_score) / 2),2) || ', HMM Prob: ' || round(spf.signal_probability,2) as scores,
               apidb.tab_to_string(CAST(COLLECT(decode(spf.algorithm_name,'SignalPhmm','HMM: ','NN: ') || dbms_lob.substr(s.sequence,aal.end_max,1) order by spf.algorithm_name, dbms_lob.substr(s.sequence, aal.end_max, 1)) AS apidb.varchartab), ', ') as pep
              FROM dots.signalpeptidefeature spf, dots.aalocation aal,dots.AASEQUENCE s
              WHERE spf.aa_sequence_id = s.aa_sequence_id 
              and  aal.aa_feature_id = spf.aa_feature_id
              and (spf.signal_probability >= .5
              or ((spf.means_score + spf.maxy_score) / 2) >= .5
              or ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) >= 3)
              group by spf.aa_sequence_id,'NN Sum: ' || ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) ||
              ', NN D: ' || round(((spf.means_score + spf.maxy_score) / 2),2) || ', HMM Prob: ' || round(spf.signal_probability,2)) sigp
      WHERE gf.na_feature_id = t.parent_id
        AND t.na_feature_id = taf.na_feature_id
        AND taf.aa_sequence_id = tas.aa_sequence_id
        AND taf.aa_sequence_id = asa.aa_sequence_id
        and tas.aa_sequence_id = sigp.aa_sequence_id(+)
        AND tas.aa_sequence_id = transmembrane.aa_sequence_id(+)
        AND tas.aa_sequence_id = ec.aa_sequence_id(+)) protein
WHERE gene.source_id = protein.source_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GPA_sourceId ON apidb.GeneProteinAttributes (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GeneAttributes&1 NOLOGGING AS
SELECT cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       gf.source_id, gf.na_feature_id,
       REPLACE(so.term_name, '_', ' ') AS gene_type,
       SUBSTR(COALESCE(preferred_product.product, any_product.product, gf.product, 'unspecified product'), 1, 300) AS product,
       COALESCE(preferred_name.name, any_name.name) AS name,
       gf.is_pseudo,
       LEAST(nl.start_min, nl.end_max) AS start_min,
       GREATEST(nl.start_min, nl.end_max) AS end_max,
       CASE
         WHEN nl.is_reversed = 1
           THEN coding_range.max_coding_start
         ELSE coding_range.min_coding_start
       END as coding_start,
       CASE
         WHEN nl.is_reversed = 1
           THEN coding_range.min_coding_end
         ELSE coding_range.max_coding_end
       END as coding_end,
       nl.is_reversed,
       sns.length AS transcript_length,
       GREATEST(1, least(nl.start_min, nl.end_max) - 15000)
           AS context_start,
       LEAST(sequence.length, greatest(nl.start_min, nl.end_max) + 15000)
           AS context_end,
       DECODE(nvl(nl.is_reversed, 0), 0, 'forward', 1, 'reverse',
              nl.is_reversed) AS strand,
       SUBSTR(sequence.source_id, 1, 50) AS sequence_id,
       SUBSTR(tn.name, 1, 100) AS organism,
       SUBSTR(species_name.name, 1, 100) AS species,
       taxon.ncbi_tax_id,
       so_id, SUBSTR(so.term_name, 1, 150) AS so_term_name,
       SUBSTR(so.definition, 1, 150) AS so_term_definition,
       so.ontology_name, SUBSTR(so.so_version, 1, 7) AS so_version,
       SUBSTR(NVL(rt1.anticodon, rt2.anticodon), 1, 3) AS anticodon,
       protein.tm_count, protein.molecular_weight,
       protein.isoelectric_point, protein.min_molecular_weight,
       protein.max_molecular_weight, protein.hydropathicity_gravy_score,
       protein.aromaticity_score, protein.cds_length, protein.protein_length,
       protein.ec_numbers,
       ed.name AS external_db_name,
       SUBSTR(edr.version, 1, 10) AS external_db_version,
       exons.exon_count, SUBSTR(cmnt.comment_string, 1, 300) AS comment_string,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.chromosome_order_num, sequence.na_sequence_id,
       go.annotated_go_component,
       go.annotated_go_function,
       go.annotated_go_process,
       go.predicted_go_component,
       go.predicted_go_function,
       go.predicted_go_process,
       DerisiExpn.derisi_max_level,
       DerisiExpn.derisi_max_pct,
       DerisiExpn.derisi_max_timing,
       DerisiExpn.derisi_min_timing,
       DerisiExpn.derisi_min_level,
       DerisiExpn.derisi_max_fold_induction,
       WinzelerExpn.winzeler_max_level,
       WinzelerExpn.winzeler_max_pct,
       WinzelerExpn.winzeler_max_timing,
       WinzelerExpn.winzeler_min_timing,
       WinzelerExpn.winzeler_min_level,
       ToxoExpn.type3_type1_fold_change,
       ToxoExpn.type3_type2_fold_change,
       ToxoExpn.type2_type1_fold_change,
       nvl(deprecated.is_deprecated, 0) as is_deprecated, gi.gene_id,
       substr(orthologs.name, 1, 60) as orthomcl_name,
       nvl(totsnps.total_snps,0) as total_snps, 
       nvl(nssnps.nonsyn_snps,0) as nonsynonymous_snps,
       nvl(synsnps.syn_snps,0) as synonymous_snps,
       CASE WHEN (nssnps.nonsyn_snps is null or synsnps.syn_snps is null) THEN 0 
            ELSE round((nssnps.nonsyn_snps / synsnps.syn_snps),2) END as nonsyn_syn_ratio,
       protein.signalp_scores,protein.signalp_peptide, sequence.taxon_id, protein.aa_sequence_id
FROM dots.GeneFeature gf, apidb.FeatureLocation nl, sres.SequenceOntology so,
     sres.Taxon, sres.TaxonName tn, dots.RnaType rt1, dots.RnaType rt2,
     dots.Transcript t, sres.ExternalDatabase ed,
     sres.ExternalDatabaseRelease edr, dots.SplicedNaSequence sns,
     apidb.GeneProteinAttributes protein, apidb.GeneGoAttributes go,
     apidb.DerisiExpn DerisiExpn, apidb.WinzelerExpn WinzelerExpn,
     apidb.ToxoExpn ToxoExpn, apidb.GenomicSequence sequence,
     dots.geneinstance gi, apidb.TaxonSpecies ts, sres.TaxonName species_name,
     (SELECT parent_id, count(*) AS exon_count
      FROM dots.ExonFeature
      GROUP BY parent_id) exons,
     (SELECT parent_id, max(coding_start) as max_coding_start, min(coding_start) as min_coding_start,
             max(coding_end) as max_coding_end, min(coding_end) as min_coding_end
      FROM apidb.FeatureLocation
      WHERE feature_type = 'ExonFeature'
        AND is_top_level = 1
      GROUP BY parent_id) coding_range,
     (SELECT nfc.na_feature_id,
             MAX(DBMS_LOB.SUBSTR(nfc.comment_string, 300, 1))
               AS comment_string
      FROM dots.NaFeatureComment nfc
      GROUP BY nfc.na_feature_id) cmnt,
     (select distinct gf.source_id, 1 as is_deprecated
      from dots.GeneFeature gf, dots.DbRefNaFeature drnf, sres.DbRef dr, sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      where gf.na_feature_id = drnf.na_feature_id
        and drnf.db_ref_id = dr.db_ref_id
        and dr.external_database_release_id = edr.external_database_release_id
        and edr.external_database_id = ed.external_database_id
        and ed.name = 'deprecated genes') deprecated,
     (select sf.parent_id,count(*) as total_snps
      from dots.snpfeature sf, sres.externaldatabaserelease rel, sres.EXTERNALDATABASE d
      where d.name not in ('Pf_Broad_SNPs_RSRC','Broad SNPs','Sanger falciparum SNPs','sangerItGhanaSnps_RSRC',
            'Winzeler Array - Plasmodium Genetic Variation','WinzelerGeneticVariationArray_RSRC','X.Su SNPs','Pf_XSuSnps_RSRC','Sanger reichenowi SNPs','sangerPReichenowiSnps_RSRC')
      and d.external_database_id = rel.external_database_id
      and sf.external_database_release_id = rel.external_database_release_id
      and sf.parent_id is not null
      group by sf.parent_id) totsnps,
     (select sf.parent_id,count(*) as nonsyn_snps
      from dots.snpfeature sf, sres.externaldatabaserelease rel, sres.EXTERNALDATABASE d
      where d.name not in ('Pf_Broad_SNPs_RSRC','Broad SNPs','Sanger falciparum SNPs','sangerItGhanaSnps_RSRC',
             'Winzeler Array - Plasmodium Genetic Variation','WinzelerGeneticVariationArray_RSRC','X.Su SNPs','Pf_XSuSnps_RSRC','Sanger reichenowi SNPs','sangerPReichenowiSnps_RSRC')
        and d.external_database_id = rel.external_database_id
        and sf.external_database_release_id = rel.external_database_release_id
        and sf.parent_id is not null
        and sf.has_nonsynonymous_allele = 1
      group by sf.parent_id) nssnps,
     (select sf.parent_id,count(*) as syn_snps
      from dots.snpfeature sf, sres.externaldatabaserelease rel, sres.EXTERNALDATABASE d
      where d.name not in ('Pf_Broad_SNPs_RSRC','Broad SNPs','Sanger falciparum SNPs','sangerItGhanaSnps_RSRC',
             'Winzeler Array - Plasmodium Genetic Variation','WinzelerGeneticVariationArray_RSRC','X.Su SNPs','Pf_XSuSnps_RSRC','Sanger reichenowi SNPs','sangerPReichenowiSnps_RSRC')
        and d.external_database_id = rel.external_database_id
        and sf.external_database_release_id = rel.external_database_release_id
        and sf.parent_id is not null
        and sf.has_nonsynonymous_allele is null
        and sf.is_coding = 1
      group by sf.parent_id) synsnps,
     (  select gf.na_feature_id, sg.name
        from dots.genefeature gf, dots.sequencesequencegroup ssg, 
             dots.sequencegroup sg, Core.tableinfo ti
        where gf.na_feature_id = ssg.sequence_id
          and ssg.sequence_group_id = sg.sequence_group_id
          and ssg.source_table_id = ti.table_id
          and ti.name = 'GeneFeature'
      UNION
        select chr6.na_feature_id, sg.name
        from (select co.group_id, gf.source_id 
              from apidb.chromosome6orthology co, dots.genefeature gf,
                   sres.taxonname tn, dots.nasequence s
              where co.source_id = gf.source_id
               and gf.na_sequence_id = s.na_sequence_id
               and tn.taxon_id = s.taxon_id
               and tn.name = 'Cryptosporidium parvum Iowa II'
             ) par, 
             (select co.group_id, gf.source_id, gf.na_feature_id
              from apidb.chromosome6orthology co, dots.genefeature gf,
                   sres.taxonname tn, dots.nasequence s
              where co.source_id = gf.source_id
               and gf.na_sequence_id = s.na_sequence_id
               and tn.taxon_id = s.taxon_id
               and tn.name = 'Cryptosporidium parvum'
             ) chr6, 
             dots.genefeature gf, dots.sequencegroup sg, dots.sequencesequencegroup ssg
        where chr6.group_id = par.group_id
         and par.source_id = gf.source_id
         and gf.na_feature_id = ssg.sequence_id
         and ssg.sequence_group_id = sg.sequence_group_id
       ) orthologs,
     (select na_feature_id, max(product) as product
      from apidb.GeneFeatureProduct
      where is_preferred = 1
      group by na_feature_id
     ) preferred_product,
     (select na_feature_id, max(product) as product
      from apidb.GeneFeatureProduct
      group by na_feature_id
     ) any_product,
     (select na_feature_id, max(name) as name
      from apidb.GeneFeatureName
      where is_preferred = 1
      group by na_feature_id
     ) preferred_name,
     (select na_feature_id, max(name) as name
      from apidb.GeneFeatureName
      group by na_feature_id
     ) any_name
WHERE gf.source_id is not null
  AND gf.na_feature_id = nl.na_feature_id
  AND nl.is_top_level = 1
  AND nl.na_sequence_id = sequence.na_sequence_id
  AND gf.sequence_ontology_id = so.sequence_ontology_id
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
  AND gf.source_id = protein.source_id(+)
  AND gf.source_id = go.source_id(+)
  AND gf.source_id = DerisiExpn.source_id(+)
  AND gf.source_id = WinzelerExpn.source_id(+)
  AND gf.source_id = ToxoExpn.source_id(+)
  AND t.na_sequence_id = sns.na_sequence_id(+)
  AND gf.na_feature_id = t.parent_id(+)
  AND t.na_feature_id = rt1.parent_id(+)
  AND gf.na_feature_id = rt2.parent_id(+)
  AND gf.external_database_release_id
       = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND gf.na_feature_id = exons.parent_id(+)
  AND gf.na_feature_id = orthologs.na_feature_id(+)
  AND gf.na_feature_id = coding_range.parent_id(+)
  AND gf.na_feature_id = cmnt.na_feature_id(+)
  AND gf.source_id = deprecated.source_id(+)
  AND gf.na_feature_id = gi.na_feature_id(+)
  AND gf.na_feature_id = totsnps.parent_id(+)
  AND gf.na_feature_id = nssnps.parent_id(+)
  AND gf.na_feature_id = synsnps.parent_id(+)
  AND sequence.taxon_id = ts.taxon_id(+)
  AND ts.species_taxon_id = species_name.taxon_id
  AND species_name.name_class = 'scientific name'
  -- skip toxo predictions (except tRNAs)
  -- skip new plasmo annotation
  AND ed.name NOT IN ('GLEAN predictions', 'GlimmerHMM predictions',
                      'TigrScan', 'TwinScan predictions',
                      'TwinScanEt predictions',
                      'Annotation for T. gondii ME49 - typeII:2005-08-01',
                      'Old annotation for ME49','P. falciparum Evigan Gene Models','Evigan_RSRC',
                      'P. yoelii Provisional Annotations from Kappe','Pyoelii_Kappe_Annotation_RSRC',
                      'Sanger P. falciparum old annotations','Pfalciparum_old_annotations_RSRC',
                      'Pfalciparum workshop annotations reviewed and changed',
                      'Annotation for T. gondii ME49 - typeII:2005-08-01',
                      'Tbrucei427_AutoMAGI_Annotations_RSRC'
)
  AND gf.na_feature_id = preferred_product.na_feature_id(+)
  AND gf.na_feature_id = preferred_name.na_feature_id(+)
  AND gf.na_feature_id = any_product.na_feature_id(+)
  AND gf.na_feature_id = any_name.na_feature_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.GeneAttr_sourceId&1
       ON apidb.GeneAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.GeneAttr_srcPrj&1
       ON apidb.GeneAttributes&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneAttr_exon_ix&1
       ON apidb.GeneAttributes&1 (exon_count, source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneAttr_loc_ix&1
       ON apidb.GeneAttributes&1 (na_sequence_id, start_min, end_max, is_reversed)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneAttr_feat_ix&1
       ON apidb.GeneAttributes&1 (na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneAttr_geneid_ix&1
       ON apidb.GeneAttributes&1 (gene_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneAttr_orthoname_ix&1
       ON apidb.GeneAttributes&1 (orthomcl_name, source_id, taxon_id, gene_type)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneAttr_ortholog_ix&1
       ON apidb.GeneAttributes&1 (source_id, na_sequence_id, start_min, end_max, orthomcl_name)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
  update apidb.geneattributes&1
  set exon_count = 1
  where exon_count > 1
   and project_id = 'TriTrypDB' 
   and source_id in (
                select source_id from apidb.GeneAttributes&1
              minus
                select source_id
                from (
                  select 'intron' as type, ga.source_id,
                          abs(rightLoc.start_min - leftLoc.end_max) as len
                  from dots.ExonFeature left, apidb.FeatureLocation leftLoc,
                       dots.ExonFeature right, apidb.FeatureLocation rightLoc,
                       apidb.geneattributes&1 ga
                  where left.parent_id = right.parent_id
                    and left.parent_id = ga.na_feature_id
                    and (left.order_number = right.order_number - 1
                         or left.order_number = right.order_number + 1)
                    and leftLoc.start_min < rightLoc.start_min
                    and left.na_feature_id = leftLoc.na_feature_id
                    and leftLoc.is_top_level = 1
                    and right.na_feature_id = rightLoc.na_feature_id
                    and rightLoc.is_top_level = 1
                   ) 
               group by source_id
               having min(len) > 10
           )
      ]]>
    </sql>
    <sql>
      <![CDATA[
update apidb.GENEATTRIBUTES&1 ga
set ga.orthomcl_name = (select distinct gb.orthomcl_name from GENEATTRIBUTES&1 gb
                     where gb.gene_id = ga.GENE_ID
                     and gb.orthomcl_name is not null
                     and gb.source_id != gb.orthomcl_name)
where ga.organism like 'Toxo%' 
and ga.ORTHOMCL_NAME is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update apidb.GENEATTRIBUTES&1
        set orthomcl_name = 'ORTH_' || gene_id || '.tmp'
        where orthomcl_name is null
        and gene_id is not null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update apidb.GENEATTRIBUTES&1
        set orthomcl_name = source_id
        where orthomcl_name is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
       alter table apidb.GENEATTRIBUTES&1
       add (
            paralog_number number,
            ortholog_number number
            )
      ]]>
    </sql>
    <sql>
      <![CDATA[
       update apidb.geneattributes&1 set ortholog_number = 0,paralog_number = 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
       update apidb.GENEATTRIBUTES&1 gaup
       set paralog_number = (select count(*)
                               from apidb.GENEATTRIBUTES&1 g1
                               where g1.orthomcl_name = gaup.orthomcl_name
                               and g1.organism = gaup.organism
                               and gaup.source_id != g1.source_id),
           ortholog_number = (select count(*)
                               from apidb.GENEATTRIBUTES&1 g1
                               where g1.orthomcl_name = gaup.orthomcl_name
                               and g1.organism != gaup.organism)
        where gaup.gene_type = 'protein coding'
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.GenomicSequence">
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.SequenceOntology"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GenomicSequence&1 NOLOGGING AS
  SELECT ens.na_sequence_id, ens.taxon_id,
         SUBSTR(ens.source_id, 1, 50) AS source_id,
         LOWER(SUBSTR(ens.source_id, 1, 50)) AS lowercase_source_id,
         ens.a_count, ens.c_count, ens.g_count, ens.t_count, ens.length,
         SUBSTR(ens.description, 1, 400) AS description,
         ens.external_database_release_id,
         SUBSTR(ens.chromosome, 1, 40) AS chromosome,
         ens.chromosome_order_num, ens.sequence_ontology_id
  FROM dots.ExternalNaSequence ens, sres.SequenceOntology so
  WHERE ens.sequence_ontology_id = so.sequence_ontology_id
    AND so.term_name != 'EST'
    AND so.term_name != 'oligo'
    AND -- see both? use the VirtualSequence.
        ens.source_id IN (SELECT source_id FROM dots.ExternalNaSequence
                         MINUS
                          SELECT source_id FROM dots.VirtualSequence)
UNION
  SELECT na_sequence_id, taxon_id, SUBSTR(source_id, 1, 50) AS source_id,
         LOWER(SUBSTR(source_id, 1, 50)) AS lowercase_source_id,
         a_count, c_count, g_count, t_count, length,
         SUBSTR(description, 1, 400) AS description,
         external_database_release_id, SUBSTR(chromosome, 1, 40) AS chromosome,
         chromosome_order_num, sequence_ontology_id
  FROM dots.VirtualSequence
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GS_sourceId&1 ON apidb.GenomicSequence&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GS_lcSourceId&1 ON apidb.GenomicSequence&1 (lowercase_source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GS_naSeqId&1 ON apidb.GenomicSequence&1 (na_sequence_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SequenceAttributes">
    <internalDependency name="apidb.GenomicSequence"/>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="dots.SequencePiece"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.SequenceAttributes&1 NOLOGGING AS
SELECT cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       SUBSTR(sequence.source_id, 1, 60) AS source_id, sequence.a_count,
       sequence.c_count, sequence.g_count, sequence.t_count,
       (sequence.length
        - (sequence.a_count + sequence.c_count + sequence.g_count + sequence.t_count))
         AS other_count,
       sequence.length,
       to_char((sequence.a_count + sequence.t_count) / sequence.length * 100, '99.99')
         AS at_percent,
       SUBSTR(tn.name, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       SUBSTR(sequence.description, 1, 400) AS sequence_description,
       SUBSTR(genbank.genbank_accession, 1, 20) AS genbank_accession,
       SUBSTR(db.database_version, 1, 30) AS database_version, db.database_name,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.chromosome_order_num, so.so_id,
       nvl(virtualization.is_top_level, 1) as is_top_level,
       sequence.na_sequence_id
FROM sres.TaxonName tn, sres.Taxon, sres.SequenceOntology so,
     apidb.GenomicSequence sequence,
     (SELECT drns.na_sequence_id, max(dr.primary_identifier) AS genbank_accession
      FROM dots.dbrefNaSequence drns, sres.DbRef dr,
           sres.ExternalDatabaseRelease gb_edr, sres.ExternalDatabase gb_ed
      WHERE drns.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
            = gb_edr.external_database_release_id
        AND gb_edr.external_database_id = gb_ed.external_database_id
        AND gb_ed.name = 'GenBank'
      GROUP BY drns.na_sequence_id) genbank,
     (SELECT edr.external_database_release_id,
             edr.version AS database_version, ed.name AS database_name
      FROM sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      WHERE edr.external_database_id = ed.external_database_id) db,
     (SELECT piece_na_sequence_id, 0 as is_top_level
      FROM dots.SequencePiece) virtualization
WHERE sequence.taxon_id = tn.taxon_id(+)
  AND tn.name_class = 'scientific name'
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.sequence_ontology_id = so.sequence_ontology_id
  AND so.term_name IN ('chromosome', 'contig', 'supercontig','mitochondrial_chromosome','plastid_sequence','cloned_genomic','apicoplast_chromosome')
  AND sequence.na_sequence_id = genbank.na_sequence_id(+)
  AND sequence.external_database_release_id = db.external_database_release_id(+)
  AND sequence.na_sequence_id = virtualization.piece_na_sequence_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.pk_SeqAttr_&1 ON apidb.SequenceAttributes&1 (source_id, project_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SnpAttributes">
    <internalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.SnpAttributes&1 NOLOGGING AS
SELECT cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       snp.source_id,
       snp.na_feature_id,
       CASE WHEN ed.name in ('Pf_XSuSnps_RSRC','X.Su SNPs') THEN 'NIH SNPs'
       ELSE ed.name END AS dataset,
       CASE WHEN ed.name in ('Pf_XSuSnps_RSRC','X.Su SNPs') THEN 'Su_SNPs'
       WHEN ed.name = 'Pf_Broad_SNPs_RSRC' THEN 'Broad_SNPs'
       WHEN ed.name = 'Broad SNPs' THEN 'Broad_SNPs'
       WHEN ed.name in ('sangerItGhanaSnps_RSRC','Sanger falciparum SNPs') THEN 'sangerItGhanaSnps'
       WHEN ed.name in ('Sanger reichenowi SNPs','sangerPReichenowiSnps_RSRC') THEN 'sangerReichenowiSnps'
       WHEN ed.name in ('Pf_plasmoDbCombinedSnps_RSRC','PlasmoDB combined SNPs') THEN 'plasmoDbCombinedSnps'
       WHEN ed.name in ('Winzeler Array - Plasmodium Genetic Variation','WinzelerGeneticVariationArray_RSRC') THEN 'WinzelerGeneticVariationArray'
       WHEN ed.name = 'Genomic Sequence SNPs' THEN 'AmitAlignmentSnps'
       WHEN ed.name = 'Genetic Markers - David Sibley' THEN 'GeneticMarkers_Sibley'
       WHEN ed.name = 'John Boothroyd lab at Stanford' THEN 'ME49_SNPs'
       WHEN ed.name = 'Lindstrom 454 SNPs' THEN 'Lindstrom454Snps'
       END AS dataset_hidden,
       sequence.na_sequence_id,
       sequence.source_id AS seq_source_id,
       snp_loc.start_min,
       SUBSTR(snp.reference_strain, 1, 200) AS reference_strain,
       SUBSTR(snp.reference_na, 1, 200) AS reference_na,
       DECODE(snp.is_coding, 0, 'no', 1, 'yes') AS is_coding,
       snp.position_in_CDS,
       snp.position_in_protein,
       SUBSTR(snp.reference_aa, 1, 200) AS reference_aa,
       DECODE(snp.has_nonsynonymous_allele, 0, 'no', 1, 'yes')
         AS has_nonsynonymous_allele,
       SUBSTR(snp.major_allele, 1, 40) AS major_allele,
       SUBSTR(snp.major_product, 1, 40) AS major_product,
       SUBSTR(strain_info.minor_allele, 1, 40) AS minor_allele,
       SUBSTR(strain_info.minor_product, 1, 40) AS minor_product,
       strain_info.major_strains,strain_info.minor_strains,
       snp.major_allele_count, 
       round(snp.major_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as major_allele_frequency,
       snp.minor_allele_count,
       round(snp.minor_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as minor_allele_frequency,
       snp.major_allele_count + snp.minor_allele_count as strain_count,
       SUBSTR(snp.strains, 1, 1000) AS strains,
       SUBSTR(snp.strains_revcomp, 1, 1000) AS strains_revcomp,
       gene_info.source_id AS gene_source_id,
       DECODE(gene_info.is_reversed, 0, 'forward', 1, 'reverse')
         AS gene_strand,
       SUBSTR(DBMS_LOB.SUBSTR(sequence.sequence, 60, snp_loc.start_min - 60), 1, 60)
         AS lflank,
       SUBSTR(DBMS_LOB.SUBSTR(sequence.sequence, 60, snp_loc.start_min + 1), 1, 60)
         AS rflank,
       SUBSTR(tn.name, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       SUBSTR(chromosome_info.chromosome, 1, 20) AS chromosome,
       chromosome_info.chromosome_order_num
FROM dots.SnpFeature snp, apidb.FeatureLocation snp_loc,
     sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, sres.Taxon,
     sres.TaxonName tn, dots.NaSequence sequence,
     (SELECT gene.source_id, gene_loc.is_reversed, gene.na_feature_id,
             gene_loc.na_sequence_id
      FROM dots.GeneFeature gene, apidb.FeatureLocation gene_loc
      WHERE gene.na_feature_id = gene_loc.na_feature_id
            and gene_loc.is_top_level = 1) gene_info,
     (SELECT na_sequence_id, chromosome, chromosome_order_num
      FROM dots.ExternalNaSequence
     UNION
      SELECT na_sequence_id, chromosome, chromosome_order_num
      FROM dots.VirtualSequence
     UNION
      SELECT na_sequence_id, null as chromosome, null as chromosome_order_num
      FROM dots.NaSequence
      WHERE subclass_view not in ('ExternalNASequence', 'VirtualSequence')
     ) chromosome_info,
     (select sf.na_feature_id, 
             apidb.tab_to_string(CAST(COLLECT(distinct CASE WHEN sv.allele != sf.major_allele THEN sv.allele END order by sv.allele) AS apidb.varchartab), ', ') as minor_allele,                
             apidb.tab_to_string(CAST(COLLECT(distinct CASE WHEN sv.allele != sf.major_allele THEN sv.product END order by sv.product) AS apidb.varchartab), ', ') as minor_product,
             apidb.tab_to_string(CAST(COLLECT(CASE WHEN sv.allele != sf.major_allele THEN sv.strain END order by sv.strain) AS apidb.varchartab), ', ') as minor_strains,
             apidb.tab_to_string(CAST(COLLECT(CASE WHEN sv.allele = sf.major_allele THEN sv.strain END order by sv.strain) AS apidb.varchartab), ', ') as major_strains
      from dots.SNPFEATURE sf, dots.SEQVARIATION sv
      where sv.parent_id = sf.na_feature_id
      group by sf.na_feature_id) strain_info
WHERE edr.external_database_release_id = snp.external_database_release_id
  AND ed.external_database_id = edr.external_database_id
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
  AND snp_loc.na_feature_id = snp.na_feature_id
  AND snp_loc.is_top_level = 1
  AND sequence.na_sequence_id = snp_loc.na_sequence_id
  AND chromosome_info.na_sequence_id = snp_loc.na_sequence_id
  and strain_info.na_feature_id = snp.na_feature_id
  AND gene_info.na_feature_id(+) = snp.parent_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.SnpAttr_source_id&1 ON apidb.SnpAttributes&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create INDEX apidb.Snp_nafeat_dataset_ix&1
       ON apidb.SnpAttributes&1 (na_feature_id, dataset)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Snp_Seq_ix&1
       ON apidb.SnpAttributes&1 (na_sequence_id, dataset, start_min, na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Snp_Freq_ix&1
       ON apidb.SnpAttributes&1 (dataset,strain_count,major_allele_frequency,minor_allele_frequency)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.OrfAttributes">
    <internalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="apidb.GenomicSequence"/>
    <externalDependency name="dots.AaFeatureImp"/>
    <externalDependency name="dots.AaSequenceImp"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.OrfAttributes&1 NOLOGGING AS
SELECT distinct
       cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       SUBSTR(m.source_id, 1, 60) AS source_id,
       LOWER(SUBSTR(m.source_id, 1, 60)) AS lowercase_source_id,
       SUBSTR(tn.name, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       SUBSTR(sequence.source_id, 1, 30) AS nas_id,
       tas.length,
       nl.start_min, nl.end_max, nl.is_reversed,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.chromosome_order_num, sequence.na_sequence_id
FROM dots.Miscellaneous m, dots.TranslatedAaFeature taaf,
     dots.TranslatedAaSequence tas, sres.Taxon, sres.TaxonName tn,
     sres.SequenceOntology so, apidb.FeatureLocation nl,
     -- subquery for sequence. Can't just use apidb.GenomicSequence,
     -- which only contains records eligible to be the result of a sequence search.
     -- ORFs can be on other sequences, such as ESTs in cryptodb.
     (  select gs.na_sequence_id, gs.source_id, gs.chromosome, gs.chromosome_order_num, gs.taxon_id
        from apidb.GenomicSequence gs
      union
        select ens.na_sequence_id, ens.source_id, ens.chromosome, ens.chromosome_order_num, ens.taxon_id
        from dots.ExternalNaSequence ens
        where ens.na_sequence_id in (select distinct na_sequence_id from dots.Miscellaneous
                                  minus select na_sequence_id
                                        from apidb.GenomicSequence)) sequence
WHERE m.na_feature_id = taaf.na_feature_id
  AND taaf.aa_sequence_id = tas.aa_sequence_id
  AND sequence.na_sequence_id = nl.na_sequence_id
  AND sequence.taxon_id = tn.taxon_id
  AND sequence.taxon_id = taxon.taxon_id
  AND m.sequence_ontology_id = so.sequence_ontology_id
  AND m.na_feature_id = nl.na_feature_id
  AND nl.is_top_level = 1
  AND so.term_name = 'ORF'
  AND tn.name_class='scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.OrfAttr_source_id&1 ON apidb.OrfAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.OrfAttr_location_idx&1 ON apidb.OrfAttributes&1 (na_sequence_id, start_min, end_max, is_reversed)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.EstAttributes">
    <externalDependency name="dots.AssemblySequence"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.Est"/>
    <externalDependency name="dots.Library"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.EstAttributes&1 NOLOGGING AS
SELECT cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ens.source_id,
       e.seq_primer AS primer,
       ens.a_count,
       ens.c_count,
       ens.g_count,
       ens.t_count,
       (ens.length - (ens.a_count + ens.c_count + ens.g_count + ens.t_count))
         AS other_count,
       ens.length,
       l.dbest_name,
       NVL(l.vector, 'unknown') AS vector,
       NVL(l.stage, 'unknown') AS stage,
       SUBSTR(CASE
                WHEN tn.name = 'Giardia lamblia' THEN 'Giardia Assemblage A isolate WB' 
                ELSE tn.name
              END, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       ed.name AS external_db_name,
       nvl(best.best_alignment_count, 0) AS best_alignment_count,
       l.library_id, l.dbest_name as library_dbest_name,
       aseq.assembly_na_sequence_id, asm.source_id as assembly_source_id,
       asm.number_of_contained_sequences AS assembly_est_count
FROM dots.Est e, dots.ExternalNaSequence ens, dots.Library l, sres.Taxon,
     sres.TaxonName tn, sres.ExternalDatabase ed,
     sres.ExternalDatabaseRelease edr, sres.SequenceOntology so,
     dots.AssemblySequence aseq, dots.Assembly asm,
     (select query_na_sequence_id,max(ct) as best_alignment_count
      from (
            SELECT query_na_sequence_id, COUNT(*) AS ct
             FROM dots.BlatAlignment ba
             WHERE is_best_alignment = 1
             GROUP BY target_external_db_release_id,query_na_sequence_id)
      group by query_na_sequence_id) best
WHERE e.na_sequence_id = ens.na_sequence_id
  AND e.library_id = l.library_id
  AND ens.taxon_id = tn.taxon_id
  AND ens.taxon_id = taxon.taxon_id
  AND tn.name_class='scientific name'
  AND ens.external_database_release_id = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ens.sequence_ontology_id = so.sequence_ontology_id
  AND so.term_name = 'EST'
  AND best.query_na_sequence_id(+) = ens.na_sequence_id
  AND ens.na_sequence_id = aseq.na_sequence_id(+)
  AND aseq.assembly_na_sequence_id = asm.na_sequence_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.EstAttr_source_id&1 ON apidb.EstAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.EstAttr_seqsrc_id&1 ON apidb.EstAttributes&1 (assembly_source_id, source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.AssemblyAttributes">
    <externalDependency name="dots.Assembly"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.AssemblyAttributes&1 NOLOGGING AS
SELECT a.source_id, cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       SUBSTR(CASE
                WHEN tn.name = 'Giardia lamblia' THEN 'Giardia Assemblage A isolate WB' 
                ELSE tn.name
              END, 1, 100) AS organism,
       a.number_of_contained_sequences AS est_count,
       a.length,
       a.a_count,
       a.c_count,
       a.g_count,
       a.t_count,
       a.other_count
FROM  dots.Assembly a, sres.TaxonName tn
WHERE a.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.AsmAttr_source_id&1
ON apidb.AssemblyAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.ArrayElementAttributes">
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.ArrayElementAttributes&1 NOLOGGING AS
SELECT cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ens.source_id, ed.name AS provider,
       tn.name AS organism,
       taxon.ncbi_tax_id
FROM sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr,
     dots.ExternalNaSequence ens, sres.TaxonName tn, sres.Taxon,
     sres.SequenceOntology so
WHERE ens.external_database_release_id = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND tn.taxon_id = ens.taxon_id
  AND tn.name_class = 'scientific name'
  AND taxon.taxon_id = ens.taxon_id
  AND ens.sequence_ontology_id = so.sequence_ontology_id
  AND so.term_name = 'oligo'
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.AEAttr_source_id&1
ON apidb.ArrayElementAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.BlatAlignmentLocation">
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="dots.blatalignment"/>

    <sql>
      <![CDATA[ 
     delete from dots.blatalignment 
           where query_na_sequence_id in 
                (select s.na_sequence_id
                from sres.externaldatabase d, sres.externaldatabaserelease r, dots.externalnasequence s
                where d.external_database_id = r.external_database_id
                 and s.external_database_release_id = r.external_database_release_id
                 and d.name in ('Tcruzi_BACEnds_RSRC',
                                'Tbrucei_Genbank_BACEnds_RSRC',
                                'Lmajor_sanger_BACEnds_RSRC',
                                'Lmajor_sanger_PACEnds_RSRC',
                                'Lmajor_sanger_CosmidEnds_RSRC')
            ) and is_best_alignment != 1
      ]]> 
    </sql>
    <sql>
      <![CDATA[ 
      CREATE TABLE apidb.BlatAlignmentLocation&1 NOLOGGING AS
      SELECT blat_alignment_id, query_na_sequence_id, target_na_sequence_id,
             query_table_id, query_taxon_id, query_external_db_release_id,
             target_table_id, target_taxon_id, target_external_db_release_id,
             is_consistent, is_genomic_contaminant, unaligned_3p_bases,
             unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
             is_5p_complete, percent_identity, max_query_gap, max_target_gap,
             number_of_spans, query_start, query_end, target_start, target_end,
             is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
             is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
             tstarts, cast('direct' as varchar2(7)) as location_mapping
      FROM dots.BlatAlignment
      ]]> 
    </sql>
    <perl>
      <![CDATA[ 
      use strict;
      use lib "$ENV{GUS_HOME}/lib/perl";

      my $sql = <<SQL;
        select blat_alignment_id, query_na_sequence_id, target_na_sequence_id,
               query_table_id, query_taxon_id, query_external_db_release_id, 
               target_table_id, target_taxon_id, target_external_db_release_id,
               is_consistent, is_genomic_contaminant, unaligned_3p_bases,
               unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
               is_5p_complete, percent_identity, max_query_gap, max_target_gap,
               number_of_spans, query_start, query_end, target_start, target_end,
               is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
               is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
               tstarts, sp.virtual_na_sequence_id, sp.distance_from_left,
               sp.strand_orientation, piece.length, vti.table_id as virtual_target_table_id
        from dots.BlatAlignment ba, apidb.SequencePieceClosure sp, dots.NaSequence piece,
             dots.NaSequence virtualseq, core.TableInfo vti
        where ba.target_na_sequence_id = sp.piece_na_sequence_id(+)
          and sp.piece_na_sequence_id = piece.na_sequence_id
          and sp.virtual_na_sequence_id = virtualseq.na_sequence_id
          and virtualseq.subclass_view = vti.name
SQL
      
      my $queryHandle = $dbh->prepare($sql);
      $queryHandle->execute();

      $sql = <<SQL;
        insert into apidb.BlatAlignmentLocation&1(blat_alignment_id,
               query_na_sequence_id, target_na_sequence_id,
               query_table_id, query_taxon_id, query_external_db_release_id, 
               target_table_id, target_taxon_id, target_external_db_release_id,
               is_consistent, is_genomic_contaminant, unaligned_3p_bases,
               unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
               is_5p_complete, percent_identity, max_query_gap, max_target_gap,
               number_of_spans, query_start, query_end, target_start, target_end,
               is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
               is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
               tstarts, location_mapping)
         values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?)
SQL

      my $insertHandle = $dbh->prepare($sql);
      my ($virtual_target_start, $virtual_target_end, $virtual_tstarts);

      while (my ($blat_alignment_id, $query_na_sequence_id, $target_na_sequence_id,
               $query_table_id, $query_taxon_id, $query_external_db_release_id,
               $target_table_id, $target_taxon_id, $target_external_db_release_id,
               $is_consistent, $is_genomic_contaminant, $unaligned_3p_bases,
               $unaligned_5p_bases, $has_3p_polya, $has_5p_polya, $is_3p_complete,
               $is_5p_complete, $percent_identity, $max_query_gap, $max_target_gap,
               $number_of_spans, $query_start, $query_end, $target_start, $target_end,
               $is_reversed, $query_bases_aligned, $repeat_bases_aligned, $num_ns, $score,
               $is_best_alignment, $blat_alignment_quality_id, $blocksizes, $qstarts,
               $tstarts, $virtual_na_sequence_id, $distance_from_left,
               $strand_orientation, $length, $virtual_target_table_id)
             = $queryHandle->fetchrow_array()) {

        if ($virtual_na_sequence_id) {
          if ($strand_orientation eq '-') {
            $virtual_target_start = $distance_from_left + $length - $target_end + 1;
            $virtual_target_end = $distance_from_left + $length - $target_start + 1;
            $virtual_tstarts = &getReversedTstarts($distance_from_left,$length,$tstarts,$blocksizes);
            $blocksizes = join(',', reverse split(',', $blocksizes));
          } else {
            $virtual_target_start = $target_start + $distance_from_left;
            $virtual_target_end = $target_end + $distance_from_left;
            $virtual_tstarts = join( ',', map{ $_ + $distance_from_left } split( /,/, $tstarts));
          }

          # insert virtual locations
          $insertHandle->execute($blat_alignment_id,
                 $query_na_sequence_id, $virtual_na_sequence_id,
                 $query_table_id, $query_taxon_id, $query_external_db_release_id,
                 $virtual_target_table_id, $target_taxon_id, $target_external_db_release_id,
                 $is_consistent, $is_genomic_contaminant, $unaligned_3p_bases,
                 $unaligned_5p_bases, $has_3p_polya, $has_5p_polya, $is_3p_complete,
                 $is_5p_complete, $percent_identity, $max_query_gap, $max_target_gap,
                 $number_of_spans, $query_start, $query_end, $virtual_target_start,
                 $virtual_target_end,
                 $is_reversed, $query_bases_aligned, $repeat_bases_aligned, $num_ns, $score,
                 $is_best_alignment, $blat_alignment_quality_id, $blocksizes, $qstarts,
                 $virtual_tstarts, 'virtual');
        }
      }

      $insertHandle->finish();
      $queryHandle->finish();

sub getReversedTstarts {
  my($dfl,$len,$tstart,$blocksizes) = @_;
  my @ts = split(',',$tstart);
  my @bs = split(',',$blocksizes);
  my @new;
  for(my $a = scalar(@ts) - 1;$a >= 0;$a--){
    push(@new,($dfl + $len - $ts[$a] - $bs[$a] + 2));
  }
  return join(',',@new);
}
      ]]> 
    </perl>
  </tuningTable>


  <tuningTable name="apidb.GeneNeighbors">
    <internalDependency name="apidb.GeneAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GeneNeighbors&1 AS 
SELECT a.prev_id, a.source_id, b.next_id
FROM
(SELECT  ga.source_id, ga2.source_id AS prev_id
 FROM apidb.geneattributes ga, apidb.geneattributes ga2,
  (SELECT max(prev.end_max) AS alpha, ga.source_id
   FROM apidb.geneattributes ga, apidb.geneattributes  prev
   WHERE ga.na_sequence_id = prev.na_sequence_id 
   AND prev.end_max < ga.start_min  GROUP BY ga.source_id) sub
 WHERE ga.source_id = sub.source_id
 AND ga2.end_max = sub.alpha
 AND ga.na_sequence_id = ga2.na_sequence_id
 UNION
 SELECT  source_id, 'null' as prev_id 
 FROM (
  SELECT ga.na_sequence_id , ga.source_id
  FROM apidb.geneattributes ga, 
    (SELECT min(start_min) as min_start_min, na_sequence_id
     FROM apidb.geneattributes
     GROUP BY na_sequence_id) sub
  WHERE ga.na_sequence_id = sub.na_sequence_id
  AND ga.start_min = sub.min_start_min )
) a,
(SELECT ga.source_id, ga2.source_id as next_id
 FROM apidb.geneattributes ga, apidb.geneattributes ga2,
  (SELECT min(nxt.start_min) AS alpha, ga.source_id
   FROM apidb.geneattributes ga, apidb.geneattributes  nxt
   WHERE ga.na_sequence_id = nxt.na_sequence_id 
   AND nxt.start_min > ga.end_max group by ga.source_id) sub
 WHERE ga.source_id = sub.source_id
 AND ga2.start_min = sub.alpha
 AND ga.na_sequence_id = ga2.na_sequence_id
 UNION
 SELECT  source_id, 'null' as next_id
 FROM (
   SELECT ga.na_sequence_id , ga.source_id, 0 as alpha
   FROM apidb.geneattributes ga, 
     (SELECT max(end_max) AS max_end_max, na_sequence_id
      FROM apidb.geneattributes
      GROUP BY na_sequence_id)  sub
   WHERE ga.na_sequence_id = sub.na_sequence_id
   AND ga.end_max = sub.max_end_max )
) b
WHERE a.source_id = b.source_id
ORDER BY a.source_id
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SpliceSiteGenes">
    <internalDependency name="apidb.GeneAttributes"/>
    <internalDependency name="apidb.SequenceAttributes"/>
    <externalDependency name="apidb.SpliceSiteFeature"/>
    <intermediateTable name="apidb.SpliceSiteGeneCoordinates"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.SpliceSiteGeneCoordinates NOLOGGING AS 
select na_sequence_id, source_id, alpha, beta, gamma, delta, strand 
from (
--CASE A:  1st gene on forward strand
select ga.na_sequence_id , ga.source_id, 0 as alpha, ga.coding_start as beta, ga.end_max as gamma, 
CASE WHEN (sub3.delta < sub4.delta) THEN sub3.delta ELSE sub4.delta END AS delta, ga.strand 
from apidb.geneattributes ga, 
  (select min(coding_start) as coding_start_min, na_sequence_id from apidb.geneattributes
   where gene_type='protein coding' 
   group by na_sequence_id)  sub,
  (select min(nxt.coding_start) as delta, ga.source_id
   from apidb.geneattributes ga, apidb.geneattributes nxt
   where ga.na_sequence_id = nxt.na_sequence_id 
   and nxt.gene_type='protein coding' 
   and nxt.coding_start > ga.coding_start  group by ga.source_id) sub3,
  (select min(nxt.coding_end) as delta, ga.source_id
   from apidb.geneattributes ga, apidb.geneattributes nxt
   where ga.na_sequence_id = nxt.na_sequence_id 
   and nxt.gene_type='protein coding' 
   and nxt.coding_end > ga.coding_end group by ga.source_id) sub4    
where ga.na_sequence_id = sub.na_sequence_id
and ga.source_id = sub3.source_id and ga.source_id = sub4.source_id
and ga.coding_start = sub.coding_start_min
and ga.gene_type='protein coding' and is_reversed=0
UNION
-- CASE B: other genes on forward strand  
select ga.na_sequence_id , ga.source_id,  
CASE WHEN (sub1.alpha > sub2.alpha) THEN sub1.alpha ELSE sub2.alpha END AS alpha,  
ga.coding_start as beta, ga.end_max as gamma, 
CASE WHEN (sub3.delta < sub4.delta) THEN sub3.delta ELSE sub4.delta END AS delta, ga.strand 
 from apidb.geneattributes ga, 
   (select max(prev.coding_end) as alpha, ga.source_id
    from apidb.geneattributes ga, apidb.geneattributes prev
    where ga.na_sequence_id = prev.na_sequence_id 
    and prev.gene_type='protein coding' 
    and prev.coding_end < ga.coding_start  group by ga.source_id) sub1,
   (select max(prev.coding_start) as alpha, ga.source_id
    from apidb.geneattributes ga, apidb.geneattributes prev
    where ga.na_sequence_id = prev.na_sequence_id 
    and prev.gene_type='protein coding' 
    and prev.coding_start < ga.coding_start group by ga.source_id) sub2,
   (select min(nxt.coding_start) as delta, ga.source_id
    from apidb.geneattributes ga, apidb.geneattributes nxt
    where ga.na_sequence_id = nxt.na_sequence_id 
    and nxt.gene_type='protein coding' 
    and nxt.coding_start > ga.coding_start  group by ga.source_id) sub3,
   (select min(nxt.coding_end) as delta, ga.source_id
    from apidb.geneattributes ga, apidb.geneattributes nxt
    where ga.na_sequence_id = nxt.na_sequence_id 
    and nxt.gene_type='protein coding' 
    and nxt.coding_end > ga.coding_end group by ga.source_id) sub4    
 where ga.source_id = sub1.source_id  and ga.source_id = sub2.source_id
  and ga.source_id = sub3.source_id  and ga.source_id = sub4.source_id
  and ga.gene_type='protein coding' and ga.is_reversed=0
UNION
--CASE C:  last gene on reverse strand
select ga.na_sequence_id , ga.source_id, ga.start_min as alpha, ga.coding_start as beta, sa.length as gamma, 
CASE WHEN (sub3.delta < sub4.delta) THEN sub3.delta ELSE sub4.delta END AS delta, ga.strand  
  from apidb.geneattributes ga, apidb.sequenceattributes sa,
    (select max(end_max) as max_end_max, na_sequence_id from apidb.geneattributes
     where gene_type='protein coding'
     group by na_sequence_id)  sub,
    (select max(nxt.coding_start) as delta, ga.source_id
     from apidb.geneattributes ga, apidb.geneattributes  nxt
     where ga.na_sequence_id = nxt.na_sequence_id 
     and nxt.gene_type='protein coding'
     and nxt.coding_start < ga.coding_end  group by ga.source_id) sub3,
    (select max(nxt.coding_end) as delta, ga.source_id
     from apidb.geneattributes ga, apidb.geneattributes  nxt
     where ga.na_sequence_id = nxt.na_sequence_id 
     and nxt.gene_type='protein coding'
     and nxt.coding_end < ga.coding_start group by ga.source_id) sub4
  where ga.na_sequence_id = sub.na_sequence_id
  and ga.source_id = sub3.source_id  and ga.source_id = sub4.source_id
  and sa.na_sequence_id = ga.na_sequence_id
  and ga.end_max = sub.max_end_max and ga.is_reversed=1
UNION
--CASE D: other genes on reverse strand
select ga.na_sequence_id , ga.source_id, ga.start_min as alpha, ga.coding_start as beta, 
CASE WHEN (sub1.gamma < sub2.gamma) THEN sub1.gamma ELSE sub2.gamma END AS gamma, 
CASE WHEN (sub3.delta < sub4.delta) THEN sub3.delta ELSE sub4.delta END AS delta, ga.strand 
  from apidb.geneattributes ga, 
    (select min(prev.coding_end) as gamma, ga.source_id
     from apidb.geneattributes ga, apidb.geneattributes  prev
     where ga.na_sequence_id = prev.na_sequence_id 
     and prev.gene_type='protein coding'
     and prev.coding_end > ga.coding_end  group by ga.source_id) sub1,
    (select min(prev.coding_start) as gamma, ga.source_id
     from apidb.geneattributes ga, apidb.geneattributes  prev
     where ga.na_sequence_id = prev.na_sequence_id 
     and prev.gene_type='protein coding'
     and prev.coding_start > ga.coding_start group by ga.source_id) sub2,
    (select max(nxt.coding_start) as delta, ga.source_id
     from apidb.geneattributes ga, apidb.geneattributes  nxt
     where ga.na_sequence_id = nxt.na_sequence_id 
     and nxt.gene_type='protein coding'
     and nxt.coding_start < ga.coding_end  group by ga.source_id) sub3,
    (select max(nxt.coding_end) as delta, ga.source_id
     from apidb.geneattributes ga, apidb.geneattributes  nxt
     where ga.na_sequence_id = nxt.na_sequence_id 
     and nxt.gene_type='protein coding'
     and nxt.coding_end < ga.coding_start group by ga.source_id) sub4
  where ga.source_id = sub1.source_id and ga.source_id = sub2.source_id
   and ga.source_id = sub3.source_id and ga.source_id = sub4.source_id
   and ga.gene_type='protein coding' and ga.is_reversed=1
 ) 
where na_sequence_id in (select distinct na_sequence_id from apidb.splicesitefeature) 
order by na_sequence_id, alpha
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.SpliceSiteGenes&1 NOLOGGING AS
select * from
(select ssf.location, ssf.strand, ga.source_id, abs(ga.beta-ssf.location) as dist_to_cds,
CASE WHEN (ssf.location>ga.beta) THEN 1 ELSE 0 END as within_cds,
ssf.sample_name, ssf.count, ssf.count_per_million, ssf.avg_mismatches, ssf.is_unique,
ssf.type, ssf.na_sequence_id, ssf.external_database_release_id
from apidb.splicesitefeature ssf, apidb.SpliceSiteGeneCoordinates ga
where ga.na_sequence_id = ssf.na_sequence_id
and ga.strand='forward'
and ssf.strand ='+' and ssf.type='Splice Site' 
and ssf.location<= ga.gamma and ssf.location>= ga.alpha
UNION
select ssf.location, ssf.strand, ga.source_id, abs(ga.beta-ssf.location) as dist_to_cds,
CASE WHEN (ssf.location<ga.beta) THEN 1 ELSE 0 END as within_cds,
ssf.sample_name, ssf.count, ssf.count_per_million, ssf.avg_mismatches, ssf.is_unique,
ssf.type, ssf.na_sequence_id, ssf.external_database_release_id
from apidb.splicesitefeature ssf, apidb.SpliceSiteGeneCoordinates ga
where ga.na_sequence_id = ssf.na_sequence_id
and ga.strand='reverse'
and ssf.strand ='-' and ssf.type='Splice Site' 
and ssf.location<= ga.gamma and ssf.location>= ga.alpha
UNION
select ssf.location, ssf.strand, ga.source_id, abs(ga.gamma-ssf.location) as dist_to_cds,
CASE WHEN (ssf.location<ga.gamma) THEN 1 ELSE 0 END as within_cds,
ssf.sample_name, ssf.count, ssf.count_per_million, ssf.avg_mismatches, ssf.is_unique,
ssf.type, ssf.na_sequence_id, ssf.external_database_release_id
from apidb.splicesitefeature ssf, apidb.SpliceSiteGeneCoordinates ga
where ga.na_sequence_id = ssf.na_sequence_id
and ga.strand='forward'
and ssf.strand ='-' and ssf.type='Poly A' 
and ssf.location<= ga.delta and ssf.location>= ga.beta
UNION
select ssf.location, ssf.strand, ga.source_id, abs(ga.alpha-ssf.location) as dist_to_cds,
CASE WHEN (ssf.location>ga.alpha) THEN 1 ELSE 0 END as within_cds,
ssf.sample_name, ssf.count, ssf.count_per_million, ssf.avg_mismatches, ssf.is_unique,
ssf.type, ssf.na_sequence_id, ssf.external_database_release_id
from apidb.splicesitefeature ssf, apidb.SpliceSiteGeneCoordinates ga
where ga.na_sequence_id = ssf.na_sequence_id
and ga.strand='reverse'
and ssf.strand ='+' and ssf.type='Poly A' 
and ssf.location>= ga.delta and ssf.location<= ga.beta
)
order by na_sequence_id, location
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.ssg_ix&1
on apidb.SpliceSiteGenes&1 (source_id, na_sequence_id, location, type)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.EstAlignmentGeneSummary">
    <internalDependency name="apidb.GenomicSequence"/>
    <internalDependency name="apidb.GeneAttributes"/>
    <internalDependency name="apidb.BlatAlignmentLocation"/>
    <externalDependency name="dots.AssemblySequence"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.Est"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.SequenceOntology"/>
    <intermediateTable name="apidb.EstAlignmentGene"/>
    <intermediateTable name="apidb.EstAlignmentNoGene"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.EstAlignmentGene NOLOGGING AS
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, e.accession,
         e.library_id, ba.query_taxon_id, ba.target_na_sequence_id,
         ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
         ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
         sequence.source_id AS target_sequence_source_id,
         least(ba.target_end, ga.end_max)
         - greatest(ba.target_start, ga.start_min) + 1
           AS est_gene_overlap_length,
         ba.query_bases_aligned / (query_sequence.length)
         * 100 AS percent_est_bases_aligned,
         ga.source_id AS gene
  FROM apidb.BlatAlignmentLocation ba, dots.est e, dots.AssemblySequence aseq,
       apidb.GeneAttributes ga, apidb.GenomicSequence sequence,
       dots.NaSequence query_sequence, sres.SequenceOntology so
  WHERE e.na_sequence_id = ba.query_na_sequence_id
    AND aseq.na_sequence_id = ba.query_na_sequence_id
    AND sequence.na_sequence_id = ba.target_na_sequence_id
    AND ga.sequence_id = sequence.source_id
    AND least(ba.target_end, ga.end_max) - greatest(ba.target_start, ga.start_min) >= 0
    AND query_sequence.na_sequence_id = ba.query_na_sequence_id
    AND query_sequence.sequence_ontology_id = so.sequence_ontology_id
    AND so.term_name = 'EST'
    AND ba.target_na_sequence_id = sequence.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.EstAlignmentNoGene NOLOGGING AS
SELECT * from EstAlignmentGene WHERE 1=0 UNION -- define datatype for null column
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, e.accession,
       e.library_id, ba.query_taxon_id, ba.target_na_sequence_id,
       ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
       ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
       sequence.source_id AS target_sequence_source_id,
       NULL AS est_gene_overlap_length,
       ba.query_bases_aligned / (query_sequence.length)
       * 100 AS percent_est_bases_aligned,
       NULL AS gene
FROM dots.blatalignment ba, dots.est e, dots.AssemblySequence aseq,
     dots.NaSequence sequence, dots.NaSequence query_sequence
WHERE e.na_sequence_id = ba.query_na_sequence_id
  AND e.na_sequence_id = query_sequence.na_sequence_id
  AND aseq.na_sequence_id = ba.query_na_sequence_id
  AND ba.target_na_sequence_id = sequence.na_sequence_id
  AND ba.blat_alignment_id IN
   ( -- set of blat_alignment_ids not in in first leg of UNION
    -- (because they overlap no genes)
    SELECT ba.blat_alignment_id
    FROM dots.BlatAlignment ba, dots.NaSequence query_sequence,
         sres.SequenceOntology so
    WHERE query_sequence.na_sequence_id = ba.query_na_sequence_id
      AND query_sequence.sequence_ontology_id = so.sequence_ontology_id
      AND so.term_name = 'EST'
  MINUS
    SELECT blat_alignment_id FROM apidb.EstAlignmentGene)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE EstAlignmentGeneSummary&1 NOLOGGING AS
SELECT * FROM apidb.EstAlignmentNoGene
UNION
SELECT * FROM apidb.EstAlignmentGene
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.EstSumm_libOverlap_ix&1
             ON apidb.EstAlignmentGeneSummary&1
                (library_id, percent_identity, is_consistent,
                 est_gene_overlap_length, percent_est_bases_aligned)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.EstSumm_estSite_ix&1
             ON apidb.EstAlignmentGeneSummary&1
                (target_sequence_source_id, target_start, target_end,
                 library_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.FeatureSo">
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="sres.SequenceOntology"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.FeatureSo&1 NOLOGGING AS
  SELECT t.na_feature_id, so.sequence_ontology_id, so.term_name
  FROM dots.NaFeature gf, dots.NaFeature t, sres.SequenceOntology so
  WHERE  gf.na_feature_id =  t.parent_id
  AND gf.sequence_ontology_id = so.sequence_ontology_id
UNION
  SELECT na_feature_id, so.sequence_ontology_id, so.term_name
  FROM dots.Miscellaneous misc, sres.SequenceOntology so
  WHERE misc.sequence_ontology_id = so.sequence_ontology_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX featso_id_ix&1 ON apidb.FeatureSo&1(na_feature_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.Polymorphism">
    <internalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="dots.SnpFeature"/>
    <externalDependency name="dots.SeqVariation"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.Polymorphism&1 NOLOGGING AS
  SELECT snp.na_feature_id AS snp_na_feature_id, fl.na_sequence_id,
         fl.start_min AS start_min,
         snp.source_id AS snp_source_id,
         snp.position_in_protein,
         sa.na_feature_id as na_feature_id_a,
         sb.na_feature_id as na_feature_id_b,
         substr(sa.strain, 1, 12) AS strain_a,
         substr(sb.strain, 1, 12) AS strain_b,
         substr(sa.allele, 1, 1) AS allele_a,
         substr(sb.allele, 1, 1) AS allele_b,
         substr(sa.product, 1, 1) AS product_a,
         substr(sb.product, 1, 1) AS product_b,
         snp.external_database_release_id,
         snp.parent_id as gene_na_feature_id,
         nl.is_reversed as gene_is_reversed, gf.source_id as gene_source_id
  FROM dots.SnpFeature snp, dots.SeqVariation sa, dots.SeqVariation sb,
       apidb.FeatureLocation fl, apidb.featurelocation nl, dots.GeneFeature gf
  WHERE sa.strain < sb.strain
    AND sa.allele != sb.allele
    AND sa.parent_id = sb.parent_id
    AND sa.parent_id = snp.na_feature_id
    AND snp.na_feature_id = fl.na_feature_id
    AND fl.parent_id = nl.na_feature_id (+)
    AND fl.na_sequence_id = nl.na_sequence_id (+)
    AND snp.parent_id = gf.na_feature_id (+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX polymorphism_ix&1 ON apidb.Polymorphism&1(na_sequence_id, strain_a, strain_b, start_min)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX polymorphism_loc_ix&1
ON apidb.Polymorphism&1(external_database_release_id, na_sequence_id, strain_a, strain_b, start_min)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.IsolateAttributes">
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.IsolateAttributes&1 NOLOGGING AS
select  na_sequence_id, taxon_id,
       external_db_version,
       external_db_name,
       na_feature_id,
       source_id,
       decode(organism, null, 'Unknown', substr(organism, 1, 100)) as organism,
       decode(strain, null, 'Unknown', substr(strain, 1, 100)) as strain,
       decode(specific_host, null, 'Unknown', substr(specific_host, 1, 100)) as specific_host,
       decode(isolation_source, null, 'Unknown', substr(isolation_source, 1, 200)) as isolation_source,
       decode(country, null, 'Unknown', substr(country, 1, 200)) as country,
       substr(note, 1, 400) as note,
       substr(description, 1, 400) as description,
       substr(pcr_primers, 1, 100) as pcr_primers,       
       length,
       is_reference,
       collected_by,
       decode(product, null, 'Unknown', substr(product, 1, 500)) as product,
       decode(product_alias, null, 'Unknown', substr(product_alias, 1, 500)) as product_alias,
       project_id,
       data_type
FROM (
   select  iso.*,
       prod.product,
       prod.product_alias
   from (SELECT  etn.na_sequence_id, etn.taxon_id,etn.length,
        edr.version as external_db_version, src.na_feature_id,
        edb.name as external_db_name,
        CASE WHEN etn.source_id is null THEN decode(edb.name, 'Broad 75K genotyping chip', 'CPHD.'||etn.na_sequence_id, 
        'Broad_75K_Genotyping_RSRC', 'CPHD.'||etn.na_sequence_id,
        'Broad 3K genotyping chip', 'CP3.'||etn.na_sequence_id,
        'Broad_3K_Genotyping_RSRC', 'CP3.'||etn.na_sequence_id,
        'Broad_Isolate_Barcode_RSRC','BC.'||etn.na_sequence_id,etn.source_id,
        'Isolate barcode data from Broad','BC.'||etn.na_sequence_id,etn.source_id)
        ELSE etn.source_id END as source_id,
        tn.name as organism,
        CASE WHEN src.strain != src.isolate THEN src.strain || ' ' || src.isolate 
             WHEN src.strain is  not null THEN src.strain ELSE src.isolate END as strain,
        src.specific_host as specific_host,
        src.isolation_source as isolation_source,
        src.country as country,
        src.note as note,
        etn.description as description,
        src.pcr_primers as pcr_primers,
        src.is_reference,
        src.collected_by,
        decode(edb.name, 'Broad 75K genotyping chip', 'HD_Array', 
        'Broad_75K_Genotyping_RSRC', 'HD_Array',
        'Broad 3K genotyping chip', '3kChip',
        'Broad_3K_Genotyping_RSRC', '3kChip',
        'Toxoplasma RFLPs from Chunlei Su', 'RFLP Typed',
        'Broad_Isolate_Barcode_RSRC','Barcode',
        'Isolate barcode data from Broad','Barcode','Sequencing Typed') as data_type,
        CASE WHEN lower(pinfo.name) like 'plas%' THEN 'PlasmoDB' 
             WHEN lower(pinfo.name) like 'cryp%' THEN 'CryptoDB'
             WHEN lower(pinfo.name) like 'toxo%' THEN 'ToxoDB'
             WHEN lower(pinfo.name) like 'giard%' THEN 'GiardiaDB'
             WHEN lower(pinfo.name) like 'tritryp%' THEN 'TriTrypDB'
        ELSE '' END as project_id
      FROM dots.ExternalNaSequence etn, dots.IsolateSource src,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase edb, core.PROJECTINFO pinfo, 
           (select  distinct taxon_id,name from sres.taxonname where name_class = 'scientific name') tn
      WHERE etn.na_sequence_id = src.na_sequence_id
       AND  etn.taxon_id = tn.taxon_id(+)
       AND edr.external_database_id = edb.external_database_id
       AND edr.external_database_release_id = etn.external_database_release_id
       AND pinfo.project_id = etn.row_project_id
      ) iso
   left join (select na_sequence_id, 
               apidb.tab_to_string(CAST(COLLECT(product order by product) AS apidb.varchartab),'; ') as product, 
               apidb.tab_to_string(CAST(COLLECT(product_alias order by product_alias) AS apidb.varchartab),'; ') as product_alias 
               from dots.isolatefeature group by na_sequence_id) prod
           on prod.na_sequence_id = iso.na_sequence_id
       )
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.IsolateAttr_sourceId_idx&1 ON apidb.IsolateAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

 <tuningTable name="apidb.ChIPProtocolParams">
    <externalDependency name="rad.Analysis"/>
    <externalDependency name="rad.AnalysisParam"/>
    <externalDependency name="rad.ProtocolParam"/>
    <sql>
      <![CDATA[
        create table apidb.ChIPProtocolParams&1 NOLOGGING AS
select a.analysis_id,
       a.protocol_id,
       antbd.antibody as antibody,
       strn.strain as strain,
       treamnt.treatment as treatment,
       replcte.replicate as replicate,
       gentyp.genotype as genotype,
       celltyp.celltype as celltype,
       CASE
          WHEN lower(p.name) like '%peak%' then 'called_peaks'
       ELSE 'raw'
       END as protocol_type
from   rad.analysis a,rad.protocol p,
      (select ap.analysis_id,ap.value as antibody
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'antibody') antbd,
      (select ap.analysis_id,ap.value as strain
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'strain') strn,
      (select ap.analysis_id,ap.value as treatment
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'treatment') treamnt,
      (select ap.analysis_id,ap.value as replicate
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'replicate') replcte,
      (select ap.analysis_id,ap.value as genotype
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'genotype') gentyp,
      (select ap.analysis_id,ap.value as celltype
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'celltype') celltyp
where a.protocol_id = p.protocol_id
and   a.analysis_id = antbd.analysis_id (+)
and   a.analysis_id = strn.analysis_id (+)
and   a.analysis_id = treamnt.analysis_id (+)
and   a.analysis_id = replcte.analysis_id (+)
and   a.analysis_id = gentyp.analysis_id (+)
and   a.analysis_id = celltyp.analysis_id (+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
       CREATE INDEX apidb.chp_prtparam_idx&1 ON apidb.chipprotocolparams&1 (analysis_id,protocol_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="apidb.ChIPchipGene">
    <internalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="apidb.GeneAttributes"/>
    <internalDependency name="apidb.SequenceAttributes"/>
    <sql>
      <![CDATA[
        create table apidb.chipchipgene&1 NOLOGGING AS
select distinct
      ga.source_id as gene_source_id,
      aef.feature_source_id as probe_id,
      aef.na_feature_id as chip_na_feature_id,
      CASE 
        WHEN ga.is_reversed = 0 
        THEN round(abs(ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0)
        ELSE round(abs(ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0) 
      END as distance,
      CASE 
        WHEN -- distance > 0
          CASE WHEN ga.is_reversed = 0 
            THEN ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)
            ELSE ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)
          END > 0 
        THEN 
          CASE 
            WHEN ga.is_reversed = 0 
            THEN '-' 
            ELSE '+'
          END 
        ELSE 
          CASE 
            WHEN ga.is_reversed = 1 
            THEN '-' 
            ELSE '+'
          END 
        END as direction
from  apidb.ExpressionElement aef,
      apidb.FeatureLocation arrloc,
      apidb.geneattributes ga,
      rad.analysis a,
      rad.protocol p
where aef.na_feature_id = arrloc.na_feature_id
and   aef.analysis_id = a.analysis_id
and   a.protocol_id = p.protocol_id
and   p.name in ('NimbleGen_ChIP_Artur_Scherf_Peak_Calls','NimbleGen_ChIP_Till_Voss_Peak_Calls','ChIP_chip_Einstein_called_peaks','NimbleScan_ChIP_Hakimi_called_peaks')
and   arrloc.na_sequence_id = ga.na_sequence_id
and   ( (ga.is_reversed = 0 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.start_min) <= 3000)
                  or (ga.is_reversed = 1 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.end_max) <= 3000) )
     ]]>
    </sql>
    <sql>
      <![CDATA[
       CREATE INDEX apidb.chpgene_geneid_idx&1 ON apidb.chipchipgene&1 (gene_source_id, chip_na_feature_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="apidb.TFBSGene">
    <internalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="apidb.GeneAttributes"/>
    <internalDependency name="apidb.SequenceAttributes"/>
    <sql>
      <![CDATA[
        create table apidb.tfbsgene&1 NOLOGGING AS
select distinct
      ga.source_id as gene_source_id,
      ga.species as species,
      aef.source_id as probe_id,
      aef.na_feature_id as tfbs_na_feature_id,
      CASE 
        WHEN ga.is_reversed = 0 
        THEN round(abs(ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0)
        ELSE round(abs(ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0) 
      END as distance,
      CASE 
        WHEN -- distance > 0
          CASE WHEN ga.is_reversed = 0 
            THEN ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)
            ELSE ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)
          END > 0 
        THEN 
          CASE 
            WHEN ga.is_reversed = 0 
            THEN '-' 
            ELSE '+'
          END 
        ELSE 
          CASE 
            WHEN ga.is_reversed = 1 
            THEN '-' 
            ELSE '+'
          END 
        END as direction
from  dots.BindingSiteFeature aef,
      apidb.FeatureLocation arrloc,
      apidb.geneattributes ga
where aef.na_feature_id = arrloc.na_feature_id
and   arrloc.na_sequence_id = ga.na_sequence_id
and   ( (ga.is_reversed = 0 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.start_min) <= 3000)
                  or (ga.is_reversed = 1 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.end_max) <= 3000) )
     ]]>
    </sql>
    <sql>
      <![CDATA[
       CREATE INDEX apidb.tfbs_geneid_idx&1 ON apidb.tfbsgene&1 (gene_source_id, tfbs_na_feature_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="apidb.SageTagAttributes">
    <internalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="apidb.SageTagAnalysisAttributes"/>
    <internalDependency name="apidb.SageTagGene"/>
    <internalDependency name="apidb.GeneAttributes"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="rad.CompositeElementImp"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.SageTagAttributes&1 NOLOGGING AS
SELECT cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       substr(s.source_id || '-' || l.start_min || '-' || l.end_max || '.'
              || l.is_reversed, 1, 40) as source_id,
       f.na_feature_id, f.source_id as feature_source_id,
       substr(s.source_id, 1, 40) as sequence_source_id, s.na_sequence_id,
       l.start_min, l.end_max, substr(st.tag, 1, 20) as sequence,
       st.composite_element_id, st.source_id as rad_source_id,
       l.is_reversed,
       SUBSTR(CASE
                WHEN tn.name = 'Giardia lamblia' THEN 'Giardia Assemblage A isolate WB' 
                ELSE tn.name
              END, 1, 60) AS organism,
       gene.gene_source_id, nvl(gene.gene_count, 0) gene_count,
       gene.gene_product
from dots.SageTagFeature f, apidb.FeatureLocation l, dots.NaSequence s,
     sres.TaxonName tn, rad.SageTag st, 
     (select a.na_feature_id,
             apidb.tab_to_string(CAST(COLLECT(b.gene_source_id order by b.gene_source_id) AS apidb.varchartab),'; ') as gene_source_id,
             apidb.tab_to_string(CAST(COLLECT(ga.product order by ga.product) AS apidb.varchartab),'; ') as gene_product,
             count(b.gene_source_id) as gene_count
      from dots.sagetagfeature a, (
                             select distinct a.na_feature_id,
                                            sg.gene_source_id as gene_source_id
                             from dots.SageTagFeature a left join apidb.SageTagGene sg on a.na_feature_id = sg.tag_feature_id
                             where (sg.distance = 0 or sg.distance is null)
                             and (sg.antisense = 0 or sg.antisense is null)
                             ) b, apidb.GeneAttributes ga
       where a.na_feature_id = b.na_feature_id
        and b.gene_source_id = ga.source_id
       group by a.na_feature_id
      ) gene
where f.na_feature_id = gene.na_feature_id (+)
  and f.na_feature_id = l.na_feature_id
  and l.is_top_level = 1
  and s.na_sequence_id = l.na_sequence_id
  and s.taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
  and f.source_id = st.composite_element_id
  and st.composite_element_id in (select composite_element_id from apidb.SageTagAnalysisAttributes)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.SageTagAttr_sourceId_idx&1 ON apidb.SageTagAttributes&1
             (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SageTagAttr_loc_idx&1 ON apidb.SageTagAttributes&1
             (na_sequence_id, start_min, end_max, is_reversed, source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.SageTagAttr_ftrId_idx&1 ON apidb.SageTagAttributes&1
             (na_feature_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.AsmAlignmentGeneSummary">
    <internalDependency name="apidb.GeneAttributes"/>
    <internalDependency name="apidb.GenomicSequence"/>
    <internalDependency name="apidb.BlatAlignmentLocation"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.SequenceOntology"/>
    <intermediateTable name="apidb.AsmAlignmentGene"/>
    <intermediateTable name="apidb.AsmAlignmentNoGene"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.AsmAlignmentGene NOLOGGING AS
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, a.source_id, a.number_of_contained_sequences AS est_count, a.length,
         ba.query_taxon_id, ba.target_na_sequence_id,
         ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
         ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
         sequence.source_id AS target_sequence_source_id,
         least(ba.target_end, ga.end_max)
         - greatest(ba.target_start, ga.start_min) + 1
           AS assembly_gene_overlap_length,
         ba.query_bases_aligned / (a.length)
         * 100 AS percent_assembly_bases_aligned,
         ga.source_id AS gene
  FROM dots.assembly a, 
       apidb.BlatAlignmentLocation ba,
       apidb.GeneAttributes ga, 
       apidb.GenomicSequence sequence
  WHERE ba.query_na_sequence_id = a.na_sequence_id 
   AND ba.target_na_sequence_id = sequence.na_sequence_id
   AND ga.sequence_id = sequence.source_id
   AND least(ba.target_end, ga.end_max) - greatest(ba.target_start, ga.start_min) >= 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.AsmAlignmentNoGene NOLOGGING AS
SELECT * from AsmAlignmentGene WHERE 1=0 UNION -- define datatype for null column
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, a.source_id, a.number_of_contained_sequences AS est_count, a.length,
         ba.query_taxon_id, ba.target_na_sequence_id,
         ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
         ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
         sequence.source_id AS target_sequence_source_id,
         NULL
           AS assembly_gene_overlap_length,
         ba.query_bases_aligned / (a.length)
         * 100 AS percent_assembly_bases_aligned,
         NULL AS gene
  FROM dots.blatalignment ba, dots.assembly a,
      dots.NaSequence sequence
  WHERE a.na_sequence_id = ba.query_na_sequence_id
    AND sequence.na_sequence_id = ba.target_na_sequence_id
    AND ba.blat_alignment_id IN
   ( -- set of blat_alignment_ids not in in first leg of UNION
    -- (because they overlap no genes)
    SELECT ba.blat_alignment_id
    FROM dots.BlatAlignment ba, dots.NaSequence query_sequence,
         sres.SequenceOntology so
    WHERE query_sequence.na_sequence_id = ba.query_na_sequence_id
      AND query_sequence.sequence_ontology_id = so.sequence_ontology_id
      AND so.term_name = 'assembly'
  MINUS
    SELECT blat_alignment_id FROM apidb.AsmAlignmentGene)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE AsmAlignmentGeneSummary&1 NOLOGGING AS
SELECT * FROM apidb.AsmAlignmentNoGene
UNION
SELECT * FROM apidb.AsmAlignmentGene
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.PlasmoExpressionGraphs">
    <externalDependency name="apidb.Profile"/>
    <externalDependency name="apidb.ProfileSet"/>
    <internalDependency name="apidb.GeneAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.PlasmoExpressionGraphs&1 NOLOGGING AS
SELECT gf.source_id,
       COUNT(pf_rna_seq) AS graph_pf_rna_seq,
       COUNT(zb_pvivax) AS graph_zb_pvivax,
       COUNT(derisi_winzeler) AS graph_derisi_winzeler,
       COUNT(winzeler) AS graph_winzeler, COUNT(ThreeD7) AS graph_3d7,
       COUNT(HB3) AS graph_hb3, COUNT(Dd2) AS graph_dd2,
       COUNT(waters) AS graph_waters, COUNT(gametocyte) as graph_gametocyte,
       COUNT(cowman) AS graph_cowman, COUNT(mexp128) AS graph_mexp128,
       COUNT(mexp494) AS graph_mexp494, COUNT(kappe) as graph_kappe,
       COUNT(daily) as graph_daily,
       COUNT(newbold) as graph_newbold,
       COUNT(westenberger) as graph_westenberger,
       COUNT(winzeler_py_mixed) as graph_winzeler_py_mixed,
       COUNT(su_cq) as graph_su_cq,
       COUNT(cowman_sir2) as graph_cowman_sir2,
       COUNT(waters_dozi) as graph_waters_dozi
FROM apidb.geneattributes gf,
     (SELECT p1.source_id, 1 AS derisi_winzeler
      FROM apidb.profile p1, apidb.profileSet ps1,
           apidb.profile p3, apidb.profileSet ps3,
           apidb.profile p5, apidb.profileSet ps5,
           apidb.profile p7, apidb.profileSet ps7
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND p3.profile_set_id = ps3.profile_set_id
        AND p5.profile_set_id = ps5.profile_set_id
        AND p7.profile_set_id = ps7.profile_set_id
        AND p1.source_id = p3.source_id
        AND p1.source_id = p5.source_id
        AND p1.source_id = p7.source_id
        AND ps1.name = 'DeRisi HB3 Smoothed'
        AND ps3.name = 'DeRisi 3D7 Smoothed'
        AND ps5.name = 'DeRisi Dd2 Smoothed'
        AND ps7.name = 'winzeler_cc_sorbExp') combo,
     (SELECT p1.source_id, 1 AS zb_pvivax
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND ps1.name = 'ZB Pvivax time series normalized_averaged 3') zbpvivax, 
     (SELECT p1.source_id, 1 AS pf_rna_seq
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND ps1.name in('Profiles of P.falciparum Newbold mRNA Seq data', 'P.falciparum RNA Sequence Profiles')) pfrnaseq, 
     (SELECT p1.source_id, 1 AS winzeler
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND ps1.name = 'winzeler_cc_sorbExp') winzeler,
     (SELECT p1.source_id, 1 AS threeD7
      FROM apidb.profile p1, apidb.profileSet ps1,
           apidb.profile p2, apidb.profileSet ps2,
           apidb.profile p3, apidb.profileSet ps3
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND p2.profile_set_id = ps2.profile_set_id
        AND p3.profile_set_id = ps3.profile_set_id
        AND p1.source_id = p2.source_id
        AND p1.source_id = p3.source_id
        AND ps1.name = 'DeRisi 3D7 Smoothed'
        AND ps2.name = 'DeRisi 3D7 non-smoothed'
         AND ps3.name = 'Percentiles of DeRisi 3D7 Red') threeD7,
     (SELECT p1.source_id, 1 AS HB3
      FROM apidb.profile p1, apidb.profileSet ps1,
           apidb.profile p2, apidb.profileSet ps2,
           apidb.profile p3, apidb.profileSet ps3
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND p2.profile_set_id = ps2.profile_set_id
        AND p3.profile_set_id = ps3.profile_set_id
        AND p1.source_id = p2.source_id
        AND p1.source_id = p3.source_id
        AND ps1.name = 'DeRisi HB3 Smoothed'
        AND ps2.name = 'DeRisi HB3 non-smoothed'
         AND ps3.name = 'Percentiles of DeRisi HB3 Red') HB3,
     (SELECT p1.source_id, 1 AS Dd2
      FROM apidb.profile p1, apidb.profileSet ps1,
           apidb.profile p2, apidb.profileSet ps2,
           apidb.profile p3, apidb.profileSet ps3
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND p2.profile_set_id = ps2.profile_set_id
        AND p3.profile_set_id = ps3.profile_set_id
        AND p1.source_id = p2.source_id
        AND p1.source_id = p3.source_id
        AND ps1.name = 'DeRisi Dd2 Smoothed'
        AND ps2.name = 'DeRisi Dd2 non-smoothed'
         AND ps3.name = 'Percentiles of DeRisi Dd2 Red') Dd2,
     (SELECT p1.source_id, 1 AS waters
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND ps1.name = 'Waters HPE Percents Red') waters,
     (SELECT p1.source_id, 1 AS gametocyte
      FROM apidb.profile p1, apidb.profileSet ps1,
           apidb.profile p2, apidb.profileSet ps2
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND p2.profile_set_id = ps2.profile_set_id
        AND p1.source_id = p2.source_id
        AND ps1.name = 'winzeler_NF54_gametocyte'
        AND ps2.name = 'winzeler_3D7_gametocyte') gametocyte,
    (SELECT p.source_id, 1 AS cowman
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'Profiles of Cowman Invasion KO-sir2_knockout'
        AND p.profile_set_id = ps.profile_set_id) cowman,
    (SELECT p.source_id, 1 AS mexp128
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'Expression profile of 3D7 clones 3D7AH1S2 and 3D7S8.4 at ring, trophozite and schizont stages.'
        AND p.profile_set_id = ps.profile_set_id) mexp128,
    (SELECT p.source_id, 1 AS mexp494
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'Identification of genome wide gene copy number polymorphisms in Plasmodium falciparum'
        AND p.profile_set_id = ps.profile_set_id) mexp494,
    (SELECT p1.source_id, 1 AS kappe
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE ps1.name = 'kappe_all_comparisons_profiles'
       AND p1.profile_set_id = ps1.profile_set_id) kappe,
    (SELECT p1.source_id, 1 AS daily
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE ps1.name = 'daily_patient-number_percents_percentiles'
       AND p1.profile_set_id = ps1.profile_set_id) daily,
    (SELECT p1.source_id, 1 AS newbold
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE ps1.name = 'newbold gene profiles sorted mild-severe'
       AND p1.profile_set_id = ps1.profile_set_id) newbold,
    (SELECT p1.source_id, 1 AS westenberger
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE ps1.name = 'westenberger vivax expression profile'
       AND p1.profile_set_id = ps1.profile_set_id) westenberger,
    (SELECT p1.source_id, 1 AS winzeler_py_mixed
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE ps1.name = 'winzeler py mixed RMAouput naturalscale'
       AND p1.profile_set_id = ps1.profile_set_id) winzeler_py_mixed,
    (SELECT p1.source_id, 1 AS cowman_sir2
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE ps1.name = 'Profiles of E-TABM-438 from Cowman'
       AND p1.profile_set_id = ps1.profile_set_id) cowman_sir2,
    (SELECT p1.source_id, 1 AS su_cq
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE ps1.name = 'Profiles of E-GEOD-10022 array from Su'
       AND p1.profile_set_id = ps1.profile_set_id) su_cq,
    (SELECT p1.source_id, 1 AS waters_dozi
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE ps1.name = 'Profiles of P. berghei DOZI array data'
       AND p1.profile_set_id = ps1.profile_set_id) waters_dozi
  WHERE gf.source_id = combo.source_id(+)
  AND gf.source_id = winzeler.source_id(+)
  AND gf.source_id = threeD7.source_id(+)
  AND gf.source_id = HB3.source_id(+)
  AND gf.source_id = Dd2.source_id(+)
  AND gf.source_id = waters.source_id(+)
  AND gf.source_id = gametocyte.source_id(+)
  AND gf.source_id = cowman.source_id(+)
  AND gf.source_id = mexp128.source_id(+)
  AND gf.source_id = mexp494.source_id(+)
  AND gf.source_id = kappe.source_id(+)
  AND gf.source_id = daily.source_id(+)
  AND gf.source_id = newbold.source_id(+)
  AND gf.source_id = zbpvivax.source_id(+)
  AND gf.source_id = pfrnaseq.source_id(+)
  AND gf.source_id = westenberger.source_id(+)
  AND gf.source_id = winzeler_py_mixed.source_id(+)
  AND gf.source_id = cowman_sir2.source_id(+)
  AND gf.source_id = su_cq.source_id(+)
  AND gf.source_id = waters_dozi.source_id(+)
GROUP BY gf.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.PlasmoExp_sourceId_idx&1 ON apidb.PlasmoExpressionGraphs&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.ToxoExpressionGraphs">
    <internalDependency name="apidb.GeneAttributes"/>
    <externalDependency name="apidb.Profile"/>
    <externalDependency name="apidb.ProfileSet"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.ToxoExpressionGraphs&1 NOLOGGING AS
SELECT ga.source_id,
        COUNT(archetypal) AS graph_archetypal,
        COUNT(bradyzoite) AS graph_bradyzoite
FROM Apidb.GeneAttributes ga,
     (SELECT p.source_id, 1 AS archetypal
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'Expression profiling of the 3 archetypal T. gondii lineages'
        AND p.profile_set_id = ps.profile_set_id) archetypal,
        (SELECT p.source_id, 1 AS bradyzoite
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'expression profile percentiles of T. gondii Matt_Tz-Bz time series'
        AND p.profile_set_id = ps.profile_set_id) bradyzoite
  WHERE ga.source_id = archetypal.source_id(+)
  and ga.source_id = bradyzoite.source_id (+)
GROUP BY ga.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.ToxoExp_sourceId_idx&1 ON apidb.ToxoExpressionGraphs&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.GiardiaExpressionGraphs">
    <internalDependency name="apidb.GeneAttributes"/>
    <externalDependency name="apidb.Profile"/>
    <externalDependency name="apidb.ProfileSet"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GiardiaExpressionGraphs&1 NOLOGGING AS
SELECT ga.source_id,
       COUNT(stress) as graph_stress,
       COUNT(stress_ts) as graph_stress_ts,
       COUNT(sage_pct) as graph_sage_pct
FROM apidb.GeneAttributes ga,
     (SELECT p.source_id, 1 AS stress
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'Stress Response in Giardia lamblia Trophozoites-Averaged'
        AND p.profile_set_id = ps.profile_set_id) stress,
     (SELECT p.source_id, 1 AS stress_ts
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'Stress response Dynamics in Trophozoites (time series)-Averaged'
        AND p.profile_set_id = ps.profile_set_id) stress2,
     (SELECT p.source_id, 1 AS sage_pct
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'giar sage count'
        AND p.profile_set_id = ps.profile_set_id) sage
  WHERE ga.source_id = stress.source_id(+)
  AND ga.source_id = stress2.source_id(+)
  AND ga.source_id = sage.source_id(+)
GROUP BY ga.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.ExpGraphSum_sourceId_idx&1 ON apidb.GiardiaExpressionGraphs&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="apidb.ExpressionGraphs">
    <internalDependency name="apidb.GeneAttributes"/>
    <externalDependency name="apidb.Profile"/>
    <externalDependency name="apidb.ProfileSet"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.ExpressionGraphs&1 NOLOGGING AS
select all_gg.source_id, 
       all_gg.main_profile_name as profile_name, 
       all_gg.project_id, 
       max(case when pr.name is null then 0 ELSE 1 END) as has_profile
from 
  (
    select ga.source_id, pm.profile_name, nvl(pm.main_profile_name, pm.profile_name) as main_profile_name, pm.project_id
    from
    (
    -- ToxoDB --
    select 'Expression profiles of Tgondii ME49 Boothroyd experiments' as profile_name,
          '' as main_profile_name,
           'ToxoDB' as project_id
    from dual
    UNION
    select 'M.White Cell Cycle Microarray profiles' as profile_name,
          '' as main_profile_name,
           'ToxoDB' as project_id
    from dual
    UNION
    select 'T. gondii VEG Day 3-4 Tachyzoite aligned to the TgME49 Genome-profiles' as profile_name,
           '' as main_profile_name,
           'ToxoDB' as project_id
    from dual
    UNION
    select 'T. gondii VEG Day 3-4 Tachyzoite aligned to the VEG Genome-profiles' as profile_name,
           '' as main_profile_name,
           'ToxoDB' as project_id
    from dual
    UNION
    select 'N. caninum Day 3-4 Tachyzoite-profiles' as profile_name,
           '' as main_profile_name,
           'ToxoDB' as project_id
    from dual
    UNION
    select 'expression profiles of RH delta-HXGPRT delta-UPRT strain Alkaline bradyzoite-inducing conditions' as profile_name,
           '' as main_profile_name,
           'ToxoDB' as project_id
    from dual
    UNION
    select 'expression profiles of T. gondii Matt_Tz-Bz time series' as profile_name,
           '' as main_profile_name,
           'ToxoDB' as project_id
    from dual
    UNION
    select 'expression profiles of VEG strain CO2-starvation bradyzoite inducing conditions' as profile_name,
           '' as main_profile_name,
           'ToxoDB' as project_id
    from dual
    UNION
    select 'expression profiles of three Tgondii strains under both normal-tachyzoite and induced-bradyzoite conditoins' as profile_name,
           '' as main_profile_name,
           'ToxoDB' as project_id
    from dual
    UNION

    -- AmoebaDB --
    select 'EhistolyticaAffyProfiles' as profile_name,
           '' as main_profile_name,
           'AmoebaDB' as project_id
    from dual
    UNION
    select 'EhistolyticaNugenProfiles' as profile_name,
           '' as main_profile_name,
           'AmoebaDB' as project_id
    from dual
    UNION
  
    -- GiardiaDB --
    select 'Stress Response in Giardia lamblia Trophozoites-Averaged' as profile_name,
           '' as main_profile_name,
           'GiardiaDB' as project_id
    from dual
    UNION
    select 'Stress response Dynamics in Trophozoites (time series)-Averaged' as profile_name,
           '' as main_profile_name,
           'GiardiaDB' as project_id
    from dual
    UNION
    select 'Hehl encystation expression profile' as profile_name,
           '' as main_profile_name,
           'GiardiaDB' as project_id
    from dual
    UNION
    select 'Profiles of G.lamblia Ringqvist array data' as profile_name,
           '' as main_profile_name,
           'GiardiaDB' as project_id
    from dual
    UNION
    select 'giar sage tag frequencies sense' as profile_name,
           '' as main_profile_name,
           'GiardiaDB' as project_id
    from dual
    UNION
    select 'giar sage tag frequencies antisense' as profile_name,
           'giar sage tag frequencies sense' as main_profile_name,
           'GiardiaDB' as project_id
    from dual
    UNION

    -- PlasmoDB --


    select 'Profiles of E-GEOD-10022 array from Su' as profile_name,
           '' as main_profile_name,
          'PlasmoDB' as project_id
    from dual
    UNION

    select 'Profiles of E-TABM-438 from Cowman' as profile_name,
           '' as main_profile_name,
          'PlasmoDB' as project_id
    from dual
    UNION

    select 'Profiles of P.falciparum Newbold mRNA Seq data' as profile_name,
           '' as main_profile_name,
          'PlasmoDB' as project_id
    from dual
    UNION
    select 'Profiles of P.falciparum duffy mRNA Seq data' as profile_name,
           '' as main_profile_name,
          'PlasmoDB' as project_id
    from dual
    UNION
    select 'Profiles of P.falciparum Stunnenberg mRNA Seq data' as profile_name,
           '' as main_profile_name,
          'PlasmoDB' as project_id
    from dual

    UNION
    select 'Profiles of Derisi HalfLife-half_life' as profile_name,
           '' as main_profile_name,
          'PlasmoDB' as project_id
    from dual
    UNION

    --TriTrypDB --
    select 'T.brucei Horn RNAi Sequence minProfiles' as profile_name,
           '' as main_profile_name,
           'TriTrypDB' as project_id
    from dual
    UNION
    select 'Linfantum promastigote time-course biorep01' as profile_name,
           '' as main_profile_name,
           'TriTrypDB' as project_id
    from dual
    UNION
    select 'Expression profiling of T. brucei microarray data from Christine Clayton' as profile_name,
           '' as main_profile_name,
           'TriTrypDB' as project_id
    from dual
    UNION
    select 'Expression profiling of T. brucei differentiation series' as profile_name,
           '' as main_profile_name,
           'TriTrypDB' as project_id
    from dual
    UNION
    select 'Expression profiling of Tbrucei five life cycle stages' as profile_name,
           '' as main_profile_name,
           'TriTrypDB' as project_id
    from dual
    UNION
    select 'Profiles of T.cruzi Tarleton Rick array data' as profile_name,
           '' as main_profile_name,
           'TriTrypDB' as project_id
    from dual
    UNION
    select 'Expression profiling of Tbrucei Procyclic TbDRBD3 depletion' as profile_name,
           '' as main_profile_name,
           'TriTrypDB' as project_id
    from dual
    UNION
    select 'T.brucei George Cross RNA Sequence min-Profiles' as profile_name,
           '' as main_profile_name,
           'TriTrypDB' as project_id
    from dual
    UNION
    select 'Profiles of L.major Beverly Steve array data' as profile_name,
           '' as main_profile_name,
           'TriTrypDB' as project_id
    from dual
    UNION
    select 'Profiles of Linfantum axenic and intracellular amastigote array data' as profile_name,
           '' as main_profile_name,
           'TriTrypDB' as project_id
    from dual
    UNION
    select 'T. brucei under heat shock array data' as profile_name,
           '' as main_profile_name,
           'TriTrypDB' as project_id
    from dual
    UNION
    select 'T. brucei DHH1 wild type array data' as profile_name,
           '' as main_profile_name,
           'TriTrypDB' as project_id
    from dual
    UNION
    select 'Lmajor RNASeq Spliced Leader And Poly A Sites from Myler uniqProfile' as profile_name,
           '' as main_profile_name,
           'TriTrypDB' as project_id
    from dual
    UNION
    select 'T.brucei RNASeq Spliced Leader And Poly A Sites from Nilsson uniqProfile' as profile_name,
           '' as main_profile_name,
           'TriTrypDB' as project_id
    from dual
    ) pm, apidb.geneattributes ga
    where ga.project_id = pm.project_id
  ) all_gg,
  (select p.source_id, ps.name
   from apidb.profile p, apidb.profileset ps
   where p.profile_set_id = ps.profile_set_id
   ) pr
  where  all_gg.source_id = pr.source_id (+)
  and all_gg.profile_name = pr.name (+)
group by all_gg.source_id, all_gg.main_profile_name, all_gg.project_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.ExpGraph_sourceId_idx&1 ON apidb.ExpressionGraphs&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="apidb.ExpressionGraphDescrip">
    <sql>
      <![CDATA[
CREATE TABLE apidb.ExpressionGraphDescrip&1 NOLOGGING AS
select mainOpen, dataOpen, order_num, profile_name, module, species, display_name, description, x_axis, y_axis, visible_parts,attribution
from (
-- ToxoDB
select 'expression profiles of RH delta-HXGPRT delta-UPRT strain Alkaline bradyzoite-inducing conditions' as profile_name,
       'Roos::TzBz' as module,
       'Toxoplasma gondii ME49' as species,
       'Bradyzoite Differentiation (Multiple 6-hr Time Points)' as display_name,
       'Two strains of T. gondii parasites were used in this analysis: type II Prugniaud lacking HXGPRT, and type I RH lacking HXGPRT and UPRT. A total of three experimental conditions were used to promote in vitro bradyzoite differentiation: Alkaline conditions (D10 media adjusted to pH 8.2), CO2 starvation (MEM with 10% FBS, 25mM HEPES, pH 7.2 grown without CO2), and sodium nitroprusside (SNP) exposure (D10 with 100uM SNP). All conditions were applied 6hr post-inoculation and each media was exchanged every twelve hours post-inoculation.' as description,
       'Time in hours' as x_axis,
       'RMA Normalized Values (log base 2 generated with RMAExpress v1.0.3) or expression percentile value.' as y_axis,
        10 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'rma,pct' as visible_parts,
        'Brady_Time_Series' as attribution
    from dual

    UNION
select 'expression profiles of T. gondii Matt_Tz-Bz time series' as profile_name,
       'Boothroyd::TzBz' as module,
       'Toxoplasma gondii ME49' as species,
       'Bradyzoite Differentiation (3-day time series)' as display_name,
       'T. gondii Type II Prugniaud parasites lacking HXGPRT were inoculated at and MOI of 2 and differentiated in RPMI 1640 lacking sodium bicarbonate, low FCS, and high pH (8.1). RNA was collected from either tachyzoite (2 days post inoculation before monolayer lysis) or bradyzoite cultures (2-days, 3-days and 4-days of induction). ' as description,
       'Time in days' as x_axis,
       'RMA Normalized Values (log base 2 generated with RMAExpress v1.0.3) or expression percentile value.' as y_axis,
        20 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'rma,pct' as visible_parts,
        'Matt_Tz-Bz_Time_Series' as attribution
    from dual

    UNION
select 'expression profiles of VEG strain CO2-starvation bradyzoite inducing conditions' as profile_name,
       'Dzierszinski::TzBz' as module,
       'Toxoplasma gondii ME49' as species,
       'Bradyzoite Differentiation (Extended time series)' as display_name,
       'Two strains of T. gondii parasites were used in this analysis: type II Prugniaud lacking HXGPRT, and type III VEG. CO2 starvation (MEM with 10% FBS, 25mM HEPES, pH 7.2 grown without CO2) was used to induce in vitro bradyzoite differentiation. ' as description,
       'Time in days' as x_axis,
       'RMA Normalized Values (log base 2 generated with RMAExpress v1.0.3) or expression percentile value.' as y_axis,
        30 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'rma,pct' as visible_parts,
        'Brady_Time_Series' as attribution
    from dual

    UNION
select 'expression profiles of three Tgondii strains under both normal-tachyzoite and induced-bradyzoite conditoins' as profile_name,
       'White::TzBz' as module,
       'Toxoplasma gondii ME49' as species,
       'Bradyzoite Differentiation (Single Time-Point)' as display_name,
       'Bradyzoite genes were induced following a 48 hour treatment with compound 1 or alkaline condition. Strains used in this study: Type I-GT1, Type II-Me49B7 and Type III-CTG.' as description,
       'Treatment/Condition' as x_axis,
       'RMA Normalized Values (log base 2 generated with RMAExpress v1.0.3) or expression percentile value.' as y_axis,
        40 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'rma,pct' as visible_parts,
        'Compound1_pH_avg_pct' as attribution
    from dual

    UNION

   select 'M.White Cell Cycle Microarray profiles' as profile_name,
       'White::CellCycle' as module,
       'Toxoplasma gondii ME49' as species,
       'Cell Cycle' as display_name,
       'The RH<sup>TK+</sup> strain used in this analysis expresses a fusion protein of herpes simplex thymidine kinase and chloramphenicol acetyltransferase (<a href="http://www.ncbi.nlm.nih.gov/pubmed/10496908">Radke and White</a>).  Synchronization of RH<sup>TK+</sup> parasites with thymidine followed published protocols (<a href="http://www.ncbi.nlm.nih.gov/pubmed/10496908">Radke and White</a>).  <b>In this synchrony model parasites released from thymidine immediately progress through S, mitosis and then cytokinesis</b>.  The first G1 phase is the start of the next cycle.  All time points represent microarray hybridization results from duplicate, independent biological replicates.  <br><br><b>The R0-12 time course represents ~1-2/3 divisions</b> with tachyzoite cell cycle phase repeats R1,R2=R8,R9, R3=R10, R4=R11, and R5=R12 (<a href="http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0012354">Behnke et al., 2010</a>)' as description,
       'Time point in hours' as x_axis,
       'RMA Value in upper graph or expression percentile value in lower graph.' as y_axis,
        50 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'rma,pct' as visible_parts,
        'T.gondii_MWhite_CellCycle_Array_Profiles' as attribution
    from dual

UNION
select 'T. gondii VEG Day 3-4 Tachyzoite aligned to the TgME49 Genome-profiles' as profile_name,
       'Reid::TgME49RnaSeq' as module,
       'Toxoplasma gondii ME49' as species,
       '<i>T. gondii ME49</i> day 3-4 tachyzoite form RNA Sequence Coverage' as display_name,
       'The coverage values in the graph are displayed in log2 scale. Poly-adenylated RNA was sequenced as 76bp, paired-end reads using the Illumina GAII. Parasites were not synchronised; days 3 and 4 samples are considered to overlap and thus represent biological replicates of expression during the tachyzoite stage, rather than distinct timepoints.' as description,
       'T. gondii ME49 Day 3 and Day4 Tachyzoite Form' as x_axis,
       'log2 of the transcript levels of reads per kilobase of exon model per million mapped reads (RPKM).  Stacked bars indicate unique and non-uniquely mapped sequences.  Non-Unique sequences are plotted to indicate the maximum expression potential of this gene.
' as y_axis,
        250 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'coverage,pct' as visible_parts,
        'TgME49_RNASeq_Tachyzoite_Reid_RSRC' as attribution
from dual

UNION
select 'T. gondii VEG Day 3-4 Tachyzoite aligned to the VEG Genome-profiles' as profile_name,
       'Reid::TgVEGRnaSeq' as module,
       'Toxoplasma gondii VEG' as species,
       '<i>T. gondii Veg</i> day 3-4 tachyzoite form RNA Sequence Coverage' as display_name,
       'The coverage values in the graph are displayed in log2 scale. Poly-adenylated RNA was sequenced as 76bp, paired-end reads using the Illumina GAII. Parasites were not synchronised; days 3 and 4 samples are considered to overlap and thus represent biological replicates of expression during the tachyzoite stage, rather than distinct timepoints.' as description,
       'T. gondii VEG Day 3 and Day4 Tachyzoite Form' as x_axis,
       'log2 of the transcript levels of reads per kilobase of exon model per million mapped reads (RPKM).  Stacked bars indicate unique and non-uniquely mapped sequences.  Non-Unique sequences are plotted to indicate the maximum expression potential of this gene.
' as y_axis,
        250 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'coverage,pct' as visible_parts,
        'TgVEG_RNASeq_Tachyzoite_Reid_RSRC' as attribution
from dual

UNION
select 'N. caninum Day 3-4 Tachyzoite-profiles' as profile_name,
       'Reid::NcRnaSeq' as module,
       'Neospora caninum' as species,
       '<i>N. caninum </i> day 3-4 tachyzoite form RNA Sequence Coverage' as display_name,
       'The coverage values in the graph are displayed in log2 scale. Poly-adenylated RNA was sequenced as 76bp, paired-end reads using the Illumina GAII. Parasites were not synchronised; days 3 and 4 samples are considered to overlap and thus represent biological replicates of expression during the tachyzoite stage, rather than distinct timepoints.' as description,
       'T. gondii VEG Day 3 and Day4 Tachyzoite Form' as x_axis,
       'log2 of the transcript levels of reads per kilobase of exon model per million mapped reads (RPKM).  Stacked bars indicate unique and non-uniquely mapped sequences.  Non-Unique sequences are plotted to indicate the maximum expression potential of this gene.
' as y_axis,
        250 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'coverage,pct' as visible_parts,
        'Nc_RNASeq_Tachyzoite_Reid_RSRC' as attribution
from dual

UNION
select 'Expression profiles of Tgondii ME49 Boothroyd experiments' as profile_name,
       'Boothroyd::TgME49M4' as module,
       'Toxoplasma gondii ME49' as species,
       'Transcriptome analsysis of oocyst, tachyzoite, and bradyzoite development in the type II strain M4' as display_name,
       'There were three primary objectives to the overall experiment. <br/> I. Describe the transcriptome of the oocyst through its development beginning with the freshly excreted, unsporulated oocyst at \"Day 0\" to a fully sporulated and mature oocyst at \"Day 10\" and including a mid-sporulation timepoint at \"Day 4\".  <br/>II. Compare the transcriptomes of <i>in vitro</i> vs. <i>in vivo</i> derived bradyzoites.<br/> III. Compare expression data from three life stages (oocyst, bradyzoite and tachyzoite) from the same parasite isolate, M4, which has been been characterized as a Type II strain. <br/><br/> The authors found that the patterns of gene expression differ across the life stages, as expected, with expression of known stage-specific genes appropriately reflected in the data.  Additionally, they found that the in vitro bradyzoite transcriptome appears to be in strong agreement with the <i>in vivo</i> transcriptome (suggesting that, at the transcriptional level, the <i>in vitro</i> model is a good approximation for <i>in vivo</i> bradyzoites). Analysis to identify significantly different genes between in vitro and <i>in vivo</i> bradyzoites is underway.' as description,
       '1. Time post infection or sporulation (i.e. 4d vs 8d Bradyzoites and 4d vs 10d sporulated oocyst). <br/>2. Developmental form (Tachyzoite, Bradyzoite, Oocyst). <br/> 3. Bradyzoite samples - obtained <i>in vitro</i> vs. <i>in vivo</i>' as x_axis,
       'The RMA values in log2 scale.' as y_axis,
        250 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'rma,pct' as visible_parts,
        'tgME49Boothroyd_RSRC' as attribution
from dual

    UNION

-- GiardiaDB --
select 'Stress Response in Giardia lamblia Trophozoites-Averaged' as profile_name,
       'Hehl::Stress1' as module,
       'Giardia Assemblage A isolate WB' as species,
       'Stress response in Trophozoites - Varying DTT Concentrations and Temperature' as display_name,
       '<b>Stress Response in Giardia lamblia Trophozoites</b>: Samples were incubated for 30min with varying concentrations of DTT. Each bar represents the average of three 2-channel hybridizations which were performed versus a control sample (ie. Control=Control/Control,...). Cases where the Control/Control is NOT close to 0 is an indication of experimental variation in the spots mapping to this gene.' as description,
       'Incubation Condition' as x_axis,
       'log(2) ratio in upper graph or expression percentile value in lower graph.' as y_axis,
        60 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'expr_val,pct' as visible_parts,
        'GL_Spycher_metaData' as attribution
    from dual

    UNION

select 'Stress response Dynamics in Trophozoites (time series)-Averaged' as profile_name,
       'Hehl::Stress2' as module,
       'Giardia Assemblage A isolate WB' as species,
       'Stress response in Trophozoites - Varying Incubation Time' as display_name,
       '<b>Stress Response in Giardia lamblia Trophozoites</b>: Samples were incubated 30min, 60min, 120min at 14.2mM DTT. Each bar represents the average of three 2-channel hybridizations which were performed versus a control sample (ie. Control=Control/Control,...). Cases where the Control/Control is NOT close to 0 is an indication of experimental variation in the spots mapping to this gene.' as description,
       'Incubation Time' as x_axis,
       'log(2) ratio in upper graph or expression percentile value in lower graph.' as y_axis,
        70 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'expr_val,pct' as visible_parts,
        'GL_Spycher_metaData_2' as attribution
    from dual

    UNION

select 'Hehl encystation expression profile' as profile_name,
       'Hehl::Encystation' as module,
       'Giardia Assemblage A isolate WB' as species,
       'Encystation in Trophozoites' as display_name,
       'Two protocols were used to encyst parasites <i>in vitro</i>: the standard 2-step, and a lipid (cholesterol) starvation protocol. Encystation-specific changes of gene expression were analyzed at 45 minutes, 3 and 7 hours post induction.' as description,
       'Encystation Time' as x_axis,
       'log(2) ratio in upper graph or expression percentile value in lower graph.' as y_axis,
        80 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'expr_val,pct' as visible_parts,
        'G.lamblia_Hehl_encystation_Array_Profiles' as attribution
    from dual

    UNION

select 'Profiles of G.lamblia Ringqvist array data' as profile_name,
       'Ringqvist::WbClone' as module,
       'Giardia Assemblage A isolate WB' as species,
       'Transcriptional changes in <i>G. intestinalis</i> during host-parasite interactions ' as display_name,
       'Interaction experiments were performed between G. intestinalis GL50803 and 21-day differentiated Caco-2 cells. Trophozoites were separated and collected from the interaction cultures at 1.5 h, 6 h and 18 h time points.  In addition, trophozoites of the same time points were harvested from standard TYI-S-33 cultures and from cultures in only interaction medium (DMEM).  Microarrays of all samples and time points were performed with a common reference, a pool of trophozoites from the 0 hr  time point of three replicate experiments. At least two 2-channel arrays were performed for each time point.' as description,
       'Time point in hours' as x_axis,
       'Fold Change in upper graph or expression percentile value in lower graph.' as y_axis,
        90 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'expr_val,pct' as visible_parts,
        'G.intestinalis_Troell_Svard_Array_Profiles' as attribution
    from dual

    UNION

select 'giar sage tag frequencies sense' as profile_name,
       'Sage::McArthur' as module,
       'Giardia Assemblage A isolate WB' as species,
       'Curated SAGE Data (Sense and Antisense Tags)' as display_name,
       'Serial Analysis of Gene Expression (SAGE) was used to monitor gene expression throughout the Giardia life cycle in vitro.  This data is based on the original raw SAGE tag data and was extensively manually curated.' as description,
       'Time points post excystation or encystation are indicated in hours.<br />S1 (stage 1) = acidic condition to mimic the stomach.<br />S2 (Stage 2) = trypsin and slight alkaline conditions to mimic the small intestine.' as x_axis,
       'Percent of sense and antisense transcripts within individual SAGE libraries.' as y_axis,
        100 as order_num,
        'TRUE' as mainOpen,
        'TRUE' as dataOpen,
       'sage' as visible_parts,
        'GiardiaSageTagArrayDesign,GiardiaSageTagFreqs' as attribution
    from dual

    UNION


-- PlasmoDB --





select 'Profiles of E-GEOD-10022 array from Su' as profile_name,
       'Su::CQTreatment' as module,
       'Plasmodium falciparum' as species,
       'Expression and genomic changes after exposing drug-selected mutants to short term CQ treatment in <i>P. falciparum</i>' as display_name,
       'Mutations in PfCRT confer chloroquine (CQ) resistance in P. falciparum. Point mutations in the homolog of the mammalian multidrug resistance gene (pfmdr1) can also modulate the levels of CQ response. However, parasites with the same pfcrt and pfmdr1 alleles exhibit a wide range of drug sensitivity, suggesting that additional genes contribute to levels of CQ resistance (CQR).<br>3 isogenic lines which have different drug resistance profiles corresponding to unique mutations in the pfcrt gene (106/1K76, 106/176I, and 106/76I-352K) were used to study changes in gene expression with and without chloroquine  and genomic variations, i.e. copy number (CN) changes.' as description,
       'isogenic line' as x_axis,
       'RMA Normalized Values (log base 2 generated with RMAExpress v1.0.3) or expression percentile value.' as y_axis,
        110 as order_num,
        'FALSE' as mainOpen,
        'FALSE' as dataOpen,
       'rma,pct' as visible_parts,
       'E-GEOD-10022_array' as attribution
from dual

UNION

select 'Profiles of E-TABM-438 from Cowman' as profile_name,
       'Cowman::Sir2KO' as module,
       'Plasmodium falciparum' as species,
       'Transcription profiling of wild type, Pfsir2A knock-out and Pfsir2B knock-out <i>P. falciparum</i> intra-erythrocytic stages' as display_name,
       'Pfsir2A and Pfsir2B KOs expression profiling in intra-erythrocytic stages' as description,
       'intra-erythrocytic stage' as x_axis,
       'RMA Normalized Values (log base 2 generated with RMAExpress) or expression percentile value. ' as y_axis,
        120 as order_num,
        'FALSE' as mainOpen,
        'FALSE' as dataOpen,
       'rma,pct' as visible_parts,
       'New_Cowman_Sir2_KO' as attribution
from dual

UNION




select 'Profiles of P.falciparum Newbold mRNA Seq data' as profile_name,
       'PfRNASeq::Ver1' as module,
       'Plasmodium falciparum' as species,
       '<i>P.falciparum</i> RNA Sequence Profiles - Intraerythrocytic Cycle' as display_name,
       'Illumina-based massively parallel sequencing was used to gain new insight into the transcriptome (RNA-Seq) of the human malaria parasite, <i>P. falciparum</i>. Using data collected at seven time points during the intraerythrocytic developmental cycle, we (i) detect novel gene transcripts; (ii) correct hundreds of gene models; (iii) propose alternative splicing events; and (iv) predict 5 prime and 3 prime untranslated regions.' as description,
       'Hours in the intraerythrocytic developmental cycle' as x_axis,
       'X/(Y * Z) where X = num bases of reads mapped to the gene; Y = total number of bases (in billions) of reads mapped; Z = length of the gene; Values plotted are log base 2' as y_axis,
        130 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'coverage,pct' as visible_parts,
        'Pfalciparum_RNA_Seq' as attribution
from dual


UNION
select 'Profiles of P.falciparum Stunnenberg mRNA Seq data' as profile_name,
       'Stunnenberg::PfRBCRnaSeq' as module,
       'Plasmodium falciparum' as species,
       '<i>P. falciparum</i> post infection (RBC) RNA Seq (time series)' as display_name,
       'Total RNA was collected from one synchronous 3D7 parasite population at 5, 10, 15, 20, 25, 30, 35 and 40 hours post-invasion of intraerythrocytic development. mRNAs were enriched using polyA-selection (Oligotex dT, Qiagen), fragmented and converted to double-stranded cDNA. All samples were prepared for Illumina sequencing using a customized bias-free sample preparation protocol and sequenced for 76bp from one side of each fragment on an Illumina GAII machine. The scaled graph represents the expression level scaled to the amount of RNA isolated / nucleus to normalize for difference in total RNA produced at different stages of the iRBC cycle. More detail about the scaling can be found on the <a href="showQuestion.do?questionFullName=InternalQuestions.GenesByRNASeqEvidence">P.f. post infection (RBC) RNA-seq time series (fold change)</a> query page.' as description,
       'Time Point post infection' as x_axis,
       'X/(Y * Z) where X = num bases of reads mapped to the gene; Y = total number of bases (in billions) of reads mapped; Z = length of the gene; Values plotted are log base 2' as y_axis,
        140 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'coverage,pct' as visible_parts,
        'RNASeqCoveragePlot_Stunnenberg' as attribution
from dual

UNION

select 'Profiles of P.falciparum duffy mRNA Seq data' as profile_name,
       'Duffy::PfRnaSeq' as module,
       'Plasmodium falciparum' as species,
       '<i>P. falciparum</i> NSR Sequence Coverage' as display_name,
       'NSR-seq was used to analyze the transcriptome of an unsynchronized in vitro culture of human malaria parasite P. falciparum reference strain 3D7, and two pools of field isolates from malaria-infected pregnant women and children adapted to short-term in vitro culture and matched by the percentage of rings, trophozoites and schizonts.' as description,
       'Parasites from pregnant women, Parasites from children, 3D7' as x_axis,
       'X/(Y * Z) where X = num bases of reads mapped to the gene; Y = total number of bases (in billions) of reads mapped; Z = length of the gene; Values plotted are log base 2' as y_axis,
        150 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'coverage' as visible_parts,
        'RNASeqCoveragePlot_Patrick_Duffy' as attribution
from dual
UNION


select 'Profiles of Derisi HalfLife-half_life' as profile_name,
       'DeRisiHalfLife::Combined' as module,
       'Plasmodium falciparum' as species,
       'mRNA half-lives during intraerythrocytic development - 3D7 post treatment with actD' as display_name,
       'Intra-rythrocytic development of Plasmodium 3d7 with the addition of actinomycin D (actD), to achieve transcription inhibition' as description,
       'Erythrocytic lifecycle stages for barplot or time in minutes' as x_axis,
       'mRNA half-lives for each stage of erythrocytic development (in minutes) for barplot or expression level normalized to the 0 Hour' as y_axis,
       157 as order_num,
       'TRUE' as mainOpen,
       'FALSE' as dataOpen,
       'half_life,expr_val' as visible_parts,
       '' as attribution
from dual
UNION

-- AmoebaDB --
select 'EhistolyticaAffyProfiles' as profile_name,
       'Singh::SinghEhTimeSeries' as module,
       'Entamoeba histolytica' as species,
       '<i>E. histolytica</i> Microarray Profiles (Gene expression in <i>E. histolytica</i> cysts and trophozoites)' as display_name,
       '<br><u>RMA normalized</u> (log base 2) values are plotted for each stage/strain in the top graph.<br><br>The <u>Percentile graph</u> (bottom graph) shows the level of expression of each gene relative to other genes in the same strain/stage/media.<br><br><b>Gene expression in Entamoeba histolytica cysts and trophozoites:</b><br>RNA was isolated from <i>E. histolytica</i> parasites recently derived from human patients and grown in xenic culture (Robinson''s media) for 1-8 weeks. These cultures contained a mixture of trophozoites and cysts (as assayed by staining with calcofluor). Two different strains, isolated from different patients, were used. Gene expression in these strains was compared to gene expression in multiple <i>E. histolytica</i> strains (HMI:IMSS, Rahman and 200:NIH)  of pure trophozoites, which had been grown in axenic culture (TYI-S-33)for > 10 years, using a full genome Affymetrix-platform microarray. Multiple lines of evidence suggest that many genes differentially expressed between these two conditions (recent isolates vs. long term lab growth) are developmentally regulated.<br><br>All samples were isolated using Trizol and all except the clinical/cyst samples were cleaned up with the Qiagen RNAeasy kit (those samples had very low RNA levels). Samples GSM154008 (HM1-rep 3) and GSM154011 (Rahman Rep 3) were amplified using the SPIA protocol (these were also hybed and scanned at VBI- other samples were processed entirely by Stanford PAN facility). Samples GSM154022, GSM154023, and GSM154024 (the clinical/cyst samples) were amplified 2 rounds using the standard affy T7 procedure. All others had sufficient RNA and only underwent the standard affy in vitro transcription labeling protocol.' as description,
       'Strain and lifecycle stage' as x_axis,
       'RMA Normalized Values (log base 2) or expression percentile value.' as y_axis,
        160 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'rma,pct' as visible_parts,
        'E.histolytica_Intestinal-Colonization_Stage-Conversion_Array_Profiles' as attribution
from dual
UNION
select 'EhistolyticaNugenProfiles' as profile_name,
       'Gilchrist::GilchristEhTimeSeries' as module,
       'Entamoeba histolytica' as species,
       '<i>E. histolytica</i> Microarray Profiles (Impact of intestinal colonization and invasion on the <i>E. histolytica</i>  transcriptome)' as display_name, 
       '<br><u>RMA normalized</u> (log base 2) values are plotted for each stage/strain in the top graph.<br><br>The <u>Percentile graph</u> (bottom graph) shows the level of expression of each gene relative to other genes in the same strain/stage/media.<br><br><b>Impact of intestinal colonization and invasion on the Entamoeba histolytica  transcriptome:</b><br>An Affymetrix platform gene expression array was designed for this analysis that included probe sets for 9435 open reading frames (ORFs) and 9066 5'' and 3'' flanking regions. Transcripts were detected for > 80% of all ORFs. A total of 523 transcripts (5.2% of all <i>E. histolytica</i> genes) were significantly changed in amebae isolated from the intestine on Days 1 and 29 after infection: 326 and 109 solely on Days 1 and 29, and 88 on both days. Quantitative real-time reverse transcriptase PCR confirmed these changes in 11/12 genes tested using mRNA isolated from an additional six mice.<br><br>HM-1:IMSS and Rahman were not part of this study but have been inlcuded here for comparison' as description,
       'Strain and lifecycle stage' as x_axis,
       'RMA Normalized Values (log base 2) or expression percentile value.' as y_axis,
        170 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'rma,pct' as visible_parts,
        'E.histolytica_Intestinal-Colonization_Stage-Conversion_Array_Profiles' as attribution
from dual
UNION
--TriTrypDB --
select 'T.brucei Horn RNAi Sequence minProfiles' as profile_name,
       'Horn::TbRNAiRNASeq' as module,
       'Trypanosoma brucei' as species,
       'RNAi Target Sequencing - Induced vs Uninduced' as display_name,
       'RNAi target sequencing coverage at different life cycle stages. <br><br>In this experiment RNAi plasmid library, containing randomly sheared genomic fragments was used to create an inducible library in bloodstream form T. brucei . After transfection, the library was grown under non-inducing and inducing conditions and genomic DNA was isolated from surviving populations.<br><br>Cells carrying RNAi target fragments that negatively impact fitness through dsRNA expression and RNAi-mediated ablation are relatively depleted as the population expands and these changes are reported by the depth of sequence coverage relative to the uninduced control (No Tet).' as description,
       'Stage/Sample' as x_axis,
       'Coverage - log 2 (RPKM)' as y_axis,
        180 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'coverage' as visible_parts,
        '' as attribution
from dual
UNION
select 'Linfantum promastigote time-course biorep01' as profile_name,
       'MylerLinfantum::Ver1' as module,
       'Leishmania infantum' as species,
       'Differentiation Time Series: Promastigote to Amastigote' as display_name,
       'Time series data are shown as Fold Induction compared to the 0 hr.  Positive values are upregulated relative to the 0 hour and negative values are downregulated relative to the 0 hour.  The Percentile graph (below) shows the level of expression relative to other genes for the same experiment.  Values in the data table are log2(R/G)' as description,
       'Time point in hours' as x_axis,
       'Fold Induction (vs. 0 hour) or expression percentile value for raw red and green values.' as y_axis,
        180 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'expr_val,pct' as visible_parts,
        'Linfantum_promastigote_ExpressionData' as attribution
from dual
UNION
select 'Profiles of Linfantum axenic and intracellular amastigote array data' as profile_name,
       'Papadopoulou::LiAxenicVsIntracellular' as module,
       'Leishmania infantum' as species,
       'Comparison of Axenic and Intracellular Amastigotes (with Promastigotes) using transcription profiling' as display_name,
       'Comparison of Axenic and Intracellular Amastigotes (with Promastigotes) using transcription profiling' as description,
       'The bars represent a direct comparison of <i>Intercellular Amastigotes vs. Promastigotes (IC.A vs P)</i> <b>AND</b> <i>Axenic Amastigotes vs. Promastigotes (Ax.A vs P)</i>' as x_axis,
       'Fold Induction or percentile.  The percentile was calculated for each channel/sample to give an indication of the expression level of this gene compared to all others on that array.' as y_axis,
        330 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'expr_val,pct' as visible_parts,
        'L.infantum_Papadoupou_Amastigote_Array_PaGE_Analysis' as attribution
from dual
UNION
select 'Expression profiling of T. brucei microarray data from Christine Clayton' as profile_name,
       'Clayton::TbTimeSeries' as module,
       'Trypanosoma brucei' as species,
       'Transcriptome of in vitro cultured <i>T. brucei</i> during bloodstream form to procyclic differentiation' as display_name,
       'Gene Expression during in vitro differentiation from slender bloodstream forms to stumpy and procyclic forms (click on data sources for additional information about this study).  <br>
				Time series data are shown as <u>Fold Induction</u> compared to established procyclic parasites as the common reference (upper graph).  Positive values are upregulated relative to the reference and negative values are downregulated relative to the reference.  <br>
				The <u>Percentile graph</u> (bottom graph) shows the level of expression of each gene relative to other genes in the same time point.  <br>
				Values in the data table (above) are log2(sample/reference) and were used to generate the values in the fold change graph' as description,
       'High and low density blood forms (hd-bf represents the 0 hour in the time series); Time points are in hours' as x_axis,
       'Fold Induction in upper graph or percentile in lower graph.' as y_axis,
        190 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'expr_val' as visible_parts,
        'Tbrucei_Christine_Clayton_RSRC' as attribution
from dual
UNION
select 'Expression profiling of T. brucei differentiation series' as profile_name,
       'Matthews::TbDifferentiationSeries' as module,
       'Trypanosoma brucei' as species,
       'Dynamic mRNA Expression analysis of cells undergoing synchronous life-cycle differentiation in <i>T. brucei</i>' as display_name,
       'mRNA expression profiles of <i>T. brucei</i> slender and stumpy bloodstream stages, as well as during the transition of the stumpy population to the procyclic life-cycle stage. Data
				represents values derived from 5 parallel biological replicates. (click on data sources for additional information about this study).<br>
				Data is plotted as <u>Fold Induction</u> as compared to the 0hr (stumpy form) time point (upper graph).<br>
				The <u>Percentile graph</u> (bottom graph) shows the level of expression of each gene relative to other genes in the same time point.<br>
				The data table above contains RMA values in log2 scale.' as description,
       'Time points are in hours (sl = slender forms)' as x_axis,
       'Fold Induction in upper graph or percentile in lower graph.' as y_axis,
        200 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'expr_val,pct' as visible_parts,
        'Tbrucei_Matthews_differentiation_series_RSRC' as attribution
from dual
UNION
select 'Expression profiling of Tbrucei five life cycle stages' as profile_name,
       'Parsons::TbDevelopmentalStages' as module,
       'Trypanosoma brucei' as species,
       'Widespread variation in transcript abundance within and across developmental stages of <i>T. brucei</i>' as display_name,
       'Whole genome comparison of RNA levels for both protein coding genes and structural RNAs in five different life-cycle stages: cultured bloodstream form (bf), in vivo slender bloodstream form (sl), in vivo stumpy bloodstream form (st), log-phase procyclic culture form (pf_log) and stationary-phase procyclic culture form (pf_stat).  Data is averaged from three biological replicas (click on data sources for additional information about this study).<br>
<u>RMA normalized</u> (log base 2) values are plotted for each stage in the top graph.<br>
The <u>Percentile graph </u> (bottom graph) shows the level of expression of each gene relative to other genes in the same life-cycle stage.<br>
The data table above contains the actual expression values.  <b>For this experiment, in the cases where the probe set mapped to near-identical genes, data was assigned to a single representative gene. (see Jensen et al.  PMID: 19840382)</b>
' as description,
       'Average value from three independent biological replicates from five different life cycle stages.' as x_axis,
       'RMA Normalized Values (log base 2) or expression percentile value.' as y_axis,
        210 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'rma,pct' as visible_parts,
        'Tbrucei_Parsons_Five_Life_Cycle_Stages_RSRC' as attribution
from dual
UNION
select 'Profiles of T.cruzi Tarleton Rick array data' as profile_name,
       'Tarleton::TcTranscriptome' as module,
       'Trypanosoma cruzi' as species,
       'Transcriptome analysis of the <i>T. cruzi</i> life-cycle' as display_name,
       'RNA from 3 biological replicates from a single time point in each stage were subjected to DNA microarrays containing probes for the complete, annotated <i>T. cruzi</i> genome (click on data sources for additional information about this study). <br>
				Data is plotted as <u>Fold Induction</u> as compared to a control sample consisting of an equal mixture of all four life-cycle stages (Upper graph). <br>
				The <u>Percentile graph</u> (bottom graph) shows the level of expression of each gene relative to other genes in the same lifecycle stage.<br>
				The data table above contains are log2(Red/green) expression values' as description,
       'Average of 3 biological replicates from each Life cycle stage: trypomastigotes(TRP), amastigotes (AMA), epimastigotes (EPI), and metacyclic trypomastigotes (MET).' as x_axis,
       'Fold Induction or percentile.' as y_axis,
        220 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'expr_val,pct' as visible_parts,
        'Tcruzi_Tarleton_Rick_RSRC' as attribution
from dual
UNION
select 'Profiles of L.major Beverly Steve array data' as profile_name,
       'Beverley::LmThreeDevStages' as module,
       'Leishmania major' as species,
       'Transcription profiling of three developmental stages of Leishmania major - earlylLog, PNA- metacyclics and mouse lesion derived amastigotes' as display_name,
       'Comparison of three developmental stages (Early Log, PNA- metacyclics and Mouse lesion Derived Amastigotes) of L.major FV1.' as description,
       'The bars represent a direct comparison of <i>Mouse Lesion Derived Amastigotes vs. Early Log Procyclic Promastigotes (A v P)</i> <b>OR</b> <i>PNA - Metacyclic Promastigotes vs. Early Log Procyclic Promastigotes (M v P)</i>.  Data for each biologial replicate (3) for each comparison are shown.  The expression values provided in the data table are log2(A/P) and log2(M/P) for each of the replicates.' as x_axis,
       'Fold Induction or percentile.  The percentile was calculated for each channel/sample to give an indication of the expression level of this gene compared to all others on that array.' as y_axis,
        230 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'expr_val,pct' as visible_parts,
        'Lmajor_Beverley_Steve_LifeStages_RSRC' as attribution
from dual
UNION
select 'Expression profiling of Tbrucei Procyclic TbDRBD3 depletion' as profile_name,
       'Estevez::Drbd3Depletion' as module,
       'Trypanosoma brucei' as species,
       'Effect of TbDRBD3 depletion on procyclic <i>T. brucei</i> transcriptome' as display_name,
       'In order to analyze whether TbDRBD3 has a role in the regulation of mRNA turnover, the transcriptome of procyclic trypanosomes depleted of TbDRBD3 was compared to that of uninduced cells using hybridizations of genomic microarrays. RNA samples were isolated from cells harvested after 48 hours of induction with tetracycline. At this point, cell growth was barely affected and trypanosomes remained highly motile. 15 microg of RNA were reverse-transcribed in the presence of 100 ng of oligo(dT)12-18, 0.25 mM dATP, 0.25 mM dTTP, 0.25 mM dGTP, 0.05 mM dCTP, 0.05 mM Cy3- or Cy5-dCTP, 50 mM Tris-HCl, pH 8.3, 75 mM KCl, 3 mM MgCl2, 5 mM DTT, 40 U of RNaseOUT (Invitrogen) and 400 U of Superscript III reverse transcriptase (Invitrogen). Reactions were incubated for 3 hours at 50 degrees C, stopped by heating at 70 degrees C for 15 min and treated with 5 U of RNase H for 20 min at 37 degrees C. cDNA was purified using the MinElute kit (Qiagen), ethanol precipitated and resuspended in hybridization buffer. Genomic T. brucei microarray glass slides containing ca. 24,000 independent random genomic clones (Brems et al., 2005) were pre-hybridized and hybridized as described (Diehl et al., 2002). Four hybridizations (two biological replicates with a dye swap each) were analyzed.' as description,
       'Direct comparison; 2 biological replicates' as x_axis,
       'Fold Induction or percentile.' as y_axis,
        240 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
        'expr_val' as visible_parts,
        'Tbrucei_Estevez_Procyclic_TbDRBD3_Depletion_RSRC_Profiles' as attribution
from dual
UNION
select 'T.brucei George Cross RNA Sequence min-Profiles' as profile_name,
       'Cross::TbRnaSeqBfPf' as module,
       'Trypanosoma brucei' as species,
       '<i>T. brucei</i> blood and procyclic forms RNA Sequence Coverage' as display_name,
       'The coverage values in the graph are displayed in log2 scale' as description,
       'Cultured Procyclic T. brucei Lister 427 and Cultured Bloodstream T. brucei Lister 427' as x_axis,
       'log2 of the transcript levels of reads per kilobase of exon model per million mapped reads (RPKM).  Stacked bars indicate unique and non-uniquely mapped sequences.  Non-Unique sequences are plotted to indicate the maximum expression potential of this gene.
' as y_axis,
        250 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'coverage,pct' as visible_parts,
        'Tbrucei_RNASeq_George_Cross_RSRC' as attribution
from dual
UNION
select 'T. brucei under heat shock array data' as profile_name,
       'Carrington::TbHeatShock' as module,
       'Trypanosoma brucei' as species,
       '<i>T. brucei</i> heat shock array data' as display_name,
       'Procyclic trypanosomes (strain 427 lister) were grown in culture under standard conditions at 27&deg;C in SDM79 medium with 10% foetal bovine serume (Brun and Schnenberger, 1979), in a gazed incubator (5% CO2). Logarithmically growing procyclic cells (at about 5*10^6 cells/ml, at 27&deg;C) were added to one volume medium that had been heated to 53&deg;C and incubated at 41&deg;C for 60 minutes in a waterbath in a closed tube (41&deg;C sample). The control cells were added to one volume medium at 27&deg;C and also incubated for 60 minutes in a closed tube at 27&deg;C. Cells were harvested and washed once in PBS. The harvesting was done within 8 minutes.' as description,
       'The bar represent the heat shock data versus the control' as x_axis,
       'Fold Induction or percentile.' as y_axis,
        260 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
        'expr_val,pct' as visible_parts,
        'T.brucei_Carrington_HeatShock_Array_PaGE_Analysis' as attribution
from dual
UNION
select 'T. brucei DHH1 wild type array data' as profile_name,
       'Carrington::TbCombined' as module,
       'Trypanosoma brucei' as species,
       '<i>T. brucei</i> DHH1 wild type and DHH1 DEAD-DQAD mutant array data' as display_name,
       'Induction of the expression of the DHH1 wild type and the DHH1 DEAD:DQAD mutant from pLEW100 for 24 hours (thus, &plusmn; 24 hours Tetracycline). Non-induced cells were used as control.' as description,
       'The bars represent the DHH1 wild type and DHH1 DEAD-DQAD mutant data versus the control' as x_axis,
       'Fold Induction or percentile.' as y_axis,
        270 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
        'expr_val,pct' as visible_parts,
        'T.brucei_Carrington_DHH1_induction_wildType_Array_PaGE_Analysis,T.brucei_Carrington_DHH1_induction_Mutant_Array_PaGE_Analysis' as attribution
from dual
UNION
select 'Lmajor RNASeq Spliced Leader And Poly A Sites from Myler uniqProfile' as profile_name,
       'Myler::LmSpliceSites' as module,
       'Leishmania major' as species,
       'Splice Leader mapping of <i>L. major</i> Friedlin promastigotes by RNASeq' as display_name,
       'The coverage values in the graph are displayed in log2 scale' as description,
       '<i>L. major</i> Random and Not so random (NSR)' as x_axis,
       'log2 of (number of aligned tags / million aligned tags). Stacked bars indicate unique and non-uniquely mapped sequences.  Non-Unique sequences are plotted to indicate the maximum expression potential of this gene.
' as y_axis,
        280 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'coverage,pct' as visible_parts,
        'Lmajor_RNASeq_Spliced_Leader_And_Poly_A_Sites_Myler_RSRC' as attribution
from dual
UNION
select 'T.brucei RNASeq Spliced Leader And Poly A Sites from Nilsson uniqProfile' as profile_name,
       'Nilsson::TbSpliceSites' as module,
       'Trypanosoma brucei' as species,
       'Splice Leader mapping of <i>T. brucei</i>' as display_name,
       'The coverage values in the graph are displayed in log2 scale' as description,
       '<i>T.brucei</i> Long Slender, Short Stumpy, bloodstream 427, procyclic_late, Alba 1 non-induced, Alba 1 induced SLT, Alba 3 and 4 non-induced, Alba 3 and 4 induced SLT' as x_axis,
       'log2 of (number of aligned tags / million aligned tags). Stacked bars indicate unique and non-uniquely mapped sequences.  Non-Unique sequences are plotted to indicate the maximum expression potential of this gene.
' as y_axis,
        290 as order_num,
        'TRUE' as mainOpen,
        'FALSE' as dataOpen,
       'coverage,pct' as visible_parts,
        'Tbrucei_RNASeq_Spliced_Leader_And_Poly_A_Sites_Nilsson_RSRC' as attribution
from dual
)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.MassSpecTerms">
    <sql>
      <![CDATA[
CREATE TABLE apidb.MassSpecTerms&1 NOLOGGING AS
SELECT project_id, extDB_name, display_term FROM (
select 'CryptoDB' as project_id,
       '1D Gel LC-MS/MS ' as display_term,
       'Wastling MassSpec 1D Gel LC-MS/MS' as extDB_name
from dual
UNION
select 'CryptoDB' as project_id,
       '2D Gel LC-MS/MS ' as display_term,
       'Wastling MassSpec 2D Gel LC-MS/MS' as extDB_name
from dual
UNION
select 'CryptoDB' as project_id,
       'MudPit Soluble fractions ' as display_term,
       'Wastling MassSpec MudPit Soluble' as extDB_name
from dual
UNION
select 'CryptoDB' as project_id,
       'MudPit Insoluble fractions ' as display_term,
       'Wastling MassSpec MudPit Insoluble' as extDB_name
from dual
UNION
select 'CryptoDB' as project_id,
       'Insoluble Excysted Fraction LC-MS/MS ' as display_term,
       'Lowery MassSpec LC-MS/MS Insoluble Excysted Fraction' as extDB_name
from dual
UNION
select 'CryptoDB' as project_id,
       'Insoluble Non-excysted Fraction LC-MS/MS ' as display_term,
       'Lowery MassSpec LC-MS/MS Insoluble Non-excysted fraction' as extDB_name
from dual
UNION
select 'CryptoDB' as project_id,
       'Soluble Excysted and Non-excysted Fraction LC-MS/MS ' as display_term,
       'Lowery MassSpec LC-MS/MS Soluble Excysted and Non-excysted fractions' as extDB_name
from dual
UNION
select 'CryptoDB' as project_id,
       '1D Gel 14Aug2006 ' as display_term,
       'Fiser_Proteomics_14Aug2006_1D_gel' as extDB_name
from dual
UNION
select 'CryptoDB' as project_id,
       '1D Gel 16May2006 ' as display_term,
       'Fiser_Proteomics_16May2006_1D_gel' as extDB_name
from dual
UNION
select 'CryptoDB' as project_id,
       '1D Gel 24Jun2006 ' as display_term,
       'Fiser_Proteomics_24Jun2006_1D_gel' as extDB_name
from dual
UNION
select 'CryptoDB' as project_id,
       'Oocyst walls ' as display_term,
       'Ferrari_Proteomics_LTQ_Oocyst_walls' as extDB_name
from dual
UNION
select 'CryptoDB' as project_id,
       'Intact Oocysts ' as display_term,
       'Ferrari_Proteomics_LTQ_intact_oocysts_merged' as extDB_name
from dual
UNION
select 'CryptoDB' as project_id,
       'Sporozoites ' as display_term,
       'Ferrari_Proteomics_LTQ_Sporozoites_merged' as extDB_name
from dual
UNION
select 'CryptoDB' as project_id,
       'Mitochondrial Fraction' as display_term,
       'C. parvum mass spec data from Lorenza Putignani' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Merozoite ' as display_term,
       'Florens_Life_Cycle_MassSpec_Mrz_RSRC' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Merozoite ' as display_term,
       'Florens Life Cycle MassSpec-Merozoites' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Trophozoite ' as display_term,
       'Florens Life Cycle MassSpec-Trophozoites ' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Trophozoite ' as display_term,
       'Florens_Life_Cycle_MassSpec_Tpz_RSRC' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Gametocyte ' as display_term,
       'Florens_Life_Cycle_MassSpec_Gmt_RSRC' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Gametocyte ' as display_term,
       'Florens Life Cycle MassSpec-Gametocytes' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Sporozoite ' as display_term,
       'Florens_Life_Cycle_MassSpec_Spz_RSRC' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Sporozoite ' as display_term,
       'Florens Life Cycle MassSpec-Sporozoite' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Merozoite Peptides ' as display_term,
       'Pf_Merozoite_Peptides_RSRC' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Merozoite Peptides ' as display_term,
       'Kahn Pfalciparum merozoite peptides' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Mosquito Oocyst Peptides ' as display_term,
       'Lasonder_Mosquito_Oocysts_Mass_Spec_RSRC' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Mosquito Oocyst Peptides ' as display_term,
       'Lasonder Mosquito oocyst peptides' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Mosquito Oocyst-derived Sporozoite Peptides ' as display_term,
       'Lasonder_Mosquito_oocyst_derived_sporozoites_RSRC' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Mosquito Oocyst-derived Sporozoite Peptides ' as display_term,
       'Lasonder Mosquito oocyst-derived sporozoite peptides' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Mosquito Salivary Gland Sporozoite Peptides ' as display_term,
       'Lasonder_Mosquito_salivary_gland_sporozoites_RSRC' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Mosquito Salivary Gland Sporozoite Peptides ' as display_term,
       'Lasonder Mosquito salivary gland sporozoite peptides' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Blood Stages - Trophozoites' as display_term,
       'Pf_Lasonder_Proteomics_Blood_Stages_trophozoites_RSRC' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Blood Stages - Early Gametocytes' as display_term,
       'Pf_Lasonder_Proteomics_Blood_Stages_early_gametocytes_RSRC' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Blood Stages - Late Gametocytes' as display_term,
       'Pf_Lasonder_Proteomics_Blood_Stages_late_gametocytes_RSRC' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'iRBC Membrane (PIESPs) / Schizont  ' as display_term,
       'Florens_PIESPs_MassSpec_RSRC' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'iRBC Membrane (PIESPs) / Schizont  ' as display_term,
       'Florens PIESPs MassSpec' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'P.falciparum Clinical Proteomics ' as display_term,
       'P.falciparum Clinical Proteomics' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'P.falciparum Clinical Proteomics ' as display_term,
       'Pfalciparum_Tatu_Clinical_Proteomics_RSRC' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'P.falciparum Proteome 42 hrs Post Infection' as display_term,
       'Pfalciparum_Bowyer_Proteomics_42hrs_Post_Infection' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'P.falciparum Proteome 42 hrs Post Infection' as display_term,
       'Pf_Bowyer_Proteomics_42hrs_Post_Infection_RSRC' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'P.falciparum Proteome 48 hrs Post Infection' as display_term,
       'Pfalciparum_Bowyer_Proteomics_48hrs_Post_Infection' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'P.falciparum Proteome 48 hrs Post Infection' as display_term,
       'Pf_Bowyer_Proteomics_48hrs_Post_Infection_RSRC' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Female Gametocytes ' as display_term,
       'Waters Female Gametes' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Female Gametocytes ' as display_term,
       'Waters_female_gametes_RSRC' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Male Gametocytes ' as display_term,
       'Waters Male Gametes' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Male Gametocytes ' as display_term,
       'Waters_male_gametes_RSRC' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Mixed Gametocytes ' as display_term,
       'Waters Mixed Gametes' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Mixed Gametocytes ' as display_term,
       'Waters_mixed_gametes_RSRC' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'P.vivax Clinical Proteomics' as display_term,
       'P.vivax Clinical Proteomics' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'P.vivax Clinical Proteomics' as display_term,
       'Pvivax_Tatu_Clinical_Proteomics_RSRC' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Liver Stage LS40 ' as display_term,
       'Pyoelii LiverStage LS40' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Liver Stage LS40 ' as display_term,
       'Pyoelii_LiverStage_LS40_RSRC' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Liver Stage LS50 ' as display_term,
       'Pyoelii LiverStage LS50' as extDB_name
from dual
UNION
select 'PlasmoDB' as project_id,
       'Liver Stage LS50 ' as display_term,
       'Pyoelii_LiverStage_LS50_RSRC' as extDB_name
from dual
UNION
select 'TrichDB' as project_id,
       'T. vaginalis subcellular fraction' as display_term,
       'Hayes-Johnson_Tvag_Proteomics' as extDB_name
from dual
UNION
select 'ToxoDB' as project_id,
       '1-D SDS PAGE' as display_term,
       'Wastling 1-D SDS PAGE' as extDB_name
from dual
UNION
select 'ToxoDB' as project_id,
       '1-D SDS PAGE Soluble Fraction' as display_term,
       'Wastling 1-D SDS PAGE Soluble' as extDB_name
from dual
UNION
select 'ToxoDB' as project_id,
       '1-D SDS PAGE Insoluble Fraction' as display_term,
       'Wastling 1-D SDS PAGE Insoluble' as extDB_name
from dual
UNION
select 'ToxoDB' as project_id,
       'MudPIT Soluble Fraction' as display_term,
       'Wastling MudPIT Soluble' as extDB_name
from dual
UNION
select 'ToxoDB' as project_id,
       'MudPIT Insoluble Fraction' as display_term,
       'Wastling MudPIT Insoluble' as extDB_name
from dual
UNION
select 'ToxoDB' as project_id,
       'Rhoptry Fraction' as display_term,
       'Wastling Rhoptry' as extDB_name
from dual
UNION
select 'ToxoDB' as project_id,
       'Conoid-enriched Fraction' as display_term,
       'Murray Conoid-enriched Fraction' as extDB_name
from dual
UNION
select 'ToxoDB' as project_id,
       'Conoid-depleted Fraction' as display_term,
       'Murray Conoid-depleted Fraction' as extDB_name
from dual
UNION
select 'ToxoDB' as project_id,
       '1D Gel Tachyzoite Membrane fraction 12-2006' as display_term,
       '1D Gel Tachyzoite Membrane fraction 12-2006' as extDB_name
from dual
UNION
select 'ToxoDB' as project_id,
       '1D Gel Tachyzoite Membrane fraction 10-2006' as display_term,
       '1D Gel Tachyzoite Membrane fraction 10-2006' as extDB_name
from dual
UNION
select 'ToxoDB' as project_id,
       '2DLC MS/MS Tachyzoite Membrane fraction' as display_term,
       '2DLC MS/MS Tachyzoite Membrane fraction' as extDB_name
from dual
UNION
select 'ToxoDB' as project_id,
       'MS Tachyzoite Cytosolic fraction 05-2007' as display_term,
       'MS Tachyzoite Cytosolic Protein Fractions 05-2007' as extDB_name
from dual
UNION
select 'ToxoDB' as project_id,
       'MS Tachyzoite Membrane fraction 05-02-2006' as display_term,
       'MS Tachyzoite Membrane fraction 05-02-2006' as extDB_name
from dual
UNION
select 'ToxoDB' as project_id,
       'MS Tachyzoite Membrane fraction 06-2006' as display_term,
       'MS Tachyzoite Membrane fraction 06-2006' as extDB_name
from dual
UNION
select 'ToxoDB' as project_id,
       'MS Tachyzoite Membrane fraction 05-10-2006' as display_term,
       'MS Tachyzoite Membrane fraction 05-10-2006' as extDB_name
from dual
UNION
select 'ToxoDB' as project_id,
       'MS Tachyzoite Membrane fraction 02-03-2006' as display_term,
       'MS Tachyzoite Membrane fraction 02-03-2006' as extDB_name
from dual
UNION
select 'ToxoDB' as project_id,
       'MS Tachyzoite Membrane Protein with  Biotinlyation Purification 05-22-2007' as display_term,
       'MS Tachyzoite Membrane Protein with  Biotinlyation Purification 05-22-2007' as extDB_name
from dual
UNION
select 'ToxoDB' as project_id,
       'MS RH Secretome fraction 2destinct peptides' as display_term,
       'MS Carruthers 2destinct peptides' as extDB_name
from dual
UNION
select 'ToxoDB' as project_id,
       'MS RH Secretome fraction MudPIT Twinscan hits' as display_term,
       'MS Carruthers MudPIT Twinscan hits' as extDB_name
from dual
UNION
select 'ToxoDB' as project_id,
       'RH Mass Spec Data (sample A)' as display_term,
       'Moreno DTASelect filter sample A' as extDB_name
from dual
UNION
select 'ToxoDB' as project_id,
       'RH Mass Spec Data (sample G)' as display_term,
       'Moreno DTASelect filter sample G' as extDB_name
from dual
UNION
select 'GiardiaDB' as project_id,
       'DTA-Select Filter ' as display_term,
       'DTASelect-filter_032108_Proteomics' as extDB_name
from dual
UNION
select 'GiardiaDB' as project_id,
       'G. intestinalis mitosome enriched fraction - nanoLC/MALDI TOF/TOF ' as display_term,
       'Giardia proteomics data from Tachezy lab' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>Trypanosoma cruzi</i> Esmeraldo-like Amastigote ' as display_term,
       'TcruziEsmeraldoLike_Proteomics_Brent_Amastigote_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>Trypanosoma cruzi</i> Non-Esmeraldo-like Amastigote ' as display_term,
       'TcruziNonEsmeraldoLike_Proteomics_Brent_Amastigote_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>T. cruzi</i> Esmeraldo-like Epimastigote ' as display_term,
       'TcruziEsmeraldoLike_Proteomics_Brent_Epimastigote_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>T. cruzi</i> Non-Esmeraldo-like Epimastigote ' as display_term,
       'TcruziNonEsmeraldoLike_Proteomics_Brent_Epimastigote_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>T. cruzi</i> Esmeraldo-like Metacyclic ' as display_term,
       'TcruziEsmeraldoLike_Proteomics_Brent_Metacyclic_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>T. cruzi</i> Non-Esmeraldo-like Metacyclic ' as display_term,
       'TcruziNonEsmeraldoLike_Proteomics_Brent_Metacyclic_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>T. cruzi</i> Esmeraldo-like Trypomastigote ' as display_term,
       'TcruziEsmeraldoLike_Proteomics_Brent_Trypomastigote_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>T. cruzi</i> Non-Esmeraldo-like Trypomastigote ' as display_term,
       'TcruziNonEsmeraldoLike_Proteomics_Brent_Trypomastigote_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>T. cruzi</i> Esmeraldo-like reservosomes-B1 fraction digested with trypsin and endoproteinase Glu-C ' as display_term,
       'TcruziEsmeraldoLike_Proteomics_Reservosomes_B1TG_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>T. cruzi</i> Non-Esmeraldo-like reservosomes-B1 fraction digested with trypsin and endoproteinase Glu-C ' as display_term,
       'TcruziNonEsmeraldoLike_Proteomics_Reservosomes_B1TG_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>T. cruzi</i> Esmeraldo-like reservosomes-B1 fraction digested with trypsin' as display_term,
       'TcruziEsmeraldoLike_Proteomics_Reservosomes_B1TU_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>T. cruzi</i> Non-Esmeraldo-like reservosomes-B1 fraction digested with trypsin' as display_term,
       'TcruziNonEsmeraldoLike_Proteomics_Reservosomes_B1TU_RSRC' as extDB_name
from dual
  UNION
select 'TriTrypDB' as project_id,
       '<i>T. cruzi</i> Esmeraldo-like reservosomes-B1M fraction digested with trypsin ' as display_term,
       'TcruziEsmeraldoLike_Proteomics_Reservosomes_B1MTU_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>T. cruzi</i> Non-Esmeraldo-like reservosomes-B1M fraction digested with trypsin ' as display_term,
       'TcruziNonEsmeraldoLike_Proteomics_Reservosomes_B1MTU_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>T. cruzi</i> Esmeraldo-like Proteomic Analysis of Detergent-Solubilized Membrane Proteins from Insect-Developmental Forms ' as display_term,
       'TcruziEsmeraldoLike_Proteomics_Membrane_Protein_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>T. cruzi</i> Non-Esmeraldo-like Proteomic Analysis of Detergent-Solubilized Membrane Proteins from Insect-Developmental Forms ' as display_term,
       'TcruziNonEsmeraldoLike_Proteomics_Membrane_Protein_RSRC;' as extDB_name
from dual
UNION

select 'TriTrypDB' as project_id,
       '<i>T. brucei</i> Procyclic Form ' as display_term,
       'Tbrucei_Proteomics_PF_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       'Amastigote' as display_term,
       'Amastigote' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       'Promastigote' as display_term,
       'Promastigote' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       'Post translational modification' as display_term,
       'ptl' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>L. infantum</i> - glycosylated ' as display_term,
       'Linfantum_Proteomics_PTM_glycosylation_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>L. infantum</i> - acetylated ' as display_term,
       'Linfantum_Proteomics_PTM_acetylation_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>L. infantum</i> - methylated ' as display_term,
       'Linfantum_Proteomics_PTM_methylation_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>L. infantum</i> - phosphorylated' as display_term,
       'Linfantum_Proteomics_PTM_phosphorylation_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>L. infantum</i> Amastigote (1DGel) ' as display_term,
       'Linfantum_Proteomics_Brotherton_SDS_Amastigote_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>L. infantum</i> Amastigote (2DGel pH6-9) ' as display_term,
       'Linfantum_Proteomics_Brotherton_2DGel_6_9_Amastigote_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>L. infantum</i>  Amastigote (2DGel pH6-11) ' as display_term,
       'Linfantum_Proteomics_Brotherton_2DGel_6_11_Amastigote_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>L. infantum</i> Promastigote (2DGel pH6-9) ' as display_term,
       'Linfantum_Proteomics_Brotherton_2DGel_6_9_Promastigote_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>L. infantum</i> Promastigote (2DGel pH6-11) ' as display_term,
       'Linfantum_Proteomics_Brotherton_2DGel_6_11_Promastigote_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       'Metacyclogenesis (pH 5-6)' as display_term,
       'Linfantum_Proteomics_OuelletteM_Metacyclic_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>L. infantum</i>  Promastigote temperature and pH Control ' as display_term,
       'Linfantum_Proteomics_Brotherton_Promastigote_temperature_and_pH_non_stressed_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>L. infantum</i>  Promastigote temperature and pH stressed ' as display_term,
       'Linfantum_Proteomics_Brotherton_Promastigote_temperature_and_pH_stressed_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>L. infantum</i> Amastigote (Secreted) ' as display_term,
       'Linfantum_Proteomics_Brotherton_Amastigote_Secreted_Protein_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>L. infantum</i> Promastigote (Secreted) ' as display_term,
       'Linfantum_Proteomics_Brotherton_Promastigote_Secreted_Protein_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>L. braziliensis</i> Promastigotes ' as display_term,
       'Lbraziliensis_Proteomics_Promastigotes_Secreted_RSRC' as extDB_name
from dual
UNION
select 'TriTrypDB' as project_id,
       '<i>L. major</i> Exosomes' as display_term,
       'Lmajor_Proteomics_Exosomes_RSRC' as extDB_name
from dual
)
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="apidb.NaSynteny">
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="dots.Similarity"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.NaSynteny&1 NOLOGGING AS
SELECT
    sim.similarity_id,
    extq.na_sequence_id query_na_sequence_id,
    extt.na_sequence_id target_na_sequence_id,
    extq.source_id query_source_id,
    extt.source_id target_source_id,
    sim.min_subject_start ,
    sim.max_subject_end ,
    sim.min_query_start ,
    sim.max_query_end,
    sim.is_reversed,
    sim.score,
    sim.pvalue_mant,
    sim.pvalue_exp
FROM
    dots.Similarity sim,
    dots.ExternalNaSequence extt,
    dots.ExternalNaSequence extq,
    core.TableInfo qtab,
    core.TableInfo stab
WHERE
    sim.query_id = extq.na_sequence_id and
    sim.subject_id = extt.na_sequence_id and
    sim.subject_table_id = stab.table_id and
    stab.name = 'ExternalNASequence'and
    sim.query_table_id  = qtab.table_id and
    qtab.name = 'ExternalNASequence'
UNION
SELECT
    sim.similarity_id,
    extt.na_sequence_id query_na_sequence_id,
    extq.na_sequence_id target_na_sequence_id,
    extt.source_id query_source_id,
    extq.source_id target_source_id,
    sim.min_query_start min_subject_start,
    sim.max_query_end max_subject_end,
    sim.min_subject_start min_query_start,
    sim.max_subject_end max_query_end,
    sim.is_reversed,
    sim.score,
    sim.pvalue_mant,
    sim.pvalue_exp
FROM
    dots.Similarity sim,
    dots.ExternalNaSequence extt,
    dots.ExternalNaSequence extq,
    core.TableInfo qtab,
    core.TableInfo stab
WHERE
    sim.query_id = extq.na_sequence_id and
    sim.subject_id = extt.na_sequence_id and
    sim.subject_table_id = stab.table_id and
    stab.name = 'ExternalNASequence'and
    sim.query_table_id  = qtab.table_id and
    qtab.name = 'ExternalNASequence'
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE BITMAP INDEX apidb.syn_query_ix&1 ON apidb.NaSynteny&1(query_na_sequence_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE BITMAP INDEX apidb.syn_target_ix&1 ON apidb.NaSynteny&1(target_na_sequence_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.Subcellular">
    <internalDependency name="apidb.GeneAttributes"/>
    <externalDependency name="dots.AaFeatureImp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.Subcellular&1 NOLOGGING AS
select ga.source_id, 'ht' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf, apidb.GeneAttributes ga
where ed.name in ('subcellular motif from Haldar','Haldar_Subcellular_motifs_RSRC')
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
  and paf.source_id = ga.source_id
union
select ga.source_id, 'pexel' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf, apidb.GeneAttributes ga
where ed.name in ('subcellular motif from Cowman','Cowman_Subcellular_motifs_RSRC')
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
  and paf.source_id = ga.source_id
union
select ga.source_id, 'apicoplast' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf, apidb.GeneAttributes ga
where ed.name in ('apicoplast targeting data from 4.4','Pf_ApicoplastTargeting_RSRC')
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
  and paf.source_id = ga.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.subc_ix&1 ON apidb.Subcellular&1(source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.Expression">
    <externalDependency name="apidb.Profile"/>
    <externalDependency name="apidb.ProfileElement"/>
    <externalDependency name="apidb.ProfileElementName"/>
    <externalDependency name="apidb.ProfileSet"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.Expression&1 NOLOGGING AS
  SELECT pct_p.source_id, pct_pe.value, pct_ps.name AS profile_set_name,
       pct_pe.element_order, pen.name AS element_name
  FROM apidb.ProfileSet pct_ps,
     apidb.Profile pct_p, apidb.ProfileElement pct_pe,apidb.ProfileElementName pen,
     apidb.ProfileSet exp_ps,
     apidb.Profile exp_p, apidb.ProfileElement exp_pe
  WHERE pct_ps.profile_set_id = pct_p.profile_set_id
  AND pct_p.profile_id = pct_pe.profile_id
  AND pct_ps.name like '%Pct'
  AND exp_ps.profile_set_id = exp_p.profile_set_id
  AND exp_p.profile_id = exp_pe.profile_id
  AND exp_pe.element_order = pct_pe.element_order
  AND exp_p.source_id = pct_p.source_id
  AND exp_ps.name = REPLACE(pct_ps.name, 'Pct', 'Exp')
  AND pct_ps.profile_set_id = pen.profile_set_id
  AND exp_pe.element_order = pen.element_order
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Exp_value_ix&1 ON apidb.Expression&1 (value, element_order, source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Exp_element_ix&1 ON apidb.Expression&1 (element_order, source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SnpSummary">
    <externalDependency name="dots.AaFeatureImp"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="dots.SeqVariation"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.SnpSummary&1 NOLOGGING AS
SELECT cds_length, na_feature_id, source_id,
       strain_a, strain_b,
       sum(synonymous) as synonymous,
       sum(non_synonymous) as non_synonymous,
       sum(non_coding) as non_coding,
       sum(stop) as stop,
       sum(non_coding) + sum(synonymous) + sum(non_synonymous) as total
FROM  (SELECT greatest(taf.translation_start, taf.translation_stop)
              - least(taf.translation_start, taf.translation_stop) + 1 AS cds_length,
              gf.na_feature_id, gf.source_id,
              edr.external_database_release_id,
              SUBSTR(sva.strain, 1, 30) AS strain_a,
              SUBSTR(svb.strain, 1, 30) AS strain_b,
              CASE WHEN sva.product IS NULL THEN 1 ELSE 0 END AS non_coding,
              CASE WHEN sva.product = svb.product THEN 1 ELSE 0 END AS synonymous,
              CASE WHEN sva.product != svb.product THEN 1 ELSE 0 END AS non_synonymous,
              CASE WHEN sva.product = '*' OR  svb.product = '*' THEN 1 ELSE 0 END AS stop
       FROM dots.SeqVariation sva, dots.SeqVariation svb, dots.SnpFeature sf,
            dots.SplicedNaSequence cds, dots.Transcript, dots.GeneFeature gf,
            dots.TranslatedAaFeature taf, sres.ExternalDatabase ed,
            sres.ExternalDatabaseRelease edr
       WHERE ed.name NOT IN ('Pf_Broad_SNPs_RSRC','Broad SNPs', 'Sanger falciparum SNPs','sangerItGhanaSnps_RSRC',
                             'X.Su SNPs','Pf_XSuSnps_RSRC')
         AND sva.strain  < svb.strain
         AND sva.allele != svb.allele
         AND sva.parent_id = svb.parent_id
         AND sva.parent_id = sf.na_feature_id
         AND sf.parent_id = gf.na_feature_id
         AND sf.external_database_release_id = edr.external_database_release_id
         AND edr.external_database_id = ed.external_database_id
         AND gf.na_feature_id = transcript.parent_id
         AND transcript.na_sequence_id = cds.na_sequence_id
         AND transcript.na_feature_id = taf.na_feature_id
)
GROUP BY cds_length, na_feature_id, source_id,
         strain_a, strain_b
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SnpSummary_idx&1
       ON apidb.SnpSummary&1(na_feature_id, source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SnpSummary_strain_idx&1
       ON apidb.SnpSummary&1(strain_a, strain_b, source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SnpSummary_strainb_idx&1
       ON apidb.SnpSummary&1(strain_b, strain_a, source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SnpSummary_srcId_idx&1
       ON apidb.SnpSummary&1(source_id, na_feature_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.Scaffold_Map">
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="dots.SequencePiece"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.Scaffold_Map&1 NOLOGGING AS
     SELECT
      na_sequence_id as virtual_na_sequence_id,
      parent_id as virtual_source_id,
      piece_na_sequence_id,
      source_id as piece_source_id,
      (offset + 1) as startm,
      (offset + length) as end,
      strand_orientation,
      length,
      sequence_order
FROM (
(SELECT vs.na_sequence_id, vs.source_id as parent_id, ens.source_id,
       sp.piece_na_sequence_id, sp.sequence_order,
       ens.length, vs.length as chr_length, sp.strand_orientation,
       0 as offset
 FROM dots.VirtualSequence vs, apidb.SequencePieceClosure sp,
     dots.ExternalNaSequence ens
 WHERE vs.na_sequence_id = sp.virtual_na_sequence_id
  and ens.na_sequence_id = sp.piece_na_sequence_id
  and sp.sequence_order = 1
GROUP by vs.na_sequence_id, vs.source_id, ens.source_id, sp.piece_na_sequence_id, sp.sequence_order,
       ens.length, vs.length, sp.strand_orientation)
UNION
(SELECT vs.na_sequence_id, vs.source_id as parent_id, ens.source_id,
       sp.piece_na_sequence_id, sp.sequence_order,
       ens.length, vs.length as chr_length, sp.strand_orientation,
       sum(predecessors.length) as offset
 FROM dots.VirtualSequence vs, apidb.SequencePieceClosure sp,
     dots.ExternalNaSequence ens,
     (select sp2.virtual_na_sequence_id, sp2.sequence_order, ens2.length
      from apidb.SequencePieceClosure sp2,
           dots.ExternalNaSequence ens2
      where sp2.piece_na_sequence_id = ens2.na_sequence_id) predecessors
 WHERE vs.na_sequence_id = sp.virtual_na_sequence_id
  and ens.na_sequence_id = sp.piece_na_sequence_id
  and vs.na_sequence_id = predecessors.virtual_na_sequence_id(+)
  and sp.sequence_order > predecessors.sequence_order
GROUP by vs.source_id, vs.na_sequence_id, ens.source_id, sp.piece_na_sequence_id, sp.sequence_order,
       ens.length, vs.length, sp.strand_orientation )
ORDER by na_sequence_id, offset, sequence_order)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.DistinctLowerProduct">
    <internalDependency name="apidb.GeneAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.DistinctLowerProduct&1 NOLOGGING AS
select rownum as dlp_id, dlp
from (select distinct lower(product) as dlp
      from apidb.GeneAttributes)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.GeneProduct">
    <internalDependency name="apidb.DistinctLowerProduct"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GeneProduct&1 NOLOGGING AS
select dlp_id, na_feature_id
from apidb.DistinctLowerProduct, dots.GeneFeature
where lower(product) = dlp
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX geneProduct_ix&1 ON apidb.GeneProduct&1(dlp_id, na_feature_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SimilaritySpanLocation">
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.SimilaritySpan"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.SequencePiece"/>
    <sql>
      <![CDATA[
create table apidb.SimilaritySpanLocation&1 NOLOGGING as
select sim.similarity_id, sim.query_id, sim.subject_id, sim.query_table_id,
       sim.subject_table_id, sim.score as similarity_score, sim.min_query_start,
       sim.max_query_end, sim.is_reversed as similarity_is_reversed,
       sim.pvalue_mant, sim.pvalue_exp,
       round(100 * sim.number_identical / sim.total_match_length,1) as percent_identical,
       round(100 * sim.number_positive / sim.total_match_length,1) as percent_positive,
       sim.min_subject_start, sim.max_subject_end, sim.total_match_length,
       simp.similarity_span_id, simp.score as span_score, simp.query_start, simp.query_end,
       simp.subject_start, simp.subject_end,
       simp.is_reversed as span_is_reversed,
       'direct' as location_mapping, 1 as is_top_level
from dots.similarity sim, dots.similarityspan simp, core.TableInfo ti
where sim.similarity_id = simp.similarity_id
  and sim.query_table_id = ti.table_id
  and ti.name = 'ExternalNASequence'
union
select sim.similarity_id, scaffold.na_sequence_id as query_id, sim.subject_id,
       sim.query_table_id,
       sim.subject_table_id, sim.score as similarity_score,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - greatest(sim.min_query_start, sim.max_query_end) + 1
           else least(sim.min_query_start, sim.max_query_end) + sp.distance_from_left
       end as min_query_start,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - least(sim.min_query_start, sim.max_query_end) + 1
           else greatest(sim.min_query_start, sim.max_query_end) + sp.distance_from_left
       end as max_query_end,
       sim.is_reversed, sim.pvalue_mant, sim.pvalue_exp,
       round(100 * sim.number_identical / sim.total_match_length,1) as percent_identical,
       round(100 * sim.number_positive / sim.total_match_length,1) as percent_positive,
       sim.min_subject_start, sim.max_subject_end, sim.total_match_length, 
       simp.similarity_span_id, simp.score as span_score,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - greatest(simp.query_start, simp.query_end) + 1
           else least(simp.query_start, simp.query_end) + sp.distance_from_left
       end as query_start,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - least(simp.query_start, simp.query_end) + 1
           else greatest(simp.query_start, simp.query_end) + sp.distance_from_left
       end as query_end,
       simp.subject_start, simp.subject_end,
       simp.is_reversed as span_is_reversed,
       'virtual' as location_mapping, 1 as is_top_level
from dots.similarity sim, dots.similarityspan simp, core.TableInfo ti,
     dots.NaSequence contig, dots.SequencePiece sp, dots.NaSequence scaffold
where sim.similarity_id = simp.similarity_id
  and sim.query_table_id = ti.table_id
  and ti.name = 'ExternalNASequence'
  and sim.query_id = sp.piece_na_sequence_id
  and sp.piece_na_sequence_id = contig.na_sequence_id
  and sp.virtual_na_sequence_id = scaffold.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
update apidb.SimilaritySpanLocation&1
set is_top_level = 0
where subject_id in (select piece_na_sequence_id from dots.SequencePiece)
      ]]>
    </sql>
    <sql>
      <![CDATA[
update apidb.SimilaritySpanLocation&1
set pvalue_exp = (select min(pvalue_exp) from apidb.SimilaritySpanLocation&1)
where pvalue_mant = 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index apidb.spanloc_query_ix&1
        on apidb.SimilaritySpanLocation&1 (query_id, min_query_start, max_query_end, query_table_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.IsolateSNPs">
    <externalDependency name="dots.NaFeatureImp"/>
    <internalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="apidb.IsolateAttributes"/>
    <internalDependency name="apidb.SnpAttributes"/>
    <sql>
      <![CDATA[
create table apidb.IsolateSNPs&1 NOLOGGING as
select atr.na_sequence_id as is_na_sequence_id,
       atr.source_id as is_source_id,
       isof.allele,
       sa.source_id as snp_source_id,
       sa.dataset as snp_db_name,
       sa.na_sequence_id as snp_na_sequence_id,
       sa.start_min as snp_start_min
from dots.ISOLATEFEATURE isof,  apidb.featurelocation isol, 
     apidb.SNPATTRIBUTES sa, apidb.ISOLATEATTRIBUTES atr
where atr.na_feature_id = isof.parent_id
and isof.na_feature_id = isol.na_feature_id
and sa.na_sequence_id = isol.na_sequence_id
and sa.start_min = isol.start_min
and sa.dataset in ('Pf_plasmoDbCombinedSnps_RSRC','PlasmoDB combined SNPs','Broad SNPs','Pf_Broad_SNPs_RSRC')
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index apidb.isolatesnps_is_sid_idx&1 on apidb.isolatesnps&1 (is_source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index apidb.isolatesnps_snp_db_id_idx&1 on apidb.isolatesnps&1 (snp_db_name,snp_source_id,allele)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index apidb.isolatesnps_snp_id_idx&1 on apidb.isolatesnps&1 (snp_source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index apidb.isnps_snp_sq_strt_idx&1 on apidb.isolatesnps&1 (snp_na_sequence_id,snp_start_min)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SnpsWithIsolates">
    <internalDependency name="apidb.IsolateAttributes"/>
    <internalDependency name="apidb.IsolateSNPs"/>
    <sql>
      <![CDATA[
create table apidb.SnpsWithIsolates&1 NOLOGGING as
select iso_ext_db_name,snp_source_id, 
 apidb.tab_to_string(CAST(COLLECT(CASE WHEN frequency < 0.5 THEN allele END order by allele) AS apidb.varchartab), ', ') as minor_allele,
 apidb.tab_to_string(CAST(COLLECT(CASE WHEN frequency > 0.5 THEN allele END order by allele) AS apidb.varchartab), ', ') as major_allele,
 to_char(min(frequency), '0.99') as minor_allele_frequency,
 min(number_isolates) as number_isolates
from (
 select s.snp_source_id as snp_source_id, s.external_db_name as iso_ext_db_name, s.allele, s.ct/t.tot as frequency, s.ct as allele_count, t.tot as number_isolates
                 from (
                       select ia.external_db_name, isos.snp_source_id,isos.allele,count(*) as ct
                       from apidb.ISOLATESNPS isos,apidb.ISOLATEATTRIBUTES ia
                       where  isos.allele in ('A','C','G','T')
                       and isos.is_source_id = ia.source_id
                       group by ia.external_db_name, isos.snp_source_id,isos.allele
                       ) s,
                       (
                       select ia.external_db_name, isos.snp_source_id, count(*) as tot
                       from apidb.isolatesnps isos,apidb.ISOLATEATTRIBUTES ia
                       where  isos.allele in ('A','C','G','T')
                       and isos.is_source_id = ia.source_id
                       group by ia.external_db_name, isos.snp_source_id
                       ) t
                       where s.snp_source_id = t.snp_source_id
                       and s.external_db_name = t.external_db_name
                       )
                 group by iso_ext_db_name,snp_source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index apidb.snpswiso_id_db_idx&1 on apidb.snpswithisolates&1 (snp_source_id,iso_ext_db_name)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
update SnpsWithIsolates&1 swa
set swa.major_allele = (select max(allele) from apidb.ISOLATEATTRIBUTES ia, apidb.ISOLATESNPS isnp 
                    where isnp.snp_source_id = swa.snp_source_id and ia.EXTERNAL_DB_NAME = swa.iso_ext_db_name
                    group by isnp.snp_source_id,ia.EXTERNAL_DB_NAME),
swa.minor_allele = (select min(allele) from apidb.ISOLATEATTRIBUTES ia, apidb.ISOLATESNPS isnp 
                    where isnp.snp_source_id = swa.snp_source_id and ia.EXTERNAL_DB_NAME = swa.iso_ext_db_name
                    group by isnp.snp_source_id,ia.EXTERNAL_DB_NAME)
where swa.major_allele is null
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.Blastp">
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.ExternalAaSequence"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="core.TableInfo"/>
    <internalDependency name="apidb.GeneAttributes"/>
    <internalDependency name="apidb.TaxonSpecies"/>
    <sql>
      <![CDATA[
create table apidb.Blastp&1 as
select rownum as blastp_id, gf.source_id, ga.project_id, sim.similarity_id,
       subject.source_id as subject_source_id, sim.score score, sim.query_id, 
       sim.min_query_start, sim.max_query_end, sim.pvalue_mant, sim.pvalue_exp,
       sim.number_identical, sim.total_match_length,
       substr(replace(subject.description, chr(1), ''), 1, 300) as description,
       sim.number_positive, ed.name as external_database_name,
       SUBSTR(tn.name, 1, 50) AS query_organism
from dots.Similarity sim, core.TableInfo qti, core.TableInfo sti, dots.ExternalAaSequence subject,
     dots.GeneFeature gf, dots.Transcript t, dots.TranslatedAaFeature taf,
     sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
     dots.NaSequence ns, apidb.TaxonSpecies st, sres.TaxonName tn, apidb.GeneAttributes ga
where qti.table_id = sim.query_table_id
  and qti.name = 'TranslatedAASequence'
  and sti.table_id = sim.subject_table_id
  and sti.name = 'ExternalAASequence'
  and subject.aa_sequence_id = sim.subject_id
  and ga.source_id = gf.source_id
  and gf.na_feature_id = t.parent_id
  and t.na_feature_id = taf.na_feature_id
  and taf.aa_sequence_id = sim.query_id
  and subject.external_database_release_id = edr.external_database_release_id
  and edr.external_database_id = ed.external_database_id
  and gf.na_sequence_id = ns.na_sequence_id
  and ns.taxon_id = st.taxon_id
  and st.species_taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
update apidb.Blastp&1
set pvalue_exp = (select min(pvalue_exp) from apidb.Blastp&1)
where pvalue_mant = 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.blastp_src_ix&1 on apidb.Blastp&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.blastp_query_ix&1 on apidb.Blastp&1 (query_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
drop index apidb.blastp_text_ix
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.blastp_text_ix on apidb.blastp&1(description) indextype is ctxsys.context
             parameters('DATASTORE CTXSYS.DEFAULT_DATASTORE')
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="apidb.GeneIsolateOverlap">
    <internalDependency name="apidb.IsolateAttributes"/>
    <internalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="dots.Similarity"/>
    <sql>
      <![CDATA[
create table apidb.GeneIsolateOverlap&1 as
select substr(ia.source_id, 1, 30) as isolate_source_id,
       fl.feature_source_id as gene_source_id,
       min(pvalue_exp) as min_pvalue_exp
from apidb.IsolateAttributes ia, dots.Similarity sim, apidb.FeatureLocation fl
where fl.feature_type = 'GeneFeature'
  and fl.na_sequence_id = sim.subject_id
  and fl.start_min < sim.max_subject_end
  and fl.end_max > sim.min_subject_start
  and sim.query_id = ia.na_sequence_id
group by ia.source_id, fl.feature_source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.gi_i_ix&1 on apidb.GeneIsolateOverlap&1 (isolate_source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.gi_g_ix&1 on apidb.GeneIsolateOverlap&1 (gene_source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.TableWeight">
    <sql>
      <![CDATA[
create table TableWeight&1 as
-- genes
  select cast ('GoTerms' as varchar2(80)) as table_name, 1 as weight from dual
union
  select cast ('Product' as varchar2(80)) as table_name, 5 as weight from dual
union
  select cast ('Notes' as varchar2(80)) as table_name, 2 as weight from dual
union
  select cast ('Comments' as varchar2(80)) as table_name, 2 as weight from dual
union
  select cast ('InterPro' as varchar2(80)) as table_name, 1 as weight from dual
union
  select cast ('BlastP' as varchar2(80)) as table_name, 1 as weight from dual
union
  select cast ('EcNumber' as varchar2(80)) as table_name, 1 as weight from dual
-- isolates
union
  select cast ('Reference' as varchar2(80)) as table_name, 1 as weight from dual
union
  select cast ('ProteinSequence' as varchar2(80)) as table_name, 1 as weight from dual
union
  select cast ('GeneOverlap' as varchar2(80)) as table_name, 1 as weight from dual
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index apidb.weight_ix&1 on apidb.TableWeight&1(table_name)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.TaxonSpecies">
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <sql>
      <![CDATA[
create table TaxonSpecies&1 as
select t.taxon_id, species.taxon_id as species_taxon_id
from sres.Taxon species, (select distinct ns.taxon_id
      from dots.NaSequence ns, dots.NaFeature nf
      where ns.na_sequence_id = nf.na_sequence_id) t
where species.taxon_id in (select taxon_id from sres.taxon
                           connect by taxon_id = prior parent_id and prior rank != 'species'
                           start with taxon_id = t.taxon_id)
  and species.rank = 'species'
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.Blastx">
    <externalDependency name="dots.ExternalAaSequence"/>
    <externalDependency name="dots.NaSequence"/>
    <internalDependency name="apidb.SimilaritySpanLocation"/>
    <sql>
      <![CDATA[
create table apidb.blastx&1
      (similarity_id, name, score, pvalue, na_sequence_id, startm, end, strand, atts,
       constraint blastx&1_pk primary key(na_sequence_id, startm, pvalue, end, similarity_id))
organization index
nologging
as
select distinct sim.similarity_id,
       extt.source_id name, 
       substr(sim.similarity_score || '', 1, 6) score, 
       to_number(sim.pvalue_mant || 'e' || sim.pvalue_exp) pvalue,
       extq.na_sequence_id,
       sim.min_query_start startm, 
       sim.max_query_end end, 
       decode (sim.similarity_is_reversed, 0, '+1', 1, '-1', '.') strand, 
       substr('Score=' || sim.similarity_score || ';;' || 
              'Expect=' || (sim.pvalue_mant || 'e' ||sim.pvalue_exp)||';;'|| 
              'Defline=' || extt.description || ';;' || 
              'PercentIdentity=' || sim.percent_identical || ';;' ||
              'PercentPositive=' || sim.percent_positive || ';;' ||
              'TStart=' || sim.min_query_start || ';;' || 
              'TStop=' || sim.max_query_end, 1, 400) atts 
from apidb.SimilaritySpanLocation sim, dots.ExternalAaSequence extt, 
     dots.NaSequence extq
where sim.query_id = extq.na_sequence_id
  and sim.subject_id = extt.aa_sequence_id
  and (sim.max_query_end - sim.min_query_start) < 5000
  and sim.pvalue_exp < -10
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.TranscriptSequence">
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.SplicedNaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <internalDependency name="apidb.GeneAttributes"/>
    <sql>
      <![CDATA[
create table apidb.TranscriptSequence&1 nologging as
select gf.source_id, cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       sns.sequence
from apidb.GeneAttributes gf, dots.Transcript t, dots.SplicedNaSequence sns, sres.TaxonName tn
where t.parent_id = gf.na_feature_id
  and sns.na_sequence_id = t.na_sequence_id
  and sns.taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.XScriptSeq_ix&1 on apidb.TranscriptSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.CodingSequence">
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.SplicedNaSequence"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="sres.TaxonName"/>
    <internalDependency name="apidb.GeneAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.CodingSequence&1 NOLOGGING AS
SELECT gf.source_id, cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       SUBSTR(sns.sequence, tf.translation_start,                            
              tf.translation_stop - tf.translation_start + 1) as sequence
FROM apidb.GeneAttributes gf, dots.Transcript t, dots.SplicedNaSequence sns,
     dots.TranslatedAaFeature tf, sres.TaxonName tn
WHERE t.parent_id = gf.na_feature_id
  AND sns.na_sequence_id = t.na_sequence_id
  AND t.na_feature_id = tf.na_feature_id
  AND sns.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.CodSeq_ix&1 on apidb.CodingSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.ProteinSequence">
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="sres.TaxonName"/>
    <internalDependency name="apidb.GeneAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.ProteinSequence&1 NOLOGGING AS
SELECT ga.source_id, cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       tas.sequence
FROM apidb.GeneAttributes ga, dots.Transcript t, dots.TranslatedAaFeature taf,
     dots.TranslatedAaSequence tas, sres.TaxonName tn
WHERE t.parent_id = ga.na_feature_id
  AND t.na_feature_id = taf.na_feature_id
  AND taf.aa_sequence_id = tas.aa_sequence_id
  AND tas.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.ProtSeq_ix&1 on apidb.ProteinSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.NaSequence">
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <internalDependency name="apidb.SequenceAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.NaSequence&1 NOLOGGING AS
SELECT sa.source_id, cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ns.sequence
FROM apidb.SequenceAttributes sa, dots.NaSequence ns, sres.TaxonName tn
WHERE sa.na_sequence_id = ns.na_sequence_id
  AND ns.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.GenomicSeq_ix&1 on apidb.NaSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.OrfSequence">
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.NaFeature"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.OrfSequence&1 NOLOGGING AS
SELECT nf.source_id,
       cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ts.sequence
FROM dots.TranslatedAaSequence ts, dots.TranslatedAaFeature tf,
      dots.NaFeature nf, sres.SequenceOntology so, sres.TaxonName tn
 WHERE nf.na_feature_id = tf.na_feature_id
   AND ts.aa_sequence_id = tf.aa_sequence_id
   AND so.term_name = 'ORF'
   AND nf.sequence_ontology_id = so.sequence_ontology_id
   AND ts.taxon_id = tn.taxon_id
   AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.OrfSeq_ix&1 on apidb.OrfSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.EstSequence">
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.EstSequence&1 NOLOGGING AS
SELECT ens.source_id,
       cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ens.sequence
FROM dots.ExternalNaSequence ens, sres.SequenceOntology so, sres.TaxonName tn
WHERE so.term_name = 'EST'
  AND so.sequence_ontology_id = ens.sequence_ontology_id
  AND ens.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.EstSeq_ix&1 on apidb.EstSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.AssemblySequence">
    <externalDependency name="dots.Assembly"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.AssemblySequence&1 NOLOGGING AS
SELECT a.source_id,
       cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       a.sequence 
FROM dots.Assembly a, sres.TaxonName tn
WHERE a.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.AssemblySeq_ix&1 on apidb.AssemblySequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.IsolateSequence">
    <internalDependency name="apidb.IsolateAttributes"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.IsolateSequence&1 NOLOGGING AS
SELECT ia.source_id,
       cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ns.sequence
FROM apidb.IsolateAttributes ia, dots.NaSequence ns, sres.TaxonName tn
WHERE ia.na_sequence_id = ns.na_sequence_id
  AND ns.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.IsolateSeq_ix&1 on apidb.IsolateSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.GeneContextSyntenicGenes">
    <!-- "SyntenicGeneCache" might be a better name.  This table is used along
         with SyntenicExonCache to speed up the gbrowse queries "gene:syntenyMC"
         and "gene:syntenyMC:bulksubfeatures", respectively.  -->
    <internalDependency name="apidb.GeneAttributes"/>
    <internalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="apidb.Synteny"/>
    <externalDependency name="apidb.SyntenyAnchor"/>
    <sql>
      <![CDATA[
create table apidb.GeneContextSyntenicGenes&1
--      (organism, na_sequence_id, context_start, context_end, context_source_id, project_id, syntenic_na_feature_id, syntenic_source_id, synteny_id, startm, end, strand, is_truncated, atts
--      )
--partition by list (organism)
--  (
--   partition Chominis values ('Cryptosporidium hominis'),
--   partition Cmuris values ('Cryptosporidium muris'),
--   partition Cparvum values ('Cryptosporidium parvum'),
--   partition Cparvum_Iowa values ('Cryptosporidium parvum Iowa II'),
--   partition Gintestinalis values ('Giardia intestinalis ATCC 50581'),
--   partition Glamblia values ('Giardia lamblia ATCC 50803'),
--   partition GlambliaP15 values ('Giardia lamblia P15'),
--   partition Lbraziliensis values ('Leishmania braziliensis'),
--   partition Linfantum values ('Leishmania infantum'),
--   partition Lmajor values ('Leishmania major'),
--   partition Ncaninum values ('Neospora caninum'),
--   partition Pberghei values ('Plasmodium berghei str. ANKA'),
--   partition Pchabaudi values ('Plasmodium chabaudi chabaudi'),
--   partition Pfalciparum values ('Plasmodium falciparum 3D7'),
--   partition Pknowlesi values ('Plasmodium knowlesi strain H'),
--   partition Pvivax values ('Plasmodium vivax SaI-1'),
--   partition Pyoelii values ('Plasmodium yoelii yoelii str. 17XNL'),
--   partition TgondiiGT1 values ('Toxoplasma gondii GT1'),
--   partition TgondiiME49 values ('Toxoplasma gondii ME49'),
--   partition TgondiiRH values ('Toxoplasma gondii RH'),
--   partition TgondiiVEG values ('Toxoplasma gondii VEG'),
--   partition Tvaginalis values ('Trichomonas vaginalis G3'),
--   partition Tbrucei values ('Trypanosoma brucei TREU927'),
--   partition Tcruzi values ('Trypanosoma cruzi strain CL Brener'),
--   partition others values (default)
--  )
nologging
as
select  /*+ ordered no_expand use_nl(syn syn_fl) use_nl(syn_fl syntenic_gene_attrs) */
       syntenic_gene_attrs.organism, context_gene_attrs.na_sequence_id,
       context_gene_attrs.context_start, context_gene_attrs.context_end,
       context_gene_attrs.source_id as context_source_id,
       context_gene_attrs.project_id,
       syntenic_gene_attrs.na_feature_id syntenic_na_feature_id,
       syntenic_gene_attrs.source_id as syntenic_source_id,
       anch_left.synteny_id synteny_id,
       CASE WHEN (syn.is_reversed = 1) 
            THEN anch_left.ref_loc - ((anch_left.syntenic_loc
                                       - (CASE WHEN syn_fl.end_max > syn.b_end
                                               THEN syn.b_end ELSE syn_fl.end_max
                                          END))
                                      * (anch_right.ref_loc - anch_left.ref_loc + 1)
                                      / (anch_right.syntenic_loc - anch_left.syntenic_loc - 1))
            ELSE anch_left.ref_loc
                 + (((CASE WHEN syn_fl.start_min < syn.b_start
                           THEN syn.b_start
                           ELSE syn_fl.start_min
                      END) - anch_left.syntenic_loc)
                    * (anch_right.ref_loc - anch_left.ref_loc + 1)
                    / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))
            END startm,
       CASE WHEN (syn.is_reversed = 1)
            THEN anch_left.ref_loc
                 - ((anch_left.syntenic_loc
                     - (CASE WHEN syn_fl.start_min < syn.b_start
                             THEN syn.b_start
                             ELSE syn_fl.start_min
                        END)) * (anch_right.ref_loc - anch_left.ref_loc + 1)
                              / (anch_right.syntenic_loc - anch_left.syntenic_loc - 1))
            ELSE anch_left.ref_loc + (((CASE WHEN syn_fl.end_max > syn.b_end
                                             THEN syn.b_end
                                             ELSE syn_fl.end_max
                                             END) - anch_left.syntenic_loc)
                                                  * (anch_right.ref_loc - anch_left.ref_loc + 1)
                                                  / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))
            END end,
       CASE WHEN (syn_fl.is_reversed = syn.is_reversed)
            THEN 1
            ELSE -1
            END strand,
       CASE WHEN syn_fl.end_max > syn.b_end THEN syn.b_end 
            WHEN syn_fl.start_min < syn.b_start THEN syn.b_start 
       END is_truncated,
       substr('Note=' || syntenic_gene_attrs.product ||
              decode(syntenic_gene_attrs.is_deprecated,1,' (deprecated)') || ';;' ||
              'SOTerm=' || syntenic_gene_attrs.so_term_name || ';;' ||
              'SyntenyID=' || syn.synteny_id || ';;' ||
              'Contig=' || syntenic_gene_attrs.sequence_id || ';;' ||
              'IsPseudo=' || syntenic_gene_attrs.is_pseudo || ';;' ||
              'isDeprecated=' || syntenic_gene_attrs.is_deprecated || ';;' ||
              'Start=' || syntenic_gene_attrs.start_min || ';;' ||
              'End=' || syntenic_gene_attrs.end_max || ';;' ||
              'isReversed=' || syntenic_gene_attrs.is_reversed || ';;' ||
              'Truncated=' || CASE WHEN syn_fl.end_max > syn.b_end THEN syn.b_end 
                                  WHEN syn_fl.start_min < syn.b_start THEN syn.b_start 
                                  END || ';;' ||
              'Taxon=' || syntenic_gene_attrs.organism, 1, 400) atts
FROM apidb.Synteny syn, apidb.GeneAttributes context_gene_attrs,
     apidb.SyntenyAnchor anch_left, apidb.SyntenyAnchor anch_right,
     apidb.FeatureLocation syn_fl, apidb.GeneAttributes syntenic_gene_attrs
WHERE syn.a_na_sequence_id = context_gene_attrs.na_sequence_id
  AND syn.a_start <= context_gene_attrs.context_end
  AND syn.a_end >= context_gene_attrs.context_start 
  AND anch_left.synteny_id = syn.synteny_id 
  AND anch_left.prev_ref_loc < context_gene_attrs.context_start 
  AND anch_left.ref_loc >= context_gene_attrs.context_start
  AND anch_right.synteny_id = syn.synteny_id
  AND anch_left.ref_loc !=  anch_right.ref_loc
  AND anch_right.ref_loc < context_gene_attrs.context_end
  AND anch_right.next_ref_loc >= context_gene_attrs.context_end
  AND syn_fl.na_sequence_id = syn.b_na_sequence_id 
  AND syn_fl.feature_type = 'GeneFeature'
  AND syntenic_gene_attrs.na_feature_id = syn_fl.na_feature_id
  AND (
       (syn.is_reversed = 0
        AND abs(anch_right.syntenic_loc - anch_left.syntenic_loc + 1) > 0
        AND anch_left.ref_loc
            + ((syn_fl.start_min - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1)
               / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))
            <= context_gene_attrs.context_end 
        AND anch_left.ref_loc
            + ((syn_fl.end_max - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1)
               / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))
            >= context_gene_attrs.context_start) 
      OR
       (syn.is_reversed = 1 
        AND abs(anch_left.syntenic_loc - anch_right.syntenic_loc - 1) > 0
        AND anch_left.ref_loc
            + ((anch_left.syntenic_loc - syn_fl.end_max) * (anch_right.ref_loc - anch_left.ref_loc + 1)
               / (anch_left.syntenic_loc - anch_right.syntenic_loc - 1))
            <= context_gene_attrs.context_end 
        AND anch_left.ref_loc
            + ((anch_left.syntenic_loc - syn_fl.start_min) * (anch_right.ref_loc - anch_left.ref_loc + 1)
               / (anch_left.syntenic_loc - anch_right.syntenic_loc - 1))
            >= context_gene_attrs.context_start) )
  AND syn_fl.start_min <= syn.b_end
  AND syn_fl.end_max >= syn.b_start
      ]]> 
    </sql>
    <sql>
      <![CDATA[
insert into apidb.GeneContextSyntenicGenes&1 (na_sequence_id, context_start, context_end, context_source_id, organism, syntenic_na_feature_id)
select na_sequence_id, context_start, context_end, source_id,  'placeholder', -1
from apidb.GeneAttributes
where source_id in (select source_id from apidb.GeneAttributes minus select context_source_id from apidb.GeneContextSyntenicGenes&1)
      ]]> 
    </sql>
    <sql>
      <![CDATA[
create index apidb.gcsg_ix&1
        on apidb.GeneContextSyntenicGenes&1 (na_sequence_id, context_start, context_end, organism)
      ]]> 
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SyntenicExonCache">
    <!-- used by the gbrowse query "gene:syntenyMC:bulksubfeatures" -->
    <internalDependency name="apidb.GeneAttributes"/>
    <internalDependency name="apidb.FeatureLocation"/>
    <!-- externalDependency name="apidb.Synteny"/ -->
    <!-- externalDependency name="apidb.SyntenyAnchor"/ -->
    <sql>
      <![CDATA[
create table SyntenicExonCache&1
--            (organism, na_sequence_id, feature_id, context_start, context_end,
--             context_source_id, project_id, syntenic_na_feature_id,
--             syntenic_exon_feature_id, syntenic_gene_feature_id, startm, end,
--             strand, atts
--            )
--partition by list (organism)
--  (
--   partition Chominis values ('Cryptosporidium hominis'),
--   partition Cmuris values ('Cryptosporidium muris'),
--   partition Cparvum values ('Cryptosporidium parvum'),
--   partition Cparvum_Iowa values ('Cryptosporidium parvum Iowa II'),
--   partition Gintestinalis values ('Giardia intestinalis ATCC 50581'),
--   partition Glamblia values ('Giardia lamblia ATCC 50803'),
--   partition GlambliaP15 values ('Giardia lamblia P15'),
--   partition Lbraziliensis values ('Leishmania braziliensis'),
--   partition Linfantum values ('Leishmania infantum'),
--   partition Lmajor values ('Leishmania major'),
--   partition Ncaninum values ('Neospora caninum'),
--   partition Pberghei values ('Plasmodium berghei str. ANKA'),
--   partition Pchabaudi values ('Plasmodium chabaudi chabaudi'),
--   partition Pfalciparum values ('Plasmodium falciparum 3D7'),
--   partition Pknowlesi values ('Plasmodium knowlesi strain H'),
--   partition Pvivax values ('Plasmodium vivax SaI-1'),
--   partition Pyoelii values ('Plasmodium yoelii yoelii str. 17XNL'),
--   partition TgondiiGT1 values ('Toxoplasma gondii GT1'),
--   partition TgondiiME49 values ('Toxoplasma gondii ME49'),
--   partition TgondiiRH values ('Toxoplasma gondii RH'),
--   partition TgondiiVEG values ('Toxoplasma gondii VEG'),
--   partition Tvaginalis values ('Trichomonas vaginalis G3'),
--   partition Tbrucei values ('Trypanosoma brucei TREU927'),
--   partition Tcruzi values ('Trypanosoma cruzi strain CL Brener'),
--   partition others values (default)
--  )
nologging
as
SELECT /*+ ordered no_expand use_hash(syn exfloc) use_hash(exfloc syntenic_gene_attrs) */
       syntenic_gene_attrs.organism, context_gene_attrs.na_sequence_id,
       exfloc.na_feature_id feature_id,
       context_gene_attrs.context_start, context_gene_attrs.context_end,
       context_gene_attrs.source_id as context_source_Id,
       context_gene_attrs.project_id,
       syntenic_gene_attrs.na_feature_id syntenic_na_feature_id,
       exfloc.na_feature_id as syntenic_exon_feature_id,
       exfloc.parent_id as syntenic_gene_feature_id,
       CASE WHEN (syn.is_reversed = 1) 
            THEN anch_left.ref_loc
                 - ((anch_left.syntenic_loc
                     - (CASE WHEN exfloc.end_max > syn.b_end
                             THEN syn.b_end
                             ELSE exfloc.end_max
                        END))
                    * (anch_right.ref_loc - anch_left.ref_loc + 1)
                    / (anch_right.syntenic_loc - anch_left.syntenic_loc - 1))
            ELSE anch_left.ref_loc
                 + (((CASE WHEN exfloc.start_min < syn.b_start
                           THEN syn.b_start
                           ELSE exfloc.start_min
                      END) - anch_left.syntenic_loc)
                    * (anch_right.ref_loc - anch_left.ref_loc + 1)
                    / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))
            END startm,
       CASE WHEN (syn.is_reversed = 1) 
            THEN anch_left.ref_loc
                 - ((anch_left.syntenic_loc
                     - (CASE WHEN exfloc.start_min < syn.b_start
                             THEN syn.b_start
                             ELSE exfloc.start_min
                        END))
                    * (anch_right.ref_loc - anch_left.ref_loc + 1)
                    / (anch_right.syntenic_loc - anch_left.syntenic_loc - 1))
            ELSE anch_left.ref_loc
                 + (((CASE WHEN exfloc.end_max > syn.b_end
                           THEN syn.b_end
                           ELSE exfloc.end_max
                      END) - anch_left.syntenic_loc)
                    * (anch_right.ref_loc - anch_left.ref_loc + 1)
                    / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))
            END end,
       CASE WHEN (exfloc.is_reversed = syn.is_reversed) THEN 1 ELSE -1 END strand,
       'isDeprecated=' ||  syntenic_gene_attrs.is_deprecated atts 
FROM
     apidb.synteny syn, apidb.geneattributes context_gene_attrs,
     apidb.syntenyAnchor anch_left, apidb.syntenyAnchor anch_right,
     apidb.featurelocation exfloc, apidb.geneattributes syntenic_gene_attrs
WHERE syntenic_gene_attrs.na_feature_id = exfloc.parent_id
  AND syn.a_na_sequence_id = context_gene_attrs.na_sequence_id
  AND syn.a_start <= context_gene_attrs.context_end 
  AND syn.a_end >= context_gene_attrs.context_start 
  AND anch_left.synteny_id = syn.synteny_id 
  AND anch_left.prev_ref_loc < context_gene_attrs.context_start
  AND anch_left.ref_loc >= context_gene_attrs.context_start
  AND anch_right.synteny_id = syn.synteny_id
  AND anch_right.ref_loc < context_gene_attrs.context_end
  AND anch_right.next_ref_loc >= context_gene_attrs.context_end
  AND anch_left.ref_loc !=  anch_right.ref_loc
  AND exfloc.feature_type = 'ExonFeature'
  AND exfloc.na_sequence_id = syn.b_na_sequence_id 
  AND (
       (syn.is_reversed = 0
        AND abs(anch_right.syntenic_loc - anch_left.syntenic_loc + 1) > 0
        AND anch_left.ref_loc
            + ((exfloc.start_min - anch_left.syntenic_loc)
               * (anch_right.ref_loc - anch_left.ref_loc + 1)
               / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))
            <= context_gene_attrs.context_end 
        AND anch_left.ref_loc
            + ((exfloc.end_max - anch_left.syntenic_loc)
               * (anch_right.ref_loc - anch_left.ref_loc + 1)
               / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))
            >= context_gene_attrs.context_start
       ) 
       OR
       (syn.is_reversed = 1 
        AND abs(anch_right.syntenic_loc - anch_left.syntenic_loc - 1) > 0
        AND anch_left.ref_loc
            - ((anch_left.syntenic_loc - exfloc.end_max)
               * (anch_right.ref_loc - anch_left.ref_loc + 1)
               / (anch_right.syntenic_loc - anch_left.syntenic_loc - 1))
            <= context_gene_attrs.context_end 
        AND anch_left.ref_loc
            - ((anch_left.syntenic_loc - exfloc.start_min)
               * (anch_right.ref_loc - anch_left.ref_loc + 1)
               / (anch_right.syntenic_loc - anch_left.syntenic_loc - 1))
            >= context_gene_attrs.context_start
        )
  )
  AND exfloc.start_min <= syn.b_end
  AND exfloc.end_max >= syn.b_start
      ]]> 
    </sql>
    <sql>
      <![CDATA[
insert into apidb.SyntenicExonCache&1 (na_sequence_id, context_start, context_end, context_source_id, organism, syntenic_na_feature_id)
select na_sequence_id, context_start, context_end, source_id,  'placeholder', -1
from apidb.GeneAttributes
where source_id in (select source_id from apidb.GeneAttributes minus select context_source_id from apidb.SyntenicExonCache&1)
      ]]> 
    </sql>
    <sql>
      <![CDATA[
create index apidb.sec_ix&1
        on apidb.SyntenicExonCache&1 (na_sequence_id, context_start, context_end, organism)
      ]]> 
    </sql>
  </tuningTable>

  <tuningTable name="apidb.TypeAheadCounts">
    <internalDependency name="apidb.GeneAttributes"/>
    <externalDependency name="dots.DbRefAaFeature"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="dots.AaFeature"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.EnzymeClass"/>
    <externalDependency name="dots.AaSequenceEnzymeClass"/>
    <externalDependency name="dots.GoAssociation"/>
    <externalDependency name="sres.GoTerm"/>
    <externalDependency name="sres.GoRelationship"/>
    <externalDependency name="sres.GoRelationshipType"/>
    <externalDependency name="core.TableInfo"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.TypeAheadCounts&1 NOLOGGING AS
   (SELECT DISTINCT dr.primary_identifier as option_id,
                   count(distinct aaf.aa_sequence_id) AS gene_count,
                   gf.project_id
   FROM dots.DbRefAaFeature draf, sres.DbRef dr, dots.aafeature aaf,
        sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
        dots.TranslatedAAFeature taf,apidb.geneattributes gf, dots.transcript t
   WHERE draf.db_ref_id = dr.db_ref_id
   AND dr.external_database_release_id
       = edr.external_database_release_id
   AND edr.external_database_id = ed.external_database_id
   AND aaf.aa_feature_id = draf.aa_feature_id
   AND aaf.aa_sequence_id = taf.aa_sequence_id
   AND taf.na_feature_id = t.na_feature_id
   AND gf.na_feature_id = t.parent_id
   GROUP BY gf.project_id,
            dr.primary_identifier)
   UNION
   (SELECT DISTINCT ec.ec_number AS option_id,
          COUNT(DISTINCT aaf.aa_sequence_id) AS gene_count,
          gf.project_id
   FROM sres.enzymeClass ec, apidb.GeneAttributes gf,
        dots.aaSequenceEnzymeClass asec,
        dots.translatedAaFeature taf,
        dots.aafeature aaf, dots.transcript t
   WHERE gf.na_feature_id = t.parent_id
   AND t.na_feature_id = taf.na_feature_id
   AND taf.aa_sequence_id = asec.aa_sequence_id
   AND aaf.aa_sequence_id = taf.aa_sequence_id
   AND asec.enzyme_class_id = ec.enzyme_class_id
   GROUP BY gf.project_id,
            ec.ec_number)
   UNION                
   (SELECT DISTINCT gp.go_id AS option_id,
           COUNT(DISTINCT aaf.aa_sequence_id) AS gene_count,
           gf.project_id
    FROM apidb.geneAttributes gf, dots.Transcript t,
         dots.TranslatedAaFeature taf, dots.AaFeature aaf,
         dots.GoAssociation ga, sres.GoTerm gp,
         sres.GoRelationship gr, core.TableInfo ti,
         sres.GoRelationshipType grt
    WHERE gf.na_feature_id = t.parent_id
    AND t.na_feature_id = taf.na_feature_id
    AND taf.aa_sequence_id = ga.row_id
    AND aaf.aa_sequence_id = taf.aa_sequence_id
    AND ga.table_id = ti.table_id
    AND ti.name = 'TranslatedAASequence'
    AND ga.go_term_id = gr.child_term_id
    AND gr.parent_term_id = gp.go_term_id
    AND gr.go_relationship_type_id = grt.go_relationship_type_id
    AND grt.name = 'closure'
    GROUP BY gf.project_id,
             gp.go_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.TypeAheadCounts_idx&1 ON apidb.TypeAheadCounts&1 (option_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.ExpressionElement">
    <internalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="rad.DataTransformationResult"/>
    <sql>
      <![CDATA[
      create table apidb.ExpressionElement&1 nologging as
      select fl.na_feature_id, fl.na_sequence_id, fl.start_min, fl.end_max,
             fl.feature_source_id, dtr.analysis_id, dtr.float_value as score
      from rad.DataTransformationResult dtr, apidb.FeatureLocation fl
      where dtr.row_id = fl.na_feature_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index apidb.ee_track_ix&1
      on apidb.ExpressionElement&1 (na_sequence_id, analysis_id, start_min, end_max, na_feature_id, score)
      tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.OrthologousPair">
    <!-- each record contains a pair of genes that are orthologous to each other -->
    <internalDependency name="apidb.GeneAttributes"/>
    <sql>
      <![CDATA[
       create table apidb.OrthologousPair&1 nologging as
       select /*+ ordered_predicates */
              ga2.source_id AS ortho_source_id, ga2.na_sequence_id as ortho_na_sequence_id, ga2.start_min as ortho_start_min,
              case when ga1.project_id = 'GiardiaDB' then ga2.species
              else ga2.organism end as organism, 
              ga2.product, ga1.source_id, ga1.project_id, ga1.na_sequence_id, ga1.start_min,
              nvl(comments.comment_count, 'no') as comment_count
             from apidb.geneattributes ga1, apidb.geneattributes ga2,
                  (select distinct 'yes' as comment_count, stable_id as source_id, project_name
                   from comments2.comments@apidb.login_comment
                   where comment_target_id = 'gene'
                     and review_status_id != 'rejected'
                     and is_visible = 1) comments
             where ga2.source_id = comments.source_id(+)
               and ga2.project_id = ga1.project_id
               and ga1.orthomcl_name = ga2.orthomcl_name
               and ga2.source_id != ga1.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index apidb.orth_ix&1
      on apidb.OrthologousPair&1 (source_id, project_id)
      tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.OrthologGeneTable">
    <!-- each record contains a record from OrthologousPair, augmented by the IS_SYNTENIC column -->
    <internalDependency name="apidb.OrthologousPair"/>
    <externalDependency name="apidb.Synteny"/>
    <sql>
      <![CDATA[
      create table apidb.OrthologGeneTable&1 nologging as
      select
       op.ortho_source_id,
       op.organism,
       op.product, op.source_id,
       nvl(synteny.is_syntenic, 'no') as is_syntenic,
       op.comment_count,
       op.project_id
      from apidb.OrthologousPair op,
       (select distinct
               'yes' as is_syntenic,
               a_na_sequence_id, b_na_sequence_id, a_start, a_end, b_start, b_end
        from apidb.synteny s) synteny
        where synteny.a_na_sequence_id(+) = op.na_sequence_id
          AND synteny.b_na_sequence_id(+) = op.ortho_na_sequence_id
          AND synteny.a_start(+) <= op.start_min
          AND synteny.a_end(+) >= op.start_min
          AND synteny.b_start(+) <= op.ortho_start_min
          AND synteny.b_end(+) >= op.ortho_start_min
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index apidb.ogt_ix&1
      on apidb.OrthologGeneTable&1 (source_id, project_id)
      tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.NextGenSeqStats">
    <externalDependency name="apidb.NextGenSeqCoverage"/>
    <sql>
      <![CDATA[
      create table apidb.NextGenSeqStats&1 nologging as
      select sample, sum_coverage / sum_span_length as average_coverage, sum_coverage, sum_span_length / num_spans as average_span_length,sum_span_length 
      from (select sample,count(*) as num_spans,
                   sum(coverage * (mapping_end - mapping_start)) as sum_coverage,
                   sum(mapping_end - mapping_start) as sum_span_length
            from apidb.NextGenSeqCoverage
            where multiple = 0
            group by sample)
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index apidb.ngss_sple_idx&1
      on apidb.NextGenSeqStats&1 (sample)
      tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SnpCombined">
    <externalDependency name="dots.SeqVariation"/>
    <internalDependency name="apidb.SnpAttributes"/>
    <sql>
      <![CDATA[
       create table apidb.SnpCombined&1
              (na_sequence_id, dataset, start_min, strain, na_feature_id, allele, phenotype, product,
               constraint SeqVar&1_pk primary key (na_sequence_id, dataset, start_min, strain, na_feature_id, allele, phenotype, product))
       nologging
       as
       select sa.na_sequence_id, sa.dataset, sa.start_min,
              substr(var.strain, 1, 20) as strain, sa.na_feature_id,
              substr(var.allele, 1, 40) as allele,
              substr(var.phenotype, 1, 20) as phenotype, nvl(substr(var.product, 1, 20), ' ') as product
       FROM apidb.SnpAttributes sa,
            dots.SeqVariation var
       WHERE var.parent_id = sa.na_feature_id
         and sa.dataset = 'Pf_plasmoDbCombinedSnps_RSRC'
      ]]>
    </sql>
  </tuningTable>

</tuningConfig>
