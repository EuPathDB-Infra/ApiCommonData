<tuningConfig>

  <tuningTable name="apidb.GeneAlias">
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.NaFeatureNaGene"/>
    <externalDependency name="dots.NaGene"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GeneAlias&1 NOLOGGING AS
SELECT DISTINCT pairs.alias, pairs.gene FROM
( -- NaGene / NaFeatureNaGene
  SELECT ng.name AS alias, gf.source_id AS gene
  FROM dots.GeneFeature gf, dots.NaFeatureNaGene nfng, dots.NaGene ng
  WHERE gf.na_feature_id = nfng.na_feature_id
    AND ng.na_gene_id = nfng.na_gene_id
 UNION -- lower() of NaGene / NaFeatureNaGene (really all we need)
  SELECT LOWER(ng.name) AS alias, gf.source_id AS gene
  FROM dots.GeneFeature gf, dots.NaFeatureNaGene nfng, dots.NaGene ng
  WHERE gf.na_feature_id = nfng.na_feature_id
    AND ng.na_gene_id = nfng.na_gene_id
 UNION -- source id is its own alias
  SELECT source_id AS alias, source_id AS gene
  FROM dots.GeneFeature
 UNION -- lower(source_id) is alias for source_id
  SELECT lower(source_id) AS alias, source_id AS gene
  FROM dots.GeneFeature
 UNION -- changed P. vivax source IDs
  SELECT dr.primary_identifier as alias, gf.source_id as gene
  FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
       sres.DbRef dr, sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase ed
  WHERE dr.primary_identifier IS NOT NULL
    AND gf.na_feature_id = drnf.na_feature_id
    AND drnf.db_ref_id = dr.db_ref_id
    AND dr.external_database_release_id
          = edr.external_database_release_id
    AND edr.external_database_id = ed.external_database_id
    AND ed.name = 'P.vivax Genbank source_Id DBRefs') pairs,
       dots.GeneFeature gf, sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase ed
 WHERE pairs.gene = gf.source_id
   AND gf.external_database_release_id = edr.external_database_release_id
   AND edr.external_database_id = ed.external_database_id
   AND ed.name NOT IN ('GLEAN predictions', 'GlimmerHMM predictions',
                       'TigrScan', 'TwinScan predictions',
                       'TwinScanEt predictions', 'P. falciparum Evigan Gene Models',
                       'Pfalciparum workshop annotations reviewed and changed',
                       'Sanger P. falciparum old annotations',
                       'Old annotation for ME49')
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneAlias_gene_idx&1 ON apidb.GeneAlias&1 (gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneAlias_alias_idx&1 ON apidb.GeneAlias&1 (alias)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SequenceAlias">
    <externalDependency name="dots.NaSequenceImp"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.SequenceAlias&1 NOLOGGING AS
SELECT ens.source_id, LOWER(ens.source_id) AS lowercase_source_id
FROM dots.ExternalNaSequence ens
UNION
SELECT ens.source_id, LOWER(ens.source_id) AS lowercase_source_id
FROM dots.VirtualSequence ens
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SequenceAlias_idx&1 ON apidb.SequenceAlias&1(lowercase_source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.GoTermSummary">
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.AaFeatureImp"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.GoAssociation"/>
    <externalDependency name="dots.GoAssociationInstance"/>
    <externalDependency name="dots.GoAssociationInstanceLoe"/>
    <externalDependency name="dots.GoAssocInstEvidCode"/>
    <externalDependency name="sres.GoEvidenceCode"/>
    <externalDependency name="sres.GoRelationship"/>
    <externalDependency name="sres.GoTerm"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GoTermSummary&1 NOLOGGING AS
SELECT gf.source_id,
       decode(ga.is_not, 0, '', 1, 'not', ga.is_not) as is_not,
                 gt.go_id, o.ontology, gt.name AS go_term_name,
                  gail.name AS source, gec.name as evidence_code
FROM dots.GeneFeature gf, dots.Transcript t,
     dots.TranslatedAaFeature taf, dots.GoAssociation ga,
     sres.GoTerm gt, dots.GoAssociationInstance gai,
     dots.GoAssociationInstanceLoe gail,
     dots.GoAssocInstEvidCode gaiec, sres.GoEvidenceCode gec,
     (SELECT gr.child_term_id AS go_term_id,
             DECODE(gp.name, 'biological_process', 'Biological Process',
                             'molecular_function', 'Molecular Function',
                             'cellular_component', 'Cellular Component',
                              gp.name)
             AS ontology
      FROM sres.GoRelationship gr, sres.GoTerm gp
      WHERE gr.parent_term_id = gp.go_term_id
        AND gp.go_id in ('GO:0008150','GO:0003674','GO:0005575')) o
WHERE gf.na_feature_id = t.parent_id
  AND t.na_feature_id = taf.na_feature_id
  AND taf.aa_sequence_id = ga.row_id
  AND ga.table_id = (SELECT table_id
                     FROM core.TableInfo
                     WHERE name = 'TranslatedAASequence')
  AND ga.go_term_id = gt.go_term_id
  AND ga.go_association_id = gai.go_association_id
  AND gai.go_assoc_inst_loe_id = gail.go_assoc_inst_loe_id
  AND gai.go_association_instance_id
      = gaiec.go_association_instance_id
  AND gaiec.go_evidence_code_id = gec.go_evidence_code_id
  AND gt.go_term_id = o.go_term_id(+)
ORDER BY o.ontology, gt.go_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GoTermSum_sourceId_idx&1 ON apidb.GoTermSummary&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.PdbSimilarity">
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.AaFeatureImp"/>
    <externalDependency name="dots.AaSequenceImp"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.PdbSimilarity&1 NOLOGGING AS
SELECT gf.source_id, eas.source_id AS pdb_chain, eas.description AS pdb_title,
       substr(eas.source_id, 1,
              instr(eas.source_id, '_', -1) - 1)
         AS pdb_id,
       s.pvalue_mant, s.pvalue_exp, 
       SUBSTR(tn.name, 1, 40) AS taxon,
       ROUND( (s.number_identical / s.total_match_length) * 100)
         AS percent_identity,
       ROUND( (s.total_match_length / tas.length) * 100)
         AS percent_plasmo_coverage,
       s.score
FROM dots.TranslatedAaFeature taf,
     dots.TranslatedAaSequence tas, core.TableInfo tas_ti,
     dots.Similarity s, core.TableInfo eas_ti,
     dots.ExternalAaSequence eas,
     sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
     sres.TaxonName tn, dots.Transcript t, dots.GeneFeature gf
WHERE taf.aa_sequence_id = tas.aa_sequence_id
  AND tas_ti.name = 'TranslatedAASequence'
  AND tas_ti.table_id = s.query_table_id
  AND s.query_id = tas.aa_sequence_id
  AND eas_ti.name = 'ExternalAASequence'
  AND eas_ti.table_id = s.subject_table_id
  AND s.subject_id = eas.aa_sequence_id
  AND tn.name_class = 'scientific name'
  AND eas.external_database_release_id
      = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ed.name = 'PDB protein sequences'
  AND eas.taxon_id = tn.taxon_id
  AND t.na_feature_id = taf.na_feature_id
  AND gf.na_feature_id = t.parent_id
ORDER BY taf.source_id, eas.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.PdbSim_sourceId_ix&1
ON apidb.PdbSimilarity&1 (source_id, score DESC)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SequencePieceClosure">
    <externalDependency name="dots.SequencePiece"/>
    <sql>
      <![CDATA[
        create table apidb.SequencePieceClosure&1 nologging as
        select sp.*, 1 as edge_level from dots.SequencePiece sp
      ]]>
    </sql>
    <sql>
      <![CDATA[
        /* known issue: this should be run not just once, but iteratively
           until it doesn't create new records.  Currently (7/2008),
           SequencePieces aren't nested even once. */
        insert into apidb.SequencePieceClosure&1
                    (edge_level, virtual_na_sequence_id, piece_na_sequence_id,
                     distance_from_left, strand_orientation, modification_date)
        select 2, higher.virtual_na_sequence_id, lower.piece_na_sequence_id,
               higher.distance_from_left
               + case
                   when nvl(higher.strand_orientation, '+') = '+'
                   then lower.distance_from_left
                   else higher_piece.length - lower_piece.length - lower.distance_from_left
                 end as distance_from_left,
               case
                 when nvl(higher.strand_orientation, '+') = nvl(lower.strand_orientation, '+')
                 then '+'
                 else '-'
               end as strand_orientation,
               sysdate
        from apidb.SequencePieceClosure&1 higher, apidb.SequencePieceClosure&1 lower,
             dots.NaSequence higher_piece, dots.NaSequence lower_piece
        where higher.piece_na_sequence_id = lower.virtual_na_sequence_id
          and higher.piece_na_sequence_id = higher_piece.na_sequence_id
          and lower.piece_na_sequence_id = lower_piece.na_sequence_id
          and (higher.virtual_na_sequence_id, lower.piece_na_sequence_id)
              not in (select virtual_na_sequence_id, piece_na_sequence_id
                      from apidb.SequencePieceClosure&1)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.FeatureLocation">
    <internalDependency name="apidb.SequencePieceClosure"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.NaLocation"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
create table apidb.FeatureLocation&1 NOLOGGING as
select case
         when nf.subclass_view = 'GeneFeature'
              and db.name in ('GLEAN predictions', 'GlimmerHMM predictions',
                              'TigrScan', 'TwinScan predictions',
                              'TwinScanEt predictions', -- not 'tRNAscan-SE',
                              'P. falciparum Evigan Gene Models',
                              'Pfalciparum workshop annotations reviewed and changed',
                              'Sanger P. falciparum old annotations',
                              'Old annotation for ME49')
           then 'GenePrediction'
         else nf.subclass_view
       end as feature_type,
       nf.source_id as feature_source_id, ns.source_id as sequence_source_id,
       nf.na_sequence_id, nf.na_feature_id,
       least(nl.start_min, nl.start_max, nl.end_min, nl.end_max) as start_min,
       greatest(nl.start_min, nl.start_max, nl.end_min, nl.end_max) as end_max,
       nl.is_reversed, nf.parent_id, nf.sequence_ontology_id,
       cast (null as number) as is_top_level, ef.coding_start, ef.coding_end,
       nf.external_database_release_id
from dots.NaFeature nf, dots.NaLocation nl, dots.NaSequence ns,
     dots.ExonFeature ef,
     (select edr.external_database_release_id, ed.name
      from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      where edr.external_database_id = ed.external_database_id) db
where nf.na_feature_id = nl.na_feature_id
  and nf.external_database_release_id = db.external_database_release_id(+)
  and nf.na_sequence_id = ns.na_sequence_id
  and nl.na_feature_id = ef.na_feature_id(+)
union
select -- virtual feature locations mapped through SequencePiece
       case
         when nf.subclass_view = 'GeneFeature'
              and  db.name in ('GLEAN predictions', 'GlimmerHMM predictions',
                          'TigrScan', 'TwinScan predictions',
                          'TwinScanEt predictions', -- not 'tRNAscan-SE',
                          'P. falciparum Evigan Gene Models',
                          'Pfalciparum workshop annotations reviewed and changed',
                          'Old annotation for ME49')
           then 'GenePrediction'
         else nf.subclass_view
       end as feature_type,
       nf.source_id as feature_source_id, scaffold.source_id as sequence_source_id,
       sp.virtual_na_sequence_id, nf.na_feature_id,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - greatest(nl.start_min, nl.start_max, nl.end_min, nl.end_max)+ 1
           else sp.distance_from_left + least(nl.start_min, nl.start_max, nl.end_min, nl.end_max)
       end as start_min,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - least(nl.start_min, nl.start_max, nl.end_min, nl.end_max) + 1
         else sp.distance_from_left + greatest(nl.start_min, nl.start_max, nl.end_min, nl.end_max)
       end as end_max,
       case
         when sp.strand_orientation in ('-', '-1')
         then decode(nvl(nl.is_reversed, 0),
                     0, 1,  1, 0,  1)
         else nl.is_reversed
       end as is_reversed,
       nf.parent_id, nf.sequence_ontology_id,
       cast (null as number) as is_top_level,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - coding_start + 1
           else sp.distance_from_left + ef.coding_start
       end as coding_start,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - coding_end + 1
         else sp.distance_from_left + coding_end
       end as coding_end, nf.external_database_release_id
from dots.NaFeature nf, dots.NaLocation nl, dots.NaSequence contig,
     apidb.SequencePieceClosure sp, dots.NaSequence scaffold, dots.ExonFeature ef,
     (select edr.external_database_release_id, ed.name
      from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      where edr.external_database_id = ed.external_database_id) db
where nf.na_feature_id = nl.na_feature_id
  and nf.external_database_release_id = db.external_database_release_id(+)
  and nf.na_sequence_id = contig.na_sequence_id
  and nf.na_sequence_id = sp.piece_na_sequence_id
  and sp.virtual_na_sequence_id = scaffold.na_sequence_id
  and nl.na_feature_id = ef.na_feature_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
update apidb.FeatureLocation&1
set is_top_level = 1
      ]]>
    </sql>
    <sql>
      <![CDATA[
update apidb.FeatureLocation&1
set is_top_level = 0
where na_sequence_id in (select piece_na_sequence_id from dots.SequencePiece)
      ]]>
    </sql>
    <sql>
      <![CDATA[
commit
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.featloc_ix&1 on apidb.FeatureLocation&1
             (feature_type, na_sequence_id, start_min, end_max, is_reversed, feature_source_id, na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.featloc2_ix&1 on apidb.FeatureLocation&1
             (na_sequence_id, start_min, end_max, is_reversed, sequence_ontology_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.fl_seq_st_end_feat_idx&1
      on apidb.FeatureLocation&1 (na_sequence_id,start_min,end_max,na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.featloc3_ix&1 on apidb.FeatureLocation&1
             (na_feature_id, na_sequence_id, is_top_level)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.featloc4_ix&1 on apidb.FeatureLocation&1
             (feature_type, is_top_level, na_feature_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.GeneId">
    <internalDependency name="apidb.GeneAlias"/>
    <internalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GeneId&1 NOLOGGING AS
SELECT lower(substr(t.protein_id, 1, instr(t.protein_id, '.') - 1)) AS id,
       gf.source_id AS gene
FROM dots.Transcript t, dots.GeneFeature gf
WHERE t.parent_id = gf.na_feature_id
  AND lower(substr(t.protein_id, 1, instr(t.protein_id, '.') - 1)) IS NOT NULL
UNION
SELECT lower(t.protein_id) AS id,
       gf.source_id AS gene
FROM dots.Transcript t, dots.GeneFeature gf
WHERE t.parent_id = gf.na_feature_id
  AND t.protein_id IS NOT NULL
UNION
SELECT LOWER(dr.primary_identifier) AS id, gf.source_id AS gene
FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
     sres.DbRef dr, sres.ExternalDatabaseRelease edr,
     sres.ExternalDatabase ed
WHERE dr.primary_identifier IS NOT NULL
  AND gf.na_feature_id = drnf.na_feature_id
  AND drnf.db_ref_id = dr.db_ref_id
  AND dr.external_database_release_id
        = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
--AND ed.name IN ('NRDB_gb_dbXRefBySeqIdentity',
--                'NRDB_pdb_dbXRefBySeqIdentity',
--                'NRDB_ref_dbXRefBySeqIdentity',
--                'NRDB_sp_dbXRefBySeqIdentity',
--                'Predicted protein structures',
--                'GenBank', 'gb', 'GI', 'Giardia gene aliases 1')
UNION
SELECT LOWER(dr.secondary_identifier) AS id, gf.source_id AS gene
FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
     sres.DbRef dr, sres.ExternalDatabaseRelease edr,
     sres.ExternalDatabase ed
WHERE dr.secondary_identifier IS NOT NULL
  AND gf.na_feature_id = drnf.na_feature_id
  AND drnf.db_ref_id = dr.db_ref_id
  AND dr.external_database_release_id
        = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ed.name IN ('NRDB_gb_dbXRefBySeqIdentity',
                  'NRDB_pdb_dbXRefBySeqIdentity',
                  'NRDB_ref_dbXRefBySeqIdentity',
                  'NRDB_sp_dbXRefBySeqIdentity',
                  'Predicted protein structures',
                  'GenBank')
UNION
SELECT lower(dr.primary_identifier) AS id, gf.source_id AS gene
FROM dots.GeneFeature gf, dots.Transcript t, dots.dbrefNaSequence drns,
     sres.DbRef dr, sres.ExternalDatabaseRelease edr,
      sres.ExternalDatabase ed
WHERE gf.na_feature_id = t.parent_id
  AND t.na_sequence_id = drns.na_sequence_id
  AND drns.db_ref_id = dr.db_ref_id
  AND dr.external_database_release_id = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ed.name = 'GenBank'
UNION
SELECT LOWER(alias) AS id, gene FROM apidb.GeneAlias
UNION
SELECT pred_loc.feature_source_id AS alias, gene_loc.feature_source_id AS gene
FROM apidb.FeatureLocation gene_loc, apidb.FeatureLocation pred_loc
WHERE pred_loc.feature_type = 'GenePrediction'
  AND gene_loc.feature_type = 'GeneFeature'
  AND pred_loc.na_sequence_id = gene_loc.na_sequence_id
  AND gene_loc.start_min <= pred_loc.end_max
  AND gene_loc.end_max >= pred_loc.start_min
  AND pred_loc.is_reversed = gene_loc.is_reversed
UNION
SELECT lower(pred_loc.feature_source_id) AS alias,
       gene_loc.feature_source_id AS gene
FROM apidb.FeatureLocation gene_loc, apidb.FeatureLocation pred_loc
WHERE pred_loc.feature_type = 'GenePrediction'
  AND gene_loc.feature_type = 'GeneFeature'
  AND pred_loc.na_sequence_id = gene_loc.na_sequence_id
  AND gene_loc.start_min <= pred_loc.end_max
  AND gene_loc.end_max >= pred_loc.start_min
  AND pred_loc.is_reversed = gene_loc.is_reversed
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneId_gene_idx&1 ON apidb.GeneId&1 (gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneId_id_idx&1 ON apidb.GeneId&1 (id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SequenceId">
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.SequenceOntology"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.SequenceId&1 NOLOGGING AS
SELECT DISTINCT substr(id, 1, 50) as id, substr(sequence, 1, 50) AS sequence
FROM (
  SELECT lower(source_id) as id, source_id as sequence
  FROM dots.NaSequence ns, sres.SequenceOntology so
  WHERE ns.sequence_ontology_id = so.sequence_ontology_id
    AND so.term_name in ('contig', 'supercontig', 'chromosome','mitochondrial_chromosome','plastid_sequence')
UNION
  SELECT LOWER(dr.primary_identifier) AS id, ns.source_id AS sequence
  FROM dots.NaSequence ns, dots.DbRefNaSequence drnf,
       sres.DbRef dr, sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase ed
  WHERE dr.primary_identifier IS NOT NULL
    AND ns.na_sequence_id = drnf.na_sequence_id
    AND drnf.db_ref_id = dr.db_ref_id
    AND dr.external_database_release_id
          = edr.external_database_release_id
    AND edr.external_database_id = ed.external_database_id
)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SequenceId_sequence_idx&1 ON apidb.SequenceId&1 (sequence)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SequenceId_id_idx&1 ON apidb.SequenceId&1 (id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.EpitopeSummary">
    <externalDependency name="dots.AaFeatureImp"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.AaSequenceDbRef"/>
    <externalDependency name="dots.AaSequenceImp"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.EpitopeSummary&1 NOLOGGING AS
SELECT gf.source_id, dr.primary_identifier AS iedb_id,
       al.start_min||'-'||al.end_max AS location,
       mas.sequence, 
       SUBSTR(tn.name, 1, 40) AS name,
       DECODE(ef.type, 'Not Full Set Not on Blast Hit', 'Low',
                       'Not Full Set On Blast Hit', 'Medium',
                       'Full Set Not on Blast Hit', 'Medium',
                       'Full Set On Blast Hit', 'High',
                       'unknown epitope type') AS confidence
FROM dots.GeneFeature gf, dots.Transcript t,
     dots.TranslatedAaFeature taf, dots.MotifAaSequence mas,
     dots.TranslatedAaSequence tas, dots.EpitopeFeature ef,
     dots.AaLocation al, dots.AaSequenceDbRef asdr,
     sres.DbRef dr, sres.ExternalDatabaseRelease edr,
     sres.ExternalDatabase ed, Sres.TaxonName tn
WHERE t.parent_id = gf.na_feature_id
  AND taf.na_feature_id = t.na_feature_id
  AND taf.aa_sequence_id = tas.aa_sequence_id
  AND tas.aa_sequence_id = ef.aa_sequence_id
  AND ef.aa_feature_id = al.aa_feature_id
  AND ef.motif_aa_sequence_id = mas.aa_sequence_id
  AND mas.aa_sequence_id = asdr.aa_sequence_id
  AND asdr.db_ref_id = dr.db_ref_id
  AND tas.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
  AND ef.external_database_release_id
      = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ed.name = 'Links to IEDB epitopes'
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Epi_srcId_ix&1 ON apidb.EpitopeSummary&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.GeneCentromereDistance">
    <internalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="sres.SequenceOntology"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GeneCentromereDistance&1 NOLOGGING AS
SELECT gfl.feature_source_id AS gene,
       LEAST(ABS(mfl.start_min - gfl.end_max),
             ABS(mfl.end_max - gfl.start_min)) AS centromere_distance,
       gfl.sequence_source_id AS genomic_sequence
FROM apidb.FeatureLocation gfl, apidb.FeatureLocation mfl,
     sres.SequenceOntology so
WHERE gfl.na_sequence_id = mfl.na_sequence_id
  AND mfl.feature_type = 'Miscellaneous'
  AND gfl.feature_type = 'GeneFeature'
  AND mfl.sequence_ontology_id = so.sequence_ontology_id
  AND so.term_name = 'centromere'
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GCent_loc_ix&1
       ON apidb.GeneCentromereDistance&1 (genomic_sequence, centromere_distance)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SageTagGene">
    <internalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="rad.DataTransformationResult"/>
    <externalDependency name="dots.SageTagFeature"/>
    <intermediateTable name="apidb.SageTagGeneFivePrime"/>
    <intermediateTable name="apidb.SageTagGeneThreePrime"/>
    <sql>
      <![CDATA[
create table apidb.SageTagGeneFivePrime NOLOGGING as
   select '5' as direction, g.feature_source_id AS gene_source_id,
          s.feature_source_id as tag_source_id,
             min (case
                    when g.is_reversed = 1 and s.end_max - g.end_max < 0
                      then 0
                    when g.is_reversed = 1 and s.end_max - g.end_max >= 0
                      then s.end_max - g.end_max
                    when g.is_reversed = 0 and g.start_min - s.start_min < 0
                      then 0
                    when g.is_reversed = 0 and g.start_min - s.start_min >= 0
                      then g.start_min - s.start_min
                  end) as distance,
           dr.analysis_id, max(dr.float_value) as tag_count,
           max(ct.occurrence) as occurrence,
           g.na_feature_id as gene_feature_id, s.na_feature_id as tag_feature_id,
           case when s.is_reversed = g.is_reversed then 0
                else 1
           end as antisense
      from apidb.FeatureLocation g, apidb.FeatureLocation s,
           rad.DataTransformationResult dr,
           (select source_id , count(*) as occurrence
            from dots.SageTagFeature
            group by source_id) ct
      where g.feature_type = 'GeneFeature'
        and s.feature_type = 'SAGETagFeature'
        and g.na_sequence_id = s.na_sequence_id
        and s.feature_source_id = dr.row_id
        and dr.row_id = ct.source_id
        and (case
               when g.is_reversed = 0
                 then g.start_min - s.start_min
               else s.end_max - g.end_max
             end <= 1000
            and case
                  when g.is_reversed = 0
                    then g.end_max - s.end_max
                  else s.start_min - g.start_min
                end >= 0)
      group by g.feature_source_id, s.feature_source_id, dr.analysis_id,
               g.na_feature_id, s.na_feature_id,
               case when s.is_reversed = g.is_reversed then 0
                    else 1
               end
      ]]>
    </sql>
    <sql>
      <![CDATA[
create table apidb.SageTagGeneThreePrime NOLOGGING as
      select '3' as direction, g.feature_source_id AS gene_source_id,
             s.feature_source_id as tag_source_id,
             min (case
                    when g.is_reversed = 1 and g.start_min - s.start_min < 0
                      then 0
                    when g.is_reversed = 1 and g.start_min - s.start_min  >= 0
                      then g.start_min - s.start_min
                    when g.is_reversed = 0 and s.end_max - g.end_max < 0
                      then 0
                    when g.is_reversed = 0 and s.end_max - g.end_max >= 0
                      then s.end_max - g.end_max
                  end) as distance,
           dr.analysis_id, max(dr.float_value) as tag_count,
           max(ct.occurrence) as occurrence,
           g.na_feature_id as gene_feature_id, s.na_feature_id as tag_feature_id,
           case when s.is_reversed = g.is_reversed then 0
                else 1
           end as antisense
      from apidb.FeatureLocation g, apidb.FeatureLocation s,
           rad.DataTransformationResult dr,
           (select source_id , count(*) as occurrence
            from dots.SageTagFeature
            group by source_id) ct
            where g.feature_type = 'GeneFeature'
              and s.feature_type = 'SAGETagFeature'
              and g.na_sequence_id = s.na_sequence_id
              and s.feature_source_id = dr.row_id
              and dr.row_id = ct.source_id
              and (case
                     when g.is_reversed = 0
                       then s.end_max - g.end_max
                     else g.start_min - s.start_min end <= 1000
                  and
                   case
                     when g.is_reversed = 0
                       then s.start_min - g.start_min
                     else g.end_max - s.end_max
                   end >= 0)
            group by g.feature_source_id, s.feature_source_id, dr.analysis_id,
                     g.na_feature_id, s.na_feature_id,
                     case when s.is_reversed = g.is_reversed then 0
                          else 1
                     end
      ]]>
    </sql>
    <sql>
      <![CDATA[
create table apidb.SageTagGene&1 NOLOGGING as
select t.direction, t.gene_source_id, t.tag_source_id, t.distance,
       t.analysis_id, t.occurrence, t.gene_feature_id, t.tag_feature_id,
       t.tag_count, t.antisense,
       case
         when t.antisense = 0 then t.tag_count
         else 0
       end as sense_count,
       case
         when t.antisense = 0 then 0
         else t.tag_count
       end as antisense_count
from
  (select * from apidb.SageTagGeneFivePrime
   union all
   select * from apidb.SageTagGeneThreePrime) t
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SageTagAnalysisAttributes">
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="rad.Analysis"/>
    <externalDependency name="rad.AnalysisInput"/>
    <externalDependency name="rad.AnalysisResultImp"/>
    <externalDependency name="rad.Assay"/>
    <externalDependency name="rad.CompositeElementImp"/>
    <externalDependency name="rad.CompositeElementResultImp"/>
    <externalDependency name="rad.LogicalGroup"/>
    <externalDependency name="rad.LogicalGroupLink"/>
    <externalDependency name="rad.Protocol"/>
    <externalDependency name="rad.Quantification"/>
    <sql>
      <![CDATA[
create table apidb.SageTagAnalysisAttributes&1 NOLOGGING as
select dtr.analysis_id, max(dtr.float_value) as tag_count,
       max(ct.occurrence) as occurrence, substr(st.tag, 1, 30) as sequence,
       st.composite_element_id, a.name as library_name,
       library_total.total_count as library_total_tag_count,
       (max(dtr.float_value) * 100) / library_total.total_count
         as library_tag_percentage,
       r.tag_count as raw_count, tot.total_raw_count,
       100 *(r.tag_count / tot.total_raw_count ) as raw_percent
from dots.SageTagFeature stf, -- apidb.FeatureLocation nl,
     rad.DataTransformationResult dtr, rad.SageTag st, core.TableInfo ti,
     rad.AnalysisInput ai, rad.LogicalGroup lg, rad.LogicalGroupLink ll,
     rad.Assay a, core.TableInfo quant_ti, --core.DatabaseInfo di,
     rad.SageTagResult r, rad.Quantification q,
     (select source_id , count(*) as occurrence
      from dots.SageTagFeature
      group by source_id) ct,
     (select dt.analysis_id, sum(float_value) as total_count
      from rad.DataTransformationResult dt, rad.Analysis a, rad.Protocol p
      where dt.analysis_id = a.analysis_id
        and a.protocol_id = p.protocol_id
        and p.name = 'Normalization of SAGE tag frequencies to a target total intensity'
      group by dt.analysis_id) library_total,
     (select quantification_id, sum(tag_count) as total_raw_count
      from rad.SageTagResult
      group by quantification_id) tot
where ti.name = 'SAGETag'
  and quant_ti.name = 'Assay'
  --and di.name = 'RAD'
  and dtr.table_id = ti.table_id
  and st.composite_element_id = dtr.row_id
  and stf.source_id = st.composite_element_id
  and st.composite_element_id = r.composite_element_id
  and q.quantification_id = r.quantification_id
  and tot.quantification_id = r.quantification_id
--  and nl.na_feature_id = stf.na_feature_id
  and ct.source_id = stf.source_id
  and dtr.analysis_id = ai.analysis_id
  and ai.logical_group_id = lg.logical_group_id
  and lg.logical_group_id = ll.logical_group_id
  and ll.row_id = a.assay_id
  and a.name = q.name
  and ll.table_id = quant_ti.table_id
  --and di.database_id = quant_ti.database_id
  and dtr.analysis_id = library_total.analysis_id
group by stf.source_id, dtr.analysis_id, st.tag, st.composite_element_id,
         a.name, library_total.total_count,
         q.name, r.tag_count, tot.total_raw_count
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.staa_ix&1 on apidb.SageTagAnalysisAttributes&1 (analysis_id, composite_element_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.GeneAttributes">
    <internalDependency name="apidb.GeneId"/>
    <internalDependency name="apidb.GeneAlias"/>
    <internalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="apidb.GenomicSequence"/>
    <internalDependency name="apidb.TaxonSpecies"/>
    <externalDependency name="apidb.AaSequenceAttribute"/>
    <externalDependency name="apidb.Profile"/>
    <externalDependency name="apidb.ProfileSet"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.AaFeatureImp"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.AaSequenceEnzymeClass"/>
    <externalDependency name="dots.AaSequenceImp"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="dots.GeneInstance"/>
    <externalDependency name="dots.GoAssociation"/>
    <externalDependency name="dots.GoAssociationInstance"/>
    <externalDependency name="dots.GoAssociationInstanceLoe"/>
    <externalDependency name="dots.GoAssocInstEvidCode"/>
    <externalDependency name="dots.NaFeatureComment"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.NaSequenceImp"/> 
    <externalDependency name="dots.SequenceGroup"/>
    <externalDependency name="rad.Analysis"/>
    <externalDependency name="rad.AnalysisInput"/>
    <externalDependency name="rad.AnalysisResultImp"/>
    <externalDependency name="rad.CompositeElementImp"/>
    <externalDependency name="rad.LogicalGroup"/>
    <externalDependency name="rad.Protocol"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.EnzymeClass"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.GoEvidenceCode"/>
    <externalDependency name="sres.GoRelationship"/>
    <externalDependency name="sres.GoTerm"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <intermediateTable name="apidb.GoTermList"/>
    <intermediateTable name="apidb.GeneGoAttributes"/>
    <intermediateTable name="apidb.DerisiExpn"/>
    <intermediateTable name="apidb.WinzelerExpn"/>
    <intermediateTable name="apidb.ToxoExpn"/>
    <intermediateTable name="apidb.GeneProteinAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GoTermList NOLOGGING AS
SELECT *
FROM (  -- work around sometime Oracle bug ORA-00942
      SELECT source_id, ontology, source,
             apidb.tab_to_string(CAST(COLLECT(name) AS apidb.varchartab), ', ')
               AS go_terms
      FROM (SELECT DISTINCT gf.source_id, o.ontology, gt.name,
                        DECODE(gail.name, 'Interpro', 'predicted', 'annotated')
                              AS source
            FROM dots.GeneFeature gf, dots.Transcript t,
                 dots.TranslatedAaFeature taf, dots.GoAssociation ga,
                 sres.GoTerm gt, dots.GoAssociationInstance gai,
                 dots.GoAssociationInstanceLoe gail,
                 dots.GoAssocInstEvidCode gaiec, sres.GoEvidenceCode gec,
                 (SELECT gr.child_term_id AS go_term_id, gp.name AS ontology
                  FROM sres.GoRelationship gr, sres.GoTerm gp
                  WHERE gr.parent_term_id = gp.go_term_id
                    AND gp.go_id in ('GO:0008150','GO:0003674','GO:0005575')) o
            WHERE gf.na_feature_id = t.parent_id
              AND t.na_feature_id = taf.na_feature_id
              AND taf.aa_sequence_id = ga.row_id
              AND ga.table_id = (SELECT table_id
                                 FROM core.TableInfo
                                 WHERE name = 'TranslatedAASequence')
              AND ga.go_term_id = gt.go_term_id
              AND ga.go_association_id = gai.go_association_id
              AND gai.go_assoc_inst_loe_id = gail.go_assoc_inst_loe_id
              AND gai.go_association_instance_id
                  = gaiec.go_association_instance_id
              AND gaiec.go_evidence_code_id = gec.go_evidence_code_id
              AND gt.go_term_id = o.go_term_id)
      GROUP BY source_id, ontology, source)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GeneGoAttributes NOLOGGING AS
SELECT DISTINCT gene.source_id,
       substr(annotated_go_component.go_terms, 1, 300) AS annotated_go_component,
       substr(annotated_go_function.go_terms, 1, 300) AS annotated_go_function,
       substr(annotated_go_process.go_terms, 1, 300) AS annotated_go_process,
       substr(predicted_go_component.go_terms, 1, 300) AS predicted_go_component,
       substr(predicted_go_function.go_terms, 1, 300) AS predicted_go_function,
       substr(predicted_go_process.go_terms, 1, 300) AS predicted_go_process
FROM (SELECT DISTINCT gene AS source_id FROM apidb.GeneId) gene,
     (SELECT * FROM apidb.GoTermList
      WHERE source = 'annotated' AND ontology = 'cellular_component')
       annotated_go_component,
     (SELECT * FROM apidb.GoTermList
      WHERE source = 'annotated' AND ontology = 'molecular_function')
       annotated_go_function,
     (SELECT * FROM apidb.GoTermList
      WHERE source = 'annotated' AND ontology = 'biological_process')
       annotated_go_process,
     (SELECT * FROM apidb.GoTermList
      WHERE source = 'predicted' AND ontology = 'cellular_component')
       predicted_go_component,
     (SELECT * FROM apidb.GoTermList
      WHERE source = 'predicted' AND ontology = 'molecular_function')
       predicted_go_function,
     (SELECT * FROM apidb.GoTermList
      WHERE source = 'predicted' AND ontology = 'biological_process')
       predicted_go_process
WHERE gene.source_id = annotated_go_component.source_id(+)
  AND 'annotated' = annotated_go_component.source(+)
  AND 'cellular_component' = annotated_go_component.ontology(+)
  AND gene.source_id = annotated_go_function.source_id(+)
  AND 'annotated' = annotated_go_function.source(+)
  AND 'molecular_function' = annotated_go_function.ontology(+)
  AND gene.source_id = annotated_go_process.source_id(+)
  AND 'annotated' = annotated_go_process.source(+)
  AND 'biological_process' = annotated_go_process.ontology(+)
  AND gene.source_id = predicted_go_component.source_id(+)
  AND 'predicted' = predicted_go_component.source(+)
  AND 'cellular_component' = predicted_go_component.ontology(+)
  AND gene.source_id = predicted_go_function.source_id(+)
  AND 'predicted' = predicted_go_function.source(+)
  AND 'molecular_function' = predicted_go_function.ontology(+)
  AND gene.source_id = predicted_go_process.source_id(+)
  AND 'predicted' = predicted_go_process.source(+)
  AND 'biological_process' = predicted_go_process.ontology(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneGoAttr_sourceId ON apidb.GeneGoAttributes (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.DerisiExpn NOLOGGING AS
SELECT gene.source_id, expn.derisi_max_level, derisi_max_pct,
       derisi_max_timing, derisi_min_timing, derisi_min_level,
       max_fold_induction as derisi_max_fold_induction
FROM (SELECT DISTINCT gene AS source_id from apidb.GeneId) gene,
     (SELECT * FROM (SELECT p.source_id,
                            p.max_expression AS derisi_max_level,
                            p.equiv_max AS derisi_max_timing,
                            p.equiv_min AS derisi_min_timing,
                            p.min_expression AS derisi_min_level,
                            p.ind_ratio as max_fold_induction,
                            row_number() over (partition by p.source_id order by p.ind_ratio desc) row_number
                     FROM apidb.Profile p, apidb.ProfileSet ps
                     WHERE ps.name like 'DeRisi % Smoothed Averaged'
                       AND p.profile_set_id = ps.profile_set_id)
      WHERE row_number = 1) expn,
     (SELECT p.source_id, max(p.max_percentile) as derisi_max_pct
      FROM apidb.Profile p, apidb.ProfileSet ps
      WHERE ps.name like 'DeRisi % Smoothed Averaged'
        AND p.profile_set_id = ps.profile_set_id
      GROUP BY p.source_id) percentile
WHERE gene.source_id = expn.source_id(+)
  AND gene.source_id = percentile.source_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Derisi_sourceId ON apidb.DerisiExpn (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.WinzelerExpn NOLOGGING AS
SELECT gene.source_id, expn.winzeler_max_level, winzeler_max_pct,
       winzeler_max_timing, winzeler_min_timing, winzeler_min_level
FROM (SELECT DISTINCT gene AS source_id from apidb.GeneId) gene,
     (SELECT p.source_id,
             p.max_expression AS winzeler_max_level,
             p.max_percentile AS winzeler_max_pct,
             p.time_of_max_expr AS winzeler_max_timing,
             p.time_of_min_expr AS winzeler_min_timing,
             p.min_expression AS winzeler_min_level
      FROM apidb.Profile p, apidb.ProfileSet ps, core.TableInfo ti
      WHERE ps.name = 'winzeler_cc_sorbExp'
        AND ti.name = 'GeneFeature'
        AND p.profile_set_id = ps.profile_set_id
        AND ti.table_id = p.subject_table_id) expn
WHERE gene.source_id = expn.source_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Winzeler_sourceId ON apidb.WinzelerExpn (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.ToxoExpn NOLOGGING AS
select g.source_id, 
       type3_type1_fold_change,
       type3_type2_fold_change,
       type2_type1_fold_change
From dots.genefeature g, 
     (select gf.source_id, dr.fold_change as type3_type1_fold_change
      from rad.analysis a, rad.differentialexpression dr, 
           core.tableinfo t, dots.genefeature gf
      where a.analysis_id = dr.analysis_id
       and dr.table_id = t.table_id
       and dr.row_id = gf.na_feature_id
       and t.name = 'GeneFeature'
       and a.name = 'Type3vsType1') type3vstype1,
 (select gf.source_id, dr.fold_change as type3_type2_fold_change
      from rad.analysis a, rad.differentialexpression dr, 
           core.tableinfo t, dots.genefeature gf
      where a.analysis_id = dr.analysis_id
       and dr.table_id = t.table_id
       and dr.row_id = gf.na_feature_id
       and t.name = 'GeneFeature'
       and a.name = 'Type3vsType2') type3vstype2,
 (select gf.source_id, dr.fold_change as type2_type1_fold_change
      from rad.analysis a, rad.differentialexpression dr, 
           core.tableinfo t, dots.genefeature gf
      where a.analysis_id = dr.analysis_id
       and dr.table_id = t.table_id
       and dr.row_id = gf.na_feature_id
       and t.name = 'GeneFeature'
       and a.name = 'Type2vsType1') type2vstype1
where g.source_id = type3vstype1.source_id
 and g.source_id = type3vstype2.source_id
 and g.source_id = type2vstype1.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Toxo_sourceId ON apidb.ToxoExpn (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GeneProteinAttributes NOLOGGING AS
SELECT gene.source_id,
       protein.tm_count, protein.molecular_weight,
       protein.isoelectric_point, protein.min_molecular_weight,
       protein.max_molecular_weight, protein.hydropathicity_gravy_score,
       protein.aromaticity_score, protein.cds_length, protein.protein_length,
       protein.ec_numbers,
       protein.signalp_scores,protein.signalp_peptide
FROM (SELECT DISTINCT gene AS source_id from apidb.GeneId) gene,
     (SELECT gf.source_id, taf.na_feature_id, tas.aa_sequence_id,tas.molecular_weight,
             tas.length AS protein_length,
             greatest(taf.translation_start, taf.translation_stop)
             - least(taf.translation_start, taf.translation_stop) + 1 AS cds_length,
             asa.isoelectric_point,
             asa.min_molecular_weight, asa.max_molecular_weight,
             asa.hydropathicity_gravy_score,
             asa.aromaticity_score,
             NVL(transmembrane.tm_domains, 0) AS tm_count,
             ec.ec_numbers,
             sigp.scores as signalp_scores,
             substr(sigp.pep, 1, 200) as signalp_peptide
      FROM  dots.GeneFeature gf, dots.Transcript t,
            dots.TranslatedAaFeature taf,
            dots.TranslatedAaSequence tas,
            apidb.AaSequenceAttribute asa,
            (SELECT aa_sequence_id, max(tm_domains) AS tm_domains
             FROM (SELECT tmaf.aa_sequence_id, COUNT(*) AS tm_domains
                   FROM dots.TransmembraneAaFeature tmaf, dots.AaLocation al
                   WHERE tmaf.aa_feature_id = al.aa_feature_id
                   GROUP BY tmaf.aa_sequence_id) tms
             GROUP BY tms.aa_sequence_id) transmembrane,
            (SELECT aa_sequence_id,
                    SUBSTR(apidb.tab_to_string(CAST(COLLECT(ec_number)
                                               AS apidb.varchartab), '; '),
                           1, 300)
                      AS ec_numbers
             FROM (SELECT DISTINCT asec.aa_sequence_id,
                          ec.ec_number || ' (' || ec.description || ')' AS ec_number
                   FROM dots.aaSequenceEnzymeClass asec, sres.enzymeClass ec
                   WHERE ec.enzyme_class_id = asec.enzyme_class_id)
             GROUP BY aa_sequence_id) ec,
             (SELECT spf.aa_sequence_id,'NN Sum: ' || ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) ||
              ', NN D: ' || round(((spf.means_score + spf.maxy_score) / 2),2) || ', HMM Prob: ' || round(spf.signal_probability,2) as scores,
               apidb.tab_to_string(CAST(COLLECT(decode(spf.algorithm_name,'SignalPhmm','HMM: ','NN: ') || dbms_lob.substr(s.sequence,aal.end_max,1)) AS apidb.varchartab), ', ') as pep
              FROM dots.signalpeptidefeature spf, dots.aalocation aal,dots.AASEQUENCE s
              WHERE spf.aa_sequence_id = s.aa_sequence_id 
              and  aal.aa_feature_id = spf.aa_feature_id
              and (spf.signal_probability >= .5
              or ((spf.means_score + spf.maxy_score) / 2) >= .5
              or ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) >= 3)
              group by spf.aa_sequence_id,'NN Sum: ' || ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) ||
              ', NN D: ' || round(((spf.means_score + spf.maxy_score) / 2),2) || ', HMM Prob: ' || round(spf.signal_probability,2)) sigp
      WHERE gf.na_feature_id = t.parent_id
        AND t.na_feature_id = taf.na_feature_id
        AND taf.aa_sequence_id = tas.aa_sequence_id
        AND taf.aa_sequence_id = asa.aa_sequence_id
        and tas.aa_sequence_id = sigp.aa_sequence_id(+)
        AND tas.aa_sequence_id = transmembrane.aa_sequence_id(+)
        AND tas.aa_sequence_id = ec.aa_sequence_id(+)) protein
WHERE gene.source_id = protein.source_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GPA_sourceId ON apidb.GeneProteinAttributes (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GeneAttributes&1 NOLOGGING AS
SELECT apidb.project_id(tn.name) as project_id,
       gf.source_id, gf.na_feature_id,
       REPLACE(so.term_name, '_', ' ') AS gene_type,
       SUBSTR(gf.product, 1, 200) AS product,
       gf.is_pseudo,
       LEAST(nl.start_min, nl.end_max) AS start_min,
       GREATEST(nl.start_min, nl.end_max) AS end_max,
       first_exon.coding_start,
       last_exon.coding_end,
       nl.is_reversed,
       sns.length AS transcript_length,
       GREATEST(0, least(nl.start_min, nl.end_max) - 15000)
           AS context_start,
       LEAST(sequence.length, greatest(nl.start_min, nl.end_max) + 15000)
           AS context_end,
       DECODE(nvl(nl.is_reversed, 0), 0, 'forward', 1, 'reverse',
              nl.is_reversed) AS strand,
       SUBSTR(sequence.source_id, 1, 50) AS sequence_id,
       SUBSTR(tn.name, 1, 40) AS organism,
       SUBSTR(species_name.name, 1, 40) AS species,
       taxon.ncbi_tax_id,
       so_id, SUBSTR(so.term_name, 1, 150) AS so_term_name,
       SUBSTR(so.definition, 1, 150) AS so_term_definition,
       so.ontology_name, SUBSTR(so.so_version, 1, 7) AS so_version,
       SUBSTR(NVL(rt1.anticodon, rt2.anticodon), 1, 3) AS anticodon,
       protein.tm_count, protein.molecular_weight,
       protein.isoelectric_point, protein.min_molecular_weight,
       protein.max_molecular_weight, protein.hydropathicity_gravy_score,
       protein.aromaticity_score, protein.cds_length, protein.protein_length,
       protein.ec_numbers,
       ed.name AS external_db_name,
       SUBSTR(edr.version, 1, 10) AS external_db_version,
       exons.exon_count, SUBSTR(cmnt.comment_string, 1, 300) AS comment_string,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.chromosome_order_num, sequence.na_sequence_id,
       go.annotated_go_component,
       go.annotated_go_function,
       go.annotated_go_process,
       go.predicted_go_component,
       go.predicted_go_function,
       go.predicted_go_process,
       DerisiExpn.derisi_max_level,
       DerisiExpn.derisi_max_pct,
       DerisiExpn.derisi_max_timing,
       DerisiExpn.derisi_min_timing,
       DerisiExpn.derisi_min_level,
       DerisiExpn.derisi_max_fold_induction,
       WinzelerExpn.winzeler_max_level,
       WinzelerExpn.winzeler_max_pct,
       WinzelerExpn.winzeler_max_timing,
       WinzelerExpn.winzeler_min_timing,
       WinzelerExpn.winzeler_min_level,
       ToxoExpn.type3_type1_fold_change,
       ToxoExpn.type3_type2_fold_change,
       ToxoExpn.type2_type1_fold_change,
       nvl(deprecated.is_deprecated, 0) as is_deprecated, gi.gene_id,
       orthologs.name as orthomcl_name,
       nvl(totsnps.total_snps,0) as total_snps, 
       nvl(nssnps.nonsyn_snps,0) as nonsynonymous_snps,
       nvl(synsnps.syn_snps,0) as synonymous_snps,
       CASE WHEN (nssnps.nonsyn_snps is null or synsnps.syn_snps is null) THEN 0 
            ELSE round((nssnps.nonsyn_snps / synsnps.syn_snps),2) END as nonsyn_syn_ratio,
       protein.signalp_scores,protein.signalp_peptide
FROM dots.GeneFeature gf, apidb.FeatureLocation nl, sres.SequenceOntology so,
     sres.Taxon, sres.TaxonName tn, dots.RnaType rt1, dots.RnaType rt2,
     dots.Transcript t, sres.ExternalDatabase ed,
     sres.ExternalDatabaseRelease edr, dots.SplicedNaSequence sns,
     apidb.GeneProteinAttributes protein, apidb.GeneGoAttributes go,
     apidb.DerisiExpn DerisiExpn, apidb.WinzelerExpn WinzelerExpn,
     apidb.ToxoExpn ToxoExpn, apidb.GenomicSequence sequence,
     dots.geneinstance gi, apidb.TaxonSpecies ts, sres.TaxonName species_name,
     (SELECT parent_id, count(*) AS exon_count
      FROM dots.ExonFeature
      GROUP BY parent_id) exons,
     (SELECT ef.parent_id, fl.coding_start
      FROM dots.ExonFeature ef, apidb.FeatureLocation fl
      WHERE ef.order_number = 1
        AND ef.na_feature_id = fl.na_feature_id
        AND fl.is_top_level = 1) first_exon,
     (SELECT ef.parent_id, ef.order_number, fl.coding_end
      FROM dots.ExonFeature ef, apidb.FeatureLocation fl
      WHERE ef.na_feature_id = fl.na_feature_id
        AND fl.is_top_level = 1) last_exon,
     (SELECT nfc.na_feature_id,
             MAX(DBMS_LOB.SUBSTR(nfc.comment_string, 300, 1))
               AS comment_string
      FROM dots.NaFeatureComment nfc
      GROUP BY nfc.na_feature_id) cmnt,
     (select distinct gf.source_id, 1 as is_deprecated
      from dots.GeneFeature gf, dots.DbRefNaFeature drnf, sres.DbRef dr, sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      where gf.na_feature_id = drnf.na_feature_id
        and drnf.db_ref_id = dr.db_ref_id
        and dr.external_database_release_id = edr.external_database_release_id
        and edr.external_database_id = ed.external_database_id
        and ed.name = 'deprecated genes') deprecated,
     (select sf.parent_id,count(*) as total_snps
      from dots.snpfeature sf, sres.externaldatabaserelease rel, sres.EXTERNALDATABASE d
      where d.name not in ('Broad SNPs','Sanger falciparum SNPs',
            'Winzeler Array - Plasmodium Genetic Variation','Su SNPs','Sanger reichenowi SNPs')
      and d.external_database_id = rel.external_database_id
      and sf.external_database_release_id = rel.external_database_release_id
      and sf.parent_id is not null
      group by sf.parent_id) totsnps,
      (select sf.parent_id,count(*) as nonsyn_snps
       from dots.snpfeature sf, sres.externaldatabaserelease rel, sres.EXTERNALDATABASE d
       where d.name not in ('Broad SNPs','Sanger falciparum SNPs',
             'Winzeler Array - Plasmodium Genetic Variation','Su SNPs','Sanger reichenowi SNPs')
       and d.external_database_id = rel.external_database_id
       and sf.external_database_release_id = rel.external_database_release_id
       and sf.parent_id is not null
       and sf.has_nonsynonymous_allele = 1
       group by sf.parent_id) nssnps,
      (select sf.parent_id,count(*) as syn_snps
       from dots.snpfeature sf, sres.externaldatabaserelease rel, sres.EXTERNALDATABASE d
       where d.name not in ('Broad SNPs','Sanger falciparum SNPs',
             'Winzeler Array - Plasmodium Genetic Variation','Su SNPs','Sanger reichenowi SNPs')
       and d.external_database_id = rel.external_database_id
       and sf.external_database_release_id = rel.external_database_release_id
       and sf.parent_id is not null
       and sf.has_nonsynonymous_allele is null
       and sf.is_coding = 1
       group by sf.parent_id) synsnps,
       (select gf.na_feature_id, sg.name
        from dots.genefeature gf, dots.sequencesequencegroup ssg, 
             dots.sequencegroup sg, Core.tableinfo ti
        where gf.na_feature_id = ssg.sequence_id
         and ssg.sequence_group_id = sg.sequence_group_id
         and ssg.source_table_id = ti.table_id
         and ti.name = 'GeneFeature'
        UNION
        select chr6.na_feature_id, sg.name
        from (select co.group_id, gf.source_id 
              from apidb.chromosome6orthology co, dots.genefeature gf,
                   sres.taxonname tn, dots.nasequence s
              where co.source_id = gf.source_id
               and gf.na_sequence_id = s.na_sequence_id
               and tn.taxon_id = s.taxon_id
               and tn.name = 'Cryptosporidium parvum Iowa II'
             ) par, 
             (select co.group_id, gf.source_id, gf.na_feature_id
              from apidb.chromosome6orthology co, dots.genefeature gf,
                   sres.taxonname tn, dots.nasequence s
              where co.source_id = gf.source_id
               and gf.na_sequence_id = s.na_sequence_id
               and tn.taxon_id = s.taxon_id
               and tn.name = 'Cryptosporidium parvum'
             ) chr6, 
             dots.genefeature gf, dots.sequencegroup sg, dots.sequencesequencegroup ssg
        where chr6.group_id = par.group_id
         and par.source_id = gf.source_id
         and gf.na_feature_id = ssg.sequence_id
         and ssg.sequence_group_id = sg.sequence_group_id
       ) orthologs
WHERE gf.source_id is not null
  AND gf.na_feature_id = nl.na_feature_id
  AND nl.is_top_level = 1
  AND nl.na_sequence_id = sequence.na_sequence_id
  AND gf.sequence_ontology_id = so.sequence_ontology_id
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
  AND gf.source_id = protein.source_id(+)
  AND gf.source_id = go.source_id(+)
  AND gf.source_id = DerisiExpn.source_id(+)
  AND gf.source_id = WinzelerExpn.source_id(+)
  AND gf.source_id = ToxoExpn.source_id(+)
  AND t.na_sequence_id = sns.na_sequence_id(+)
  AND gf.na_feature_id = t.parent_id(+)
  AND t.na_feature_id = rt1.parent_id(+)
  AND gf.na_feature_id = rt2.parent_id(+)
  AND gf.external_database_release_id
       = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND gf.na_feature_id = exons.parent_id(+)
  AND gf.na_feature_id = orthologs.na_feature_id(+)
  AND gf.na_feature_id = first_exon.parent_id(+)
  AND exons.parent_id = last_exon.parent_id(+)
  AND exons.exon_count = last_exon.order_number(+)
  AND gf.na_feature_id = cmnt.na_feature_id(+)
  AND gf.source_id = deprecated.source_id(+)
  AND gf.na_feature_id = gi.na_feature_id(+)
  AND gf.na_feature_id = totsnps.parent_id(+)
  AND gf.na_feature_id = nssnps.parent_id(+)
  AND gf.na_feature_id = synsnps.parent_id(+)
  AND sequence.taxon_id = ts.taxon_id(+)
  AND ts.species_taxon_id = species_name.taxon_id
  AND species_name.name_class = 'scientific name'
  -- skip toxo predictions (except tRNAs)
  -- skip new plasmo annotation
  AND ed.name NOT IN ('GLEAN predictions', 'GlimmerHMM predictions',
                      'TigrScan', 'TwinScan predictions',
                      'TwinScanEt predictions',
                      'Annotation for T. gondii ME49 - typeII:2005-08-01',
                      'Old annotation for ME49','P. falciparum Evigan Gene Models',
                      'P. yoelii Provisional Annotations from Kappe',
                      'Sanger P. falciparum old annotations',
                      'Pfalciparum workshop annotations reviewed and changed',
                      'Annotation for T. gondii ME49 - typeII:2005-08-01')
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.GeneAttr_sourceId&1
       ON apidb.GeneAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneAttr_exon_ix&1
       ON apidb.GeneAttributes&1 (exon_count, source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneAttr_loc_ix&1
       ON apidb.GeneAttributes&1 (na_sequence_id, start_min, end_max, is_reversed)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneAttr_feat_ix&1
       ON apidb.GeneAttributes&1 (na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneAttr_geneid_ix&1
       ON apidb.GeneAttributes&1 (gene_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneAttr_orthoname_ix&1
       ON apidb.GeneAttributes&1 (orthomcl_name)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
  update apidb.geneattributes&1
  set exon_count = 1
  where exon_count > 1
   and project_id = 'TriTrypDB' 
   and source_id not in ('LmjF29.2600',
                         'LinJ29_V3.2710',
                         'Tb927.3.3160',
                         'Tb927.8.1510',
                         'Tc00.1047053508153.440',
                         'Tc00.1047053508547.110',
                         'Tc00.1047053508973.50')
      ]]>
    </sql>
    <sql>
      <![CDATA[
update apidb.GENEATTRIBUTES&1 ga
set ga.orthomcl_name = (select distinct gb.orthomcl_name from GENEATTRIBUTES&1 gb
                     where gb.gene_id = ga.GENE_ID
                     and gb.orthomcl_name is not null
                     and gb.source_id != gb.orthomcl_name)
where ga.organism like 'Toxo%' 
and ga.ORTHOMCL_NAME is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update apidb.GENEATTRIBUTES&1
        set orthomcl_name = 'ORTH_' || gene_id || '.tmp'
        where orthomcl_name is null
        and gene_id is not null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update apidb.GENEATTRIBUTES&1
        set orthomcl_name = source_id
        where orthomcl_name is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
       alter table apidb.GENEATTRIBUTES&1
       add (
            paralog_number number,
            ortholog_number number
            )
      ]]>
    </sql>
    <sql>
      <![CDATA[
       update apidb.geneattributes&1 set ortholog_number = 0,paralog_number = 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
       update apidb.GENEATTRIBUTES&1 gaup
       set paralog_number = (select count(*)
                               from apidb.GENEATTRIBUTES&1 g1
                               where g1.orthomcl_name = gaup.orthomcl_name
                               and g1.organism = gaup.organism
                               and gaup.source_id != g1.source_id),
           ortholog_number = (select count(*)
                               from apidb.GENEATTRIBUTES&1 g1
                               where g1.orthomcl_name = gaup.orthomcl_name
                               and g1.organism != gaup.organism)
        where gaup.gene_type = 'protein coding'
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.GenomicSequence">
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.SequenceOntology"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GenomicSequence&1 NOLOGGING AS
  SELECT ens.na_sequence_id, ens.taxon_id,
         SUBSTR(ens.source_id, 1, 50) AS source_id,
         LOWER(SUBSTR(ens.source_id, 1, 50)) AS lowercase_source_id,
         ens.a_count, ens.c_count, ens.g_count, ens.t_count, ens.length,
         SUBSTR(ens.description, 1, 400) AS description,
         ens.external_database_release_id,
         SUBSTR(ens.chromosome, 1, 40) AS chromosome,
         ens.chromosome_order_num, ens.sequence_ontology_id
  FROM dots.ExternalNaSequence ens, sres.SequenceOntology so
  WHERE ens.sequence_ontology_id = so.sequence_ontology_id
    AND so.term_name != 'EST'
    AND -- see both? use the VirtualSequence.
        ens.source_id IN (SELECT source_id FROM dots.ExternalNaSequence
                         MINUS
                          SELECT source_id FROM dots.VirtualSequence)
UNION
  SELECT na_sequence_id, taxon_id, SUBSTR(source_id, 1, 50) AS source_id,
         LOWER(SUBSTR(source_id, 1, 50)) AS lowercase_source_id,
         a_count, c_count, g_count, t_count, length,
         SUBSTR(description, 1, 400) AS description,
         external_database_release_id, SUBSTR(chromosome, 1, 40) AS chromosome,
         chromosome_order_num, sequence_ontology_id
  FROM dots.VirtualSequence
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GS_sourceId&1 ON apidb.GenomicSequence&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GS_lcSourceId&1 ON apidb.GenomicSequence&1 (lowercase_source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GS_naSeqId&1 ON apidb.GenomicSequence&1 (na_sequence_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SequenceAttributes">
    <internalDependency name="apidb.GenomicSequence"/>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="dots.SequencePiece"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.SequenceAttributes&1 NOLOGGING AS
SELECT apidb.project_id(tn.name) as project_id,
       SUBSTR(sequence.source_id, 1, 60) AS source_id, sequence.a_count,
       sequence.c_count, sequence.g_count, sequence.t_count,
       (sequence.length
        - (sequence.a_count + sequence.c_count + sequence.g_count + sequence.t_count))
         AS other_count,
       sequence.length,
       to_char((sequence.a_count + sequence.t_count) / sequence.length * 100, '99.99')
         AS at_percent,
       SUBSTR(tn.name, 1, 40) AS organism,
       taxon.ncbi_tax_id,
       SUBSTR(sequence.description, 1, 400) AS sequence_description,
       SUBSTR(genbank.genbank_accession, 1, 20) AS genbank_accession,
       SUBSTR(db.database_version, 1, 30) AS database_version, db.database_name,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.chromosome_order_num, so.so_id,
       nvl(virtualization.is_top_level, 1) as is_top_level,
       sequence.na_sequence_id
FROM sres.TaxonName tn, sres.Taxon, sres.SequenceOntology so,
     apidb.GenomicSequence sequence,
     (SELECT drns.na_sequence_id, max(dr.primary_identifier) AS genbank_accession
      FROM dots.dbrefNaSequence drns, sres.DbRef dr,
           sres.ExternalDatabaseRelease gb_edr, sres.ExternalDatabase gb_ed
      WHERE drns.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
            = gb_edr.external_database_release_id
        AND gb_edr.external_database_id = gb_ed.external_database_id
        AND gb_ed.name = 'GenBank'
      GROUP BY drns.na_sequence_id) genbank,
     (SELECT edr.external_database_release_id,
             edr.version AS database_version, ed.name AS database_name
      FROM sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      WHERE edr.external_database_id = ed.external_database_id) db,
     (SELECT piece_na_sequence_id, 0 as is_top_level
      FROM dots.SequencePiece) virtualization
WHERE sequence.taxon_id = tn.taxon_id(+)
  AND tn.name_class = 'scientific name'
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.sequence_ontology_id = so.sequence_ontology_id
  AND so.term_name IN ('chromosome', 'contig', 'supercontig','mitochondrial_chromosome','plastid_sequence')
  AND sequence.na_sequence_id = genbank.na_sequence_id(+)
  AND sequence.external_database_release_id = db.external_database_release_id(+)
  AND sequence.na_sequence_id = virtualization.piece_na_sequence_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.SeqAttr_source_id&1 ON apidb.SequenceAttributes&1 (source_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SnpAttributes">
    <internalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.SnpAttributes&1 NOLOGGING AS
SELECT apidb.project_id(tn.name) as project_id,
       snp.source_id,
       snp.na_feature_id,
       CASE WHEN ed.name = 'Su SNPs' THEN 'NIH SNPs'
       ELSE ed.name END AS dataset,
       CASE WHEN ed.name = 'Su SNPs' THEN 'Su_SNPs'
       WHEN ed.name = 'Broad SNPs' THEN 'Broad_SNPs'
       WHEN ed.name = 'Sanger falciparum SNPs' THEN 'sangerItGhanaSnps'
       WHEN ed.name = 'Sanger reichenowi SNPs' THEN 'sangerReichenowiSnps'
       WHEN ed.name = 'PlasmoDB combined SNPs' THEN 'plasmoDbCombinedSnps'
       WHEN ed.name = 'Winzeler Array - Plasmodium Genetic Variation' THEN 'WinzelerGeneticVariationArray'
       WHEN ed.name = 'Genomic Sequence SNPs' THEN 'AmitAlignmentSnps'
       WHEN ed.name = 'Genetic Markers - David Sibley' THEN 'GeneticMarkers_Sibley'
       WHEN ed.name = 'John Boothroyd lab at Stanford' THEN 'ME49_SNPs'
       WHEN ed.name = 'Lindstrom 454 SNPs' THEN 'Lindstrom454Snps'
       END AS dataset_hidden,
       sequence.na_sequence_id,
       sequence.source_id AS seq_source_id,
       snp_loc.start_min,
       SUBSTR(snp.reference_strain, 1, 200) AS reference_strain,
       SUBSTR(snp.reference_na, 1, 200) AS reference_na,
       DECODE(snp.is_coding, 0, 'no', 1, 'yes') AS is_coding,
       snp.position_in_CDS,
       snp.position_in_protein,
       SUBSTR(snp.reference_aa, 1, 200) AS reference_aa,
       DECODE(snp.has_nonsynonymous_allele, 0, 'no', 1, 'yes')
         AS has_nonsynonymous_allele,
       SUBSTR(snp.major_allele, 1, 40) AS major_allele,
       SUBSTR(snp.major_product, 1, 40) AS major_product,
       SUBSTR(strain_info.minor_allele, 1, 40) AS minor_allele,
       SUBSTR(strain_info.minor_product, 1, 40) AS minor_product,
       strain_info.major_strains,strain_info.minor_strains,
       snp.major_allele_count, 
       round(snp.major_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as major_allele_frequency,
       snp.minor_allele_count,
       round(snp.minor_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as minor_allele_frequency,
       snp.major_allele_count + snp.minor_allele_count as strain_count,
       SUBSTR(snp.strains, 1, 1000) AS strains,
       SUBSTR(snp.strains_revcomp, 1, 1000) AS strains_revcomp,
       gene_info.source_id AS gene_source_id,
       DECODE(gene_info.is_reversed, 0, 'forward', 1, 'reverse')
         AS gene_strand,
       SUBSTR(DBMS_LOB.SUBSTR(sequence.sequence, 60, snp_loc.start_min - 60), 1, 60)
         AS lflank,
       SUBSTR(DBMS_LOB.SUBSTR(sequence.sequence, 60, snp_loc.start_min + 1), 1, 60)
         AS rflank,
       SUBSTR(tn.name, 1, 40) AS organism,
       taxon.ncbi_tax_id,
       SUBSTR(chromosome_info.chromosome, 1, 20) AS chromosome,
       chromosome_info.chromosome_order_num
FROM dots.SnpFeature snp, apidb.FeatureLocation snp_loc,
     sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, sres.Taxon,
     sres.TaxonName tn, dots.NaSequence sequence,
     (SELECT gene.source_id, gene_loc.is_reversed, gene.na_feature_id,
             gene_loc.na_sequence_id
      FROM dots.GeneFeature gene, apidb.FeatureLocation gene_loc
      WHERE gene.na_feature_id = gene_loc.na_feature_id
            and gene_loc.is_top_level = 1) gene_info,
     (SELECT na_sequence_id, chromosome, chromosome_order_num
      FROM dots.ExternalNaSequence
     UNION
      SELECT na_sequence_id, chromosome, chromosome_order_num
      FROM dots.VirtualSequence
     UNION
      SELECT na_sequence_id, null as chromosome, null as chromosome_order_num
      FROM dots.NaSequence
      WHERE subclass_view not in ('ExternalNASequence', 'VirtualSequence')
     ) chromosome_info,
     (select sf.na_feature_id, 
             apidb.tab_to_string(CAST(COLLECT(distinct CASE WHEN sv.allele != sf.major_allele THEN sv.allele END) AS apidb.varchartab), ', ') as minor_allele,                
             apidb.tab_to_string(CAST(COLLECT(distinct CASE WHEN sv.allele != sf.major_allele THEN sv.product END) AS apidb.varchartab), ', ') as minor_product,
             apidb.tab_to_string(CAST(COLLECT(CASE WHEN sv.allele != sf.major_allele THEN sv.strain END) AS apidb.varchartab), ', ') as minor_strains,
             apidb.tab_to_string(CAST(COLLECT(CASE WHEN sv.allele = sf.major_allele THEN sv.strain END) AS apidb.varchartab), ', ') as major_strains
      from dots.SNPFEATURE sf, dots.SEQVARIATION sv
      where sv.parent_id = sf.na_feature_id
      group by sf.na_feature_id) strain_info
WHERE edr.external_database_release_id = snp.external_database_release_id
  AND ed.external_database_id = edr.external_database_id
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
  AND snp_loc.na_feature_id = snp.na_feature_id
  AND snp_loc.is_top_level = 1
  AND sequence.na_sequence_id = snp_loc.na_sequence_id
  AND chromosome_info.na_sequence_id = snp_loc.na_sequence_id
  and strain_info.na_feature_id = snp.na_feature_id
  AND gene_info.na_feature_id(+) = snp.parent_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.SnpAttr_source_id&1 ON apidb.SnpAttributes&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create INDEX apidb.Snp_nafeat_dataset_ix&1
       ON apidb.SnpAttributes&1 (na_feature_id, dataset)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Snp_Seq_ix&1
       ON apidb.SnpAttributes&1 (na_sequence_id, dataset, start_min, na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Snp_Freq_ix&1
       ON apidb.SnpAttributes&1 (dataset,strain_count,major_allele_frequency,minor_allele_frequency)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.OrfAttributes">
    <internalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="apidb.GenomicSequence"/>
    <externalDependency name="dots.AaFeatureImp"/>
    <externalDependency name="dots.AaSequenceImp"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.OrfAttributes&1 NOLOGGING AS
SELECT distinct
       apidb.project_id(tn.name) as project_id,
       SUBSTR(m.source_id, 1, 60) AS source_id,
       LOWER(SUBSTR(m.source_id, 1, 60)) AS lowercase_source_id,
       SUBSTR(tn.name, 1, 40) AS organism,
       taxon.ncbi_tax_id,
       SUBSTR(sequence.source_id, 1, 30) AS nas_id,
       tas.length,
       nl.start_min, nl.end_max, nl.is_reversed,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.chromosome_order_num, sequence.na_sequence_id
FROM dots.Miscellaneous m, dots.TranslatedAaFeature taaf,
     dots.TranslatedAaSequence tas, sres.Taxon, sres.TaxonName tn,
     sres.SequenceOntology so, apidb.FeatureLocation nl,
     -- subquery for sequence. Can't just use apidb.GenomicSequence,
     -- which only contains records eligible to be the result of a sequence search.
     -- ORFs can be on other sequences, such as ESTs in cryptodb.
     (  select gs.na_sequence_id, gs.source_id, gs.chromosome, gs.chromosome_order_num, gs.taxon_id
        from apidb.GenomicSequence gs
      union
        select ens.na_sequence_id, ens.source_id, ens.chromosome, ens.chromosome_order_num, ens.taxon_id
        from dots.ExternalNaSequence ens
        where ens.na_sequence_id in (select distinct na_sequence_id from dots.Miscellaneous
                                  minus select na_sequence_id
                                        from apidb.GenomicSequence)) sequence
WHERE m.na_feature_id = taaf.na_feature_id
  AND taaf.aa_sequence_id = tas.aa_sequence_id
  AND sequence.na_sequence_id = nl.na_sequence_id
  AND sequence.taxon_id = tn.taxon_id
  AND sequence.taxon_id = taxon.taxon_id
  AND m.sequence_ontology_id = so.sequence_ontology_id
  AND m.na_feature_id = nl.na_feature_id
  AND nl.is_top_level = 1
  AND so.term_name = 'ORF'
  AND tn.name_class='scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.OrfAttr_source_id&1 ON apidb.OrfAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.OrfAttr_location_idx&1 ON apidb.OrfAttributes&1 (na_sequence_id, start_min, end_max, is_reversed)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.EstAttributes">
    <externalDependency name="dots.AssemblySequence"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.Est"/>
    <externalDependency name="dots.Library"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.EstAttributes&1 NOLOGGING AS
SELECT apidb.project_id(tn.name) as project_id,
       ens.source_id,
       e.seq_primer AS primer,
       ens.a_count,
       ens.c_count,
       ens.g_count,
       ens.t_count,
       (ens.length - (ens.a_count + ens.c_count + ens.g_count + ens.t_count))
         AS other_count,
       ens.length,
       l.dbest_name,
       NVL(l.vector, 'unknown') AS vector,
       NVL(l.stage, 'unknown') AS stage,
       SUBSTR(CASE
                WHEN tn.name = 'Giardia lamblia' THEN 'Giardia Assemblage A isolate WB' 
                ELSE tn.name
              END, 1, 40) AS organism,
       taxon.ncbi_tax_id,
       ed.name AS external_db_name,
       nvl(best.best_alignment_count, 0) AS best_alignment_count,
       l.library_id, l.dbest_name as library_dbest_name,
       aseq.assembly_na_sequence_id, asm.source_id as assembly_source_id,
       asm.number_of_contained_sequences AS assembly_est_count
FROM dots.Est e, dots.ExternalNaSequence ens, dots.Library l, sres.Taxon,
     sres.TaxonName tn, sres.ExternalDatabase ed,
     sres.ExternalDatabaseRelease edr, sres.SequenceOntology so,
     dots.AssemblySequence aseq, dots.Assembly asm,
     (select query_na_sequence_id,max(ct) as best_alignment_count
      from (
            SELECT query_na_sequence_id, COUNT(*) AS ct
             FROM dots.BlatAlignment ba
             WHERE is_best_alignment = 1
             GROUP BY target_external_db_release_id,query_na_sequence_id)
      group by query_na_sequence_id) best
WHERE e.na_sequence_id = ens.na_sequence_id
  AND e.library_id = l.library_id
  AND ens.taxon_id = tn.taxon_id
  AND ens.taxon_id = taxon.taxon_id
  AND tn.name_class='scientific name'
  AND ens.external_database_release_id = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ens.sequence_ontology_id = so.sequence_ontology_id
  AND so.term_name = 'EST'
  AND best.query_na_sequence_id(+) = ens.na_sequence_id
  AND ens.na_sequence_id = aseq.na_sequence_id(+)
  AND aseq.assembly_na_sequence_id = asm.na_sequence_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.EstAttr_source_id&1 ON apidb.EstAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.EstAttr_seqsrc_id&1 ON apidb.EstAttributes&1 (assembly_source_id, source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.AssemblyAttributes">
    <externalDependency name="dots.Assembly"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.AssemblyAttributes&1 NOLOGGING AS
SELECT a.source_id, apidb.project_id(tn.name) as project_id,
       SUBSTR(CASE
                WHEN tn.name = 'Giardia lamblia' THEN 'Giardia Assemblage A isolate WB' 
                ELSE tn.name
              END, 1, 40) AS organism,
       a.number_of_contained_sequences AS est_count,
       a.length,
       a.a_count,
       a.c_count,
       a.g_count,
       a.t_count,
       a.other_count
FROM  dots.Assembly a, sres.TaxonName tn
WHERE a.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.AsmAttr_source_id&1
ON apidb.AssemblyAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.ArrayElementAttributes">
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.ArrayElementAttributes&1 NOLOGGING AS
SELECT apidb.project_id(tn.name) as project_id,
       ens.source_id, ed.name AS provider,
       tn.name AS organism,
       taxon.ncbi_tax_id
FROM sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr,
     dots.ExternalNaSequence ens, sres.TaxonName tn, sres.Taxon,
     sres.SequenceOntology so
WHERE ens.external_database_release_id = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND tn.taxon_id = ens.taxon_id
  AND tn.name_class = 'scientific name'
  AND taxon.taxon_id = ens.taxon_id
  AND ens.sequence_ontology_id = so.sequence_ontology_id
  AND so.term_name = 'oligo'
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.AEAttr_source_id&1
ON apidb.ArrayElementAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.BlatAlignmentLocation">
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="dots.blatalignment"/>

    <sql>
      <![CDATA[ 
     delete from dots.blatalignment 
           where query_na_sequence_id in 
                (select s.na_sequence_id
                from sres.externaldatabase d, sres.externaldatabaserelease r, dots.externalnasequence s
                where d.external_database_id = r.external_database_id
                 and s.external_database_release_id = r.external_database_release_id
                 and d.name in ('T.cruzi CHORI105 BAC End',
                                'T.brucei RPCI93 BAC Ends',
                                'L.major BAC Ends from Sanger',
                                'L.major PAC Ends from Sanger',
                                'L.major Cosmid Ends from Sanger')
            ) and is_best_alignment != 1
      ]]> 
    </sql>
    <sql>
      <![CDATA[ 
      CREATE TABLE apidb.BlatAlignmentLocation&1 NOLOGGING AS
      SELECT blat_alignment_id, query_na_sequence_id, target_na_sequence_id,
             query_table_id, query_taxon_id, query_external_db_release_id,
             target_table_id, target_taxon_id, target_external_db_release_id,
             is_consistent, is_genomic_contaminant, unaligned_3p_bases,
             unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
             is_5p_complete, percent_identity, max_query_gap, max_target_gap,
             number_of_spans, query_start, query_end, target_start, target_end,
             is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
             is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
             tstarts, cast('direct' as varchar2(7)) as location_mapping
      FROM dots.BlatAlignment
      ]]> 
    </sql>
    <perl>
      <![CDATA[ 
      use strict;
      use lib "$ENV{GUS_HOME}/lib/perl";

      my $sql = <<SQL;
        select blat_alignment_id, query_na_sequence_id, target_na_sequence_id,
               query_table_id, query_taxon_id, query_external_db_release_id, 
               target_table_id, target_taxon_id, target_external_db_release_id,
               is_consistent, is_genomic_contaminant, unaligned_3p_bases,
               unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
               is_5p_complete, percent_identity, max_query_gap, max_target_gap,
               number_of_spans, query_start, query_end, target_start, target_end,
               is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
               is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
               tstarts, sp.virtual_na_sequence_id, sp.distance_from_left,
               sp.strand_orientation, piece.length, vti.table_id as virtual_target_table_id
        from dots.BlatAlignment ba, apidb.SequencePieceClosure sp, dots.NaSequence piece,
             dots.NaSequence virtualseq, core.TableInfo vti
        where ba.target_na_sequence_id = sp.piece_na_sequence_id(+)
          and sp.piece_na_sequence_id = piece.na_sequence_id
          and sp.virtual_na_sequence_id = virtualseq.na_sequence_id
          and virtualseq.subclass_view = vti.name
SQL
      
      my $queryHandle = $dbh->prepare($sql);
      $queryHandle->execute();

      $sql = <<SQL;
        insert into apidb.BlatAlignmentLocation&1(blat_alignment_id,
               query_na_sequence_id, target_na_sequence_id,
               query_table_id, query_taxon_id, query_external_db_release_id, 
               target_table_id, target_taxon_id, target_external_db_release_id,
               is_consistent, is_genomic_contaminant, unaligned_3p_bases,
               unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
               is_5p_complete, percent_identity, max_query_gap, max_target_gap,
               number_of_spans, query_start, query_end, target_start, target_end,
               is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
               is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
               tstarts, location_mapping)
         values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?)
SQL

      my $insertHandle = $dbh->prepare($sql);
      my ($virtual_target_start, $virtual_target_end, $virtual_tstarts);

      while (my ($blat_alignment_id, $query_na_sequence_id, $target_na_sequence_id,
               $query_table_id, $query_taxon_id, $query_external_db_release_id,
               $target_table_id, $target_taxon_id, $target_external_db_release_id,
               $is_consistent, $is_genomic_contaminant, $unaligned_3p_bases,
               $unaligned_5p_bases, $has_3p_polya, $has_5p_polya, $is_3p_complete,
               $is_5p_complete, $percent_identity, $max_query_gap, $max_target_gap,
               $number_of_spans, $query_start, $query_end, $target_start, $target_end,
               $is_reversed, $query_bases_aligned, $repeat_bases_aligned, $num_ns, $score,
               $is_best_alignment, $blat_alignment_quality_id, $blocksizes, $qstarts,
               $tstarts, $virtual_na_sequence_id, $distance_from_left,
               $strand_orientation, $length, $virtual_target_table_id)
             = $queryHandle->fetchrow_array()) {

        if ($virtual_na_sequence_id) {
          if ($strand_orientation eq '-') {
            $virtual_target_start = $distance_from_left + $length - $target_end + 1;
            $virtual_target_end = $distance_from_left + $length - $target_start + 1;
            $virtual_tstarts = &getReversedTstarts($distance_from_left,$length,$tstarts,$blocksizes);
          } else {
            $virtual_target_start = $target_start + $distance_from_left;
            $virtual_target_end = $target_end + $distance_from_left;
            $virtual_tstarts = join( ',', map{ $_ + $distance_from_left } split( /,/, $tstarts));
          }

          # insert virtual locations
          $insertHandle->execute($blat_alignment_id,
                 $query_na_sequence_id, $virtual_na_sequence_id,
                 $query_table_id, $query_taxon_id, $query_external_db_release_id,
                 $virtual_target_table_id, $target_taxon_id, $target_external_db_release_id,
                 $is_consistent, $is_genomic_contaminant, $unaligned_3p_bases,
                 $unaligned_5p_bases, $has_3p_polya, $has_5p_polya, $is_3p_complete,
                 $is_5p_complete, $percent_identity, $max_query_gap, $max_target_gap,
                 $number_of_spans, $query_start, $query_end, $virtual_target_start,
                 $virtual_target_end,
                 $is_reversed, $query_bases_aligned, $repeat_bases_aligned, $num_ns, $score,
                 $is_best_alignment, $blat_alignment_quality_id, $blocksizes, $qstarts,
                 $virtual_tstarts, 'virtual');
        }
      }

      $insertHandle->finish();
      $queryHandle->finish();

sub getReversedTstarts {
  my($dfl,$len,$tstart,$blocksizes) = @_;
  my @ts = split(',',$tstart);
  my @bs = split(',',$blocksizes);
  my @new;
  for(my $a = scalar(@ts) - 1;$a >= 0;$a--){
    push(@new,($dfl + $len - $ts[$a] - $bs[$a] + 2));
  }
  return join(',',@new);
}
      ]]> 
    </perl>
  </tuningTable>

  <tuningTable name="apidb.EstAlignmentGeneSummary">
    <internalDependency name="apidb.GenomicSequence"/>
    <internalDependency name="apidb.GeneAttributes"/>
    <internalDependency name="apidb.BlatAlignmentLocation"/>
    <externalDependency name="dots.AssemblySequence"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.Est"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.SequenceOntology"/>
    <intermediateTable name="apidb.EstAlignmentGene"/>
    <intermediateTable name="apidb.EstAlignmentNoGene"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.EstAlignmentGene NOLOGGING AS
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, e.accession,
         e.library_id, ba.query_taxon_id, ba.target_na_sequence_id,
         ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
         ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
         sequence.source_id AS target_sequence_source_id,
         least(ba.target_end, ga.end_max)
         - greatest(ba.target_start, ga.start_min) + 1
           AS est_gene_overlap_length,
         ba.query_bases_aligned / (query_sequence.length)
         * 100 AS percent_est_bases_aligned,
         ga.source_id AS gene
  FROM apidb.BlatAlignmentLocation ba, dots.est e, dots.AssemblySequence aseq,
       apidb.GeneAttributes ga, apidb.GenomicSequence sequence,
       dots.NaSequence query_sequence, sres.SequenceOntology so
  WHERE e.na_sequence_id = ba.query_na_sequence_id
    AND aseq.na_sequence_id = ba.query_na_sequence_id
    AND sequence.na_sequence_id = ba.target_na_sequence_id
    AND ga.sequence_id = sequence.source_id
    AND least(ba.target_end, ga.end_max) - greatest(ba.target_start, ga.start_min) >= 0
    AND query_sequence.na_sequence_id = ba.query_na_sequence_id
    AND query_sequence.sequence_ontology_id = so.sequence_ontology_id
    AND so.term_name = 'EST'
    AND ba.target_na_sequence_id = sequence.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.EstAlignmentNoGene NOLOGGING AS
SELECT * from EstAlignmentGene WHERE 1=0 UNION -- define datatype for null column
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, e.accession,
       e.library_id, ba.query_taxon_id, ba.target_na_sequence_id,
       ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
       ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
       sequence.source_id AS target_sequence_source_id,
       NULL AS est_gene_overlap_length,
       ba.query_bases_aligned / (query_sequence.length)
       * 100 AS percent_est_bases_aligned,
       NULL AS gene
FROM dots.blatalignment ba, dots.est e, dots.AssemblySequence aseq,
     dots.NaSequence sequence, dots.NaSequence query_sequence
WHERE e.na_sequence_id = ba.query_na_sequence_id
  AND e.na_sequence_id = query_sequence.na_sequence_id
  AND aseq.na_sequence_id = ba.query_na_sequence_id
  AND ba.target_na_sequence_id = sequence.na_sequence_id
  AND ba.blat_alignment_id IN
   ( -- set of blat_alignment_ids not in in first leg of UNION
    -- (because they overlap no genes)
    SELECT ba.blat_alignment_id
    FROM dots.BlatAlignment ba, dots.NaSequence query_sequence,
         sres.SequenceOntology so
    WHERE query_sequence.na_sequence_id = ba.query_na_sequence_id
      AND query_sequence.sequence_ontology_id = so.sequence_ontology_id
      AND so.term_name = 'EST'
  MINUS
    SELECT blat_alignment_id FROM apidb.EstAlignmentGene)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE EstAlignmentGeneSummary&1 NOLOGGING AS
SELECT * FROM apidb.EstAlignmentNoGene
UNION
SELECT * FROM apidb.EstAlignmentGene
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.EstSumm_libOverlap_ix&1
             ON apidb.EstAlignmentGeneSummary&1
                (library_id, percent_identity, is_consistent,
                 est_gene_overlap_length, percent_est_bases_aligned)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.EstSumm_estSite_ix&1
             ON apidb.EstAlignmentGeneSummary&1
                (target_sequence_source_id, target_start, target_end,
                 library_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.FeatureSo">
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="sres.SequenceOntology"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.FeatureSo&1 NOLOGGING AS
  SELECT t.na_feature_id, so.sequence_ontology_id, so.term_name
  FROM dots.NaFeature gf, dots.NaFeature t, sres.SequenceOntology so
  WHERE  gf.na_feature_id =  t.parent_id
  AND gf.sequence_ontology_id = so.sequence_ontology_id
UNION
  SELECT na_feature_id, so.sequence_ontology_id, so.term_name
  FROM dots.Miscellaneous misc, sres.SequenceOntology so
  WHERE misc.sequence_ontology_id = so.sequence_ontology_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX featso_id_ix&1 ON apidb.FeatureSo&1(na_feature_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.Polymorphism">
    <internalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="dots.SnpFeature"/>
    <externalDependency name="dots.SeqVariation"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.Polymorphism&1 NOLOGGING AS
  SELECT snp.na_feature_id AS snp_na_feature_id, fl.na_sequence_id,
         fl.start_min AS start_min,
         substr(snp.source_id, 1, 25) AS snp_source_id,
         snp.position_in_protein,
         sa.na_feature_id as na_feature_id_a,
         sb.na_feature_id as na_feature_id_b,
         substr(sa.strain, 1, 12) AS strain_a,
         substr(sb.strain, 1, 12) AS strain_b,
         substr(sa.allele, 1, 1) AS allele_a,
         substr(sb.allele, 1, 1) AS allele_b,
         substr(sa.product, 1, 1) AS product_a,
         substr(sb.product, 1, 1) AS product_b,
         snp.external_database_release_id,
         snp.parent_id as gene_na_feature_id,
         nl.is_reversed as gene_is_reversed, gf.source_id as gene_source_id
  FROM dots.SnpFeature snp, dots.SeqVariation sa, dots.SeqVariation sb,
       apidb.FeatureLocation fl, apidb.featurelocation nl, dots.GeneFeature gf
  WHERE sa.strain < sb.strain
    AND sa.allele != sb.allele
    AND sa.parent_id = sb.parent_id
    AND sa.parent_id = snp.na_feature_id
    AND sa.na_feature_id = fl.na_feature_id
    AND snp.parent_id = nl.na_feature_id (+)
    AND snp.parent_id = gf.na_feature_id (+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX polymorphism_ix&1 ON apidb.Polymorphism&1(na_sequence_id, strain_a, strain_b, start_min)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX polymorphism_loc_ix&1
ON apidb.Polymorphism&1(external_database_release_id, na_sequence_id, strain_a, strain_b, start_min)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.IsolateAttributes">
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.IsolateAttributes&1 NOLOGGING AS
select na_sequence_id, taxon_id,
       external_db_version,
       external_db_name,
       na_feature_id,
       source_id,
       decode(organism, null, 'Unknown', substr(organism, 1, 100)) as organism,
       decode(strain, null, 'Unknown', substr(strain, 1, 100)) as strain,
       decode(specific_host, null, 'Unknown', substr(specific_host, 1, 100)) as specific_host,
       decode(isolation_source, null, 'Unknown', substr(isolation_source, 1, 200)) as isolation_source,
       decode(country, null, 'Unknown', substr(country, 1, 200)) as country,
       substr(note, 1, 400) as note,
       substr(description, 1, 400) as description,
       substr(pcr_primers, 1, 100) as pcr_primers,       
       length,
       is_reference,
       collected_by,
       decode(product, null, 'Unknown', substr(product, 1, 500)) as product,
       decode(product_alias, null, 'Unknown', substr(product_alias, 1, 500)) as product_alias,
       project_id,
       data_type
FROM (
   select iso.*,
       prod.product,
       prod.product_alias
   from (SELECT etn.na_sequence_id, etn.taxon_id,etn.length,
        edr.version as external_db_version, src.na_feature_id,
        edb.name as external_db_name,
        CASE WHEN etn.source_id is null THEN decode(edb.name, 'Broad 75K genotyping chip', 'CPHD.'||etn.na_sequence_id, 
        'Broad 3K genotyping chip', 'CP3.'||etn.na_sequence_id,
        'Isolate barcode data from Broad','BC.'||etn.na_sequence_id,etn.source_id)
        ELSE etn.source_id END as source_id,
        tn.name as organism,
        CASE WHEN src.strain != src.isolate THEN src.strain || ' ' || src.isolate 
             WHEN src.strain is  not null THEN src.strain ELSE src.isolate END as strain,
        src.specific_host as specific_host,
        src.isolation_source as isolation_source,
        src.country as country,
        src.note as note,
        etn.description as description,
        src.pcr_primers as pcr_primers,
        src.is_reference,
        src.collected_by,
        decode(edb.name, 'Broad 75K genotyping chip', 'HD_Array', 
        'Broad 3K genotyping chip', '3kChip',
        'Toxoplasma RFLPs from Chunlei Su', 'RFLP Typed',
        'Isolate barcode data from Broad','Barcode','Sequencing Typed') as data_type,
        CASE WHEN lower(pinfo.name) like 'plas%' THEN 'PlasmoDB' 
             WHEN lower(pinfo.name) like 'cryp%' THEN 'CryptoDB'
             WHEN lower(pinfo.name) like 'toxo%' THEN 'ToxoDB'
             WHEN lower(pinfo.name) like 'giard%' THEN 'GiardiaDB'
             WHEN lower(pinfo.name) like 'tritryp%' THEN 'TriTrypDB'
        ELSE '' END as project_id
      FROM dots.ExternalNaSequence etn, dots.IsolateSource src, Sres.taxonname tn,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase edb, core.PROJECTINFO pinfo
      WHERE etn.na_sequence_id = src.na_sequence_id
       AND etn.taxon_id = tn.taxon_id
       AND tn.name_class = 'scientific name'
       AND edr.external_database_id = edb.external_database_id
       AND edr.external_database_release_id = etn.external_database_release_id
       AND pinfo.project_id = etn.row_project_id
      ) iso
   left join (select na_sequence_id, 
               apidb.tab_to_string(CAST(COLLECT(product) AS apidb.varchartab),'; ') as product, 
               apidb.tab_to_string(CAST(COLLECT(product_alias) AS apidb.varchartab),'; ') as product_alias 
               from dots.isolatefeature group by na_sequence_id) prod
           on prod.na_sequence_id = iso.na_sequence_id
       )
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.IsolateAttr_sourceId_idx&1 ON apidb.IsolateAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

 <tuningTable name="apidb.ChIPProtocolParams">
    <externalDependency name="rad.Analysis"/>
    <externalDependency name="rad.AnalysisParam"/>
    <externalDependency name="rad.ProtocolParam"/>
    <sql>
      <![CDATA[
        create table apidb.ChIPProtocolParams&1 NOLOGGING AS
select a.analysis_id,
       a.protocol_id,
       antbd.antibody as antibody,
       strn.strain as strain,
       treamnt.treatment as treatment,
       replcte.replicate as replicate,
       gentyp.genotype as genotype,
       celltyp.celltype as celltype,
       CASE
          WHEN lower(p.name) like '%peak%' then 'called_peaks'
       ELSE 'raw'
       END as protocol_type
from   rad.analysis a,rad.protocol p,
      (select ap.analysis_id,ap.value as antibody
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'antibody') antbd,
      (select ap.analysis_id,ap.value as strain
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'strain') strn,
      (select ap.analysis_id,ap.value as treatment
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'treatment') treamnt,
      (select ap.analysis_id,ap.value as replicate
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'replicate') replcte,
      (select ap.analysis_id,ap.value as genotype
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'genotype') gentyp,
      (select ap.analysis_id,ap.value as celltype
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'celltype') celltyp
where a.protocol_id = p.protocol_id
and   a.analysis_id = antbd.analysis_id (+)
and   a.analysis_id = strn.analysis_id (+)
and   a.analysis_id = treamnt.analysis_id (+)
and   a.analysis_id = replcte.analysis_id (+)
and   a.analysis_id = gentyp.analysis_id (+)
and   a.analysis_id = celltyp.analysis_id (+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
       CREATE INDEX apidb.chp_prtparam_idx&1 ON apidb.chipprotocolparams&1 (analysis_id,protocol_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="apidb.ChIPchipGene">
    <internalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="apidb.GeneAttributes"/>
    <internalDependency name="apidb.SequenceAttributes"/>
    <sql>
      <![CDATA[
        create table apidb.chipchipgene&1 NOLOGGING AS
select distinct
      ga.source_id as gene_source_id,
      aef.source_id as probe_id,
      aef.na_feature_id as chip_na_feature_id,
      CASE WHEN ga.is_reversed = 0 THEN round(abs(ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0)
              ELSE round(abs(ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0) END as distance,
         CASE WHEN CASE WHEN ga.is_reversed = 0 THEN round(abs(ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0)
                        ELSE round(abs(ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0) END > 0 THEN 
              CASE WHEN ga.is_reversed = 0 THEN '-' ELSE '+' END ELSE 
              CASE WHEN ga.is_reversed = 1 THEN '-' ELSE '+' END END as direction
from  dots.ArrayElementFeature aef,
      apidb.FeatureLocation arrloc,
      apidb.geneattributes ga,
      sres.externaldatabase ed,
      sres.externaldatabaserelease edr
where aef.na_feature_id = arrloc.na_feature_id
and   arrloc.external_database_release_id = edr.external_database_release_id
and   edr.external_database_id = ed.external_database_id
and   lower(ed.name) like '%peak%'
and   arrloc.na_sequence_id = ga.na_sequence_id
and   ( (ga.is_reversed = 0 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.start_min) <= 3000)
                  or (ga.is_reversed = 1 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.end_max) <= 3000) )
     ]]>
    </sql>
    <sql>
      <![CDATA[
       CREATE INDEX apidb.chpgene_geneid_idx&1 ON apidb.chipchipgene&1 (gene_source_id, chip_na_feature_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>



  <tuningTable name="apidb.SageTagAttributes">
    <internalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="apidb.SageTagGene"/>
    <internalDependency name="apidb.GeneAttributes"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="rad.CompositeElementImp"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.SageTagAttributes&1 NOLOGGING AS
SELECT apidb.project_id(tn.name) as project_id,
       substr(s.source_id || '-' || l.start_min || '-' || l.end_max || '.'
              || l.is_reversed, 1, 40) as source_id,
       f.na_feature_id, f.source_id as feature_source_id,
       substr(s.source_id, 1, 40) as sequence_source_id, s.na_sequence_id,
       l.start_min, l.end_max, substr(st.tag, 1, 20) as sequence,
       st.composite_element_id, st.source_id as rad_source_id,
       l.is_reversed,
       SUBSTR(CASE
                WHEN tn.name = 'Giardia lamblia' THEN 'Giardia Assemblage A isolate WB' 
                ELSE tn.name
              END, 1, 60) AS organism,
       gene.gene_source_id, nvl(gene.gene_count, 0) gene_count,
       gene.gene_product
from dots.SageTagFeature f, apidb.FeatureLocation l, dots.NaSequence s,
     sres.TaxonName tn, rad.SageTag st,
     (select a.na_feature_id,
             apidb.tab_to_string(CAST(COLLECT(b.gene_source_id) AS apidb.varchartab),'; ') as gene_source_id,
             apidb.tab_to_string(CAST(COLLECT(ga.product) AS apidb.varchartab),'; ') as gene_product,
             count(b.gene_source_id) as gene_count
      from dots.sagetagfeature a, (
                             select distinct a.na_feature_id,
                                            sg.gene_source_id as gene_source_id
                             from dots.SageTagFeature a left join apidb.SageTagGene sg on a.na_feature_id = sg.tag_feature_id
                             where (sg.distance = 0 or sg.distance is null)
                             and (sg.antisense = 0 or sg.antisense is null)
                             ) b, apidb.GeneAttributes ga
       where a.na_feature_id = b.na_feature_id
        and b.gene_source_id = ga.source_id
       group by a.na_feature_id
      ) gene
where f.na_feature_id = gene.na_feature_id (+)
  and f.na_feature_id = l.na_feature_id
  and l.is_top_level = 1
  and s.na_sequence_id = l.na_sequence_id
  and s.taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
  and f.source_id = st.composite_element_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.SageTagAttr_sourceId_idx&1 ON apidb.SageTagAttributes&1
             (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SageTagAttr_loc_idx&1 ON apidb.SageTagAttributes&1
             (na_sequence_id, start_min, end_max, is_reversed, source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.AsmAlignmentGeneSummary">
    <internalDependency name="apidb.GeneAttributes"/>
    <internalDependency name="apidb.GenomicSequence"/>
    <internalDependency name="apidb.BlatAlignmentLocation"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.SequenceOntology"/>
    <intermediateTable name="apidb.AsmAlignmentGene"/>
    <intermediateTable name="apidb.AsmAlignmentNoGene"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.AsmAlignmentGene NOLOGGING AS
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, a.source_id, a.number_of_contained_sequences AS est_count, a.length,
         ba.query_taxon_id, ba.target_na_sequence_id,
         ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
         ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
         sequence.source_id AS target_sequence_source_id,
         least(ba.target_end, ga.end_max)
         - greatest(ba.target_start, ga.start_min) + 1
           AS assembly_gene_overlap_length,
         ba.query_bases_aligned / (a.length)
         * 100 AS percent_assembly_bases_aligned,
         ga.source_id AS gene
  FROM dots.assembly a, 
       apidb.BlatAlignmentLocation ba,
       apidb.GeneAttributes ga, 
       apidb.GenomicSequence sequence
  WHERE ba.query_na_sequence_id = a.na_sequence_id 
   AND ba.target_na_sequence_id = sequence.na_sequence_id
   AND ga.sequence_id = sequence.source_id
   AND least(ba.target_end, ga.end_max) - greatest(ba.target_start, ga.start_min) >= 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.AsmAlignmentNoGene NOLOGGING AS
SELECT * from AsmAlignmentGene WHERE 1=0 UNION -- define datatype for null column
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, a.source_id, a.number_of_contained_sequences AS est_count, a.length,
         ba.query_taxon_id, ba.target_na_sequence_id,
         ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
         ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
         sequence.source_id AS target_sequence_source_id,
         NULL
           AS assembly_gene_overlap_length,
         ba.query_bases_aligned / (a.length)
         * 100 AS percent_assembly_bases_aligned,
         NULL AS gene
  FROM dots.blatalignment ba, dots.assembly a,
      dots.NaSequence sequence
  WHERE a.na_sequence_id = ba.query_na_sequence_id
    AND sequence.na_sequence_id = ba.target_na_sequence_id
    AND ba.blat_alignment_id IN
   ( -- set of blat_alignment_ids not in in first leg of UNION
    -- (because they overlap no genes)
    SELECT ba.blat_alignment_id
    FROM dots.BlatAlignment ba, dots.NaSequence query_sequence,
         sres.SequenceOntology so
    WHERE query_sequence.na_sequence_id = ba.query_na_sequence_id
      AND query_sequence.sequence_ontology_id = so.sequence_ontology_id
      AND so.term_name = 'assembly'
  MINUS
    SELECT blat_alignment_id FROM apidb.AsmAlignmentGene)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE AsmAlignmentGeneSummary&1 NOLOGGING AS
SELECT * FROM apidb.AsmAlignmentNoGene
UNION
SELECT * FROM apidb.AsmAlignmentGene
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.PlasmoExpressionGraphs">
    <externalDependency name="apidb.Profile"/>
    <externalDependency name="apidb.ProfileSet"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.PlasmoExpressionGraphs&1 NOLOGGING AS
SELECT gf.source_id,
       COUNT(pf_rna_seq) AS graph_pf_rna_seq,
       COUNT(zb_pvivax) AS graph_zb_pvivax,
       COUNT(derisi_winzeler) AS graph_derisi_winzeler,
       COUNT(winzeler) AS graph_winzeler, COUNT(ThreeD7) AS graph_3d7,
       COUNT(HB3) AS graph_hb3, COUNT(Dd2) AS graph_dd2,
       COUNT(waters) AS graph_waters, COUNT(gametocyte) as graph_gametocyte,
       COUNT(cowman) AS graph_cowman, COUNT(mexp128) AS graph_mexp128,
       COUNT(mexp494) AS graph_mexp494, COUNT(kappe) as graph_kappe,
       COUNT(daily) as graph_daily,
       COUNT(newbold) as graph_newbold,
       COUNT(westenberger) as graph_westenberger,
       COUNT(winzeler_py_mixed) as graph_winzeler_py_mixed
FROM dots.GeneFeature gf,
     (SELECT p1.source_id, 1 AS derisi_winzeler
      FROM apidb.profile p1, apidb.profileSet ps1,
           apidb.profile p3, apidb.profileSet ps3,
           apidb.profile p5, apidb.profileSet ps5,
           apidb.profile p7, apidb.profileSet ps7
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND p3.profile_set_id = ps3.profile_set_id
        AND p5.profile_set_id = ps5.profile_set_id
        AND p7.profile_set_id = ps7.profile_set_id
        AND p1.source_id = p3.source_id
        AND p1.source_id = p5.source_id
        AND p1.source_id = p7.source_id
        AND ps1.name = 'DeRisi HB3 Smoothed Averaged'
        AND ps3.name = 'DeRisi 3D7 Smoothed Averaged'
        AND ps5.name = 'DeRisi Dd2 Smoothed Averaged'
        AND ps7.name = 'winzeler_cc_sorbExp') combo,
     (SELECT p1.source_id, 1 AS zb_pvivax
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND ps1.name = 'ZB Pvivax time series normalized_averaged 3') zbpvivax, 
     (SELECT p1.source_id, 1 AS pf_rna_seq
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND ps1.name = 'P.falciparum RNA Sequence Profiles') pfrnaseq, 
     (SELECT p1.source_id, 1 AS winzeler
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND ps1.name = 'winzeler_cc_sorbExp') winzeler,
     (SELECT p1.source_id, 1 AS threeD7
      FROM apidb.profile p1, apidb.profileSet ps1,
           apidb.profile p2, apidb.profileSet ps2,
           apidb.profile p3, apidb.profileSet ps3
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND p2.profile_set_id = ps2.profile_set_id
        AND p3.profile_set_id = ps3.profile_set_id
        AND p1.source_id = p2.source_id
        AND p1.source_id = p3.source_id
        AND ps1.name = 'DeRisi 3D7 Smoothed Averaged'
        AND ps2.name = 'DeRisi 3D7 Normalized repsCollapsed Averaged'
         AND ps3.name = 'DeRisi 3D7 Percents Averaged') threeD7,
     (SELECT p1.source_id, 1 AS HB3
      FROM apidb.profile p1, apidb.profileSet ps1,
           apidb.profile p2, apidb.profileSet ps2,
           apidb.profile p3, apidb.profileSet ps3
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND p2.profile_set_id = ps2.profile_set_id
        AND p3.profile_set_id = ps3.profile_set_id
        AND p1.source_id = p2.source_id
        AND p1.source_id = p3.source_id
        AND ps1.name = 'DeRisi HB3 Smoothed Averaged'
        AND ps2.name = 'DeRisi HB3 Normalized repsCollapsed Averaged'
         AND ps3.name = 'DeRisi HB3 Percents Averaged') HB3,
     (SELECT p1.source_id, 1 AS Dd2
      FROM apidb.profile p1, apidb.profileSet ps1,
           apidb.profile p2, apidb.profileSet ps2,
           apidb.profile p3, apidb.profileSet ps3
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND p2.profile_set_id = ps2.profile_set_id
        AND p3.profile_set_id = ps3.profile_set_id
        AND p1.source_id = p2.source_id
        AND p1.source_id = p3.source_id
        AND ps1.name = 'DeRisi Dd2 Smoothed Averaged'
        AND ps2.name = 'DeRisi Dd2 Normalized repsCollapsed Averaged'
         AND ps3.name = 'DeRisi Dd2 Percents Averaged') Dd2,
     (SELECT p1.source_id, 1 AS waters
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND ps1.name = 'Waters HPE Percents Averaged') waters,
     (SELECT p1.source_id, 1 AS gametocyte
      FROM apidb.profile p1, apidb.profileSet ps1,
           apidb.profile p2, apidb.profileSet ps2
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND p2.profile_set_id = ps2.profile_set_id
        AND p1.source_id = p2.source_id
        AND ps1.name = 'winzeler_NF54_gametocyte'
        AND ps2.name = 'winzeler_3D7_gametocyte') gametocyte,
    (SELECT p.source_id, 1 AS cowman
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'P.falciparum strain 3D7, SIR2 knockout'
        AND p.profile_set_id = ps.profile_set_id) cowman,
    (SELECT p.source_id, 1 AS mexp128
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'Expression profile of 3D7 clones 3D7AH1S2 and 3D7S8.4 at ring, trophozite and schizont stages.-Averaged'
        AND p.profile_set_id = ps.profile_set_id) mexp128,
    (SELECT p.source_id, 1 AS mexp494
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'Identification of genome wide gene copy number polymorphisms in Plasmodium falciparum'
        AND p.profile_set_id = ps.profile_set_id) mexp494,
    (SELECT p1.source_id, 1 AS kappe
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE ps1.name = 'kappe_fold_changes'
       AND p1.profile_set_id = ps1.profile_set_id) kappe,
    (SELECT p1.source_id, 1 AS daily
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE ps1.name = 'daily_age_percents'
       AND p1.profile_set_id = ps1.profile_set_id) daily,
    (SELECT p1.source_id, 1 AS newbold
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE ps1.name = 'newbold gene profiles sorted mild-severe'
       AND p1.profile_set_id = ps1.profile_set_id) newbold,
    (SELECT p1.source_id, 1 AS westenberger
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE ps1.name = 'westenberger vivax expression profile'
       AND p1.profile_set_id = ps1.profile_set_id) westenberger,
    (SELECT p1.source_id, 1 AS winzeler_py_mixed
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE ps1.name = 'winzeler py mixed RMAouput naturalscale'
       AND p1.profile_set_id = ps1.profile_set_id) winzeler_py_mixed
  WHERE gf.source_id = combo.source_id(+)
  AND gf.source_id = winzeler.source_id(+)
  AND gf.source_id = threeD7.source_id(+)
  AND gf.source_id = HB3.source_id(+)
  AND gf.source_id = Dd2.source_id(+)
  AND gf.source_id = waters.source_id(+)
  AND gf.source_id = gametocyte.source_id(+)
  AND gf.source_id = cowman.source_id(+)
  AND gf.source_id = mexp128.source_id(+)
  AND gf.source_id = mexp494.source_id(+)
  AND gf.source_id = kappe.source_id(+)
  AND gf.source_id = daily.source_id(+)
  AND gf.source_id = newbold.source_id(+)
  AND gf.source_id = zbpvivax.source_id(+)
  AND gf.source_id = pfrnaseq.source_id(+)
  AND gf.source_id = westenberger.source_id(+)
  AND gf.source_id = winzeler_py_mixed.source_id(+)
GROUP BY gf.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.PlasmoExp_sourceId_idx&1 ON apidb.PlasmoExpressionGraphs&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.ToxoExpressionGraphs">
    <internalDependency name="apidb.GeneAttributes"/>
    <externalDependency name="apidb.Profile"/>
    <externalDependency name="apidb.ProfileSet"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.ToxoExpressionGraphs&1 NOLOGGING AS
SELECT ga.source_id,
        COUNT(archetypal) AS graph_archetypal,
        COUNT(bradyzoite) AS graph_bradyzoite
FROM Apidb.GeneAttributes ga,
     (SELECT p.source_id, 1 AS archetypal
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'Expression profiling of the 3 archetypal T. gondii lineages'
        AND p.profile_set_id = ps.profile_set_id) archetypal,
        (SELECT p.source_id, 1 AS bradyzoite
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'expression profile percentiles of T. gondii Matt_Tz-Bz time series'
        AND p.profile_set_id = ps.profile_set_id) bradyzoite
  WHERE ga.source_id = archetypal.source_id(+)
  and ga.source_id = bradyzoite.source_id (+)
GROUP BY ga.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.ToxoExp_sourceId_idx&1 ON apidb.ToxoExpressionGraphs&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.GiardiaExpressionGraphs">
    <internalDependency name="apidb.GeneAttributes"/>
    <externalDependency name="apidb.Profile"/>
    <externalDependency name="apidb.ProfileSet"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GiardiaExpressionGraphs&1 NOLOGGING AS
SELECT ga.source_id,
       COUNT(stress) as graph_stress,
       COUNT(stress_ts) as graph_stress_ts,
       COUNT(sage_pct) as graph_sage_pct
FROM apidb.GeneAttributes ga,
     (SELECT p.source_id, 1 AS stress
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'Stress Response in Giardia lamblia Trophozoites-Averaged'
        AND p.profile_set_id = ps.profile_set_id) stress,
     (SELECT p.source_id, 1 AS stress_ts
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'Stress response Dynamics in Trophozoites (time series)-Averaged'
        AND p.profile_set_id = ps.profile_set_id) stress2,
     (SELECT p.source_id, 1 AS sage_pct
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'giar sage count'
        AND p.profile_set_id = ps.profile_set_id) sage
  WHERE ga.source_id = stress.source_id(+)
  AND ga.source_id = stress2.source_id(+)
  AND ga.source_id = sage.source_id(+)
GROUP BY ga.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.ExpGraphSum_sourceId_idx&1 ON apidb.GiardiaExpressionGraphs&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="apidb.TriTrypExpressionGraphs">
    <internalDependency name="apidb.GeneAttributes"/>
    <externalDependency name="apidb.Profile"/>
    <externalDependency name="apidb.ProfileSet"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.TriTrypExpressionGraphs&1 NOLOGGING AS
SELECT ga.source_id,
       COUNT(promastigote) as graph_infantum_promastigote
FROM apidb.GeneAttributes ga,
     (SELECT p.source_id, 1 AS promastigote
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'Lmajor promastigote time-course biorep01'
        AND p.profile_set_id = ps.profile_set_id) promastigote
  WHERE ga.source_id = promastigote.source_id(+)
GROUP BY ga.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.TrypExpGraph_sourceId_idx&1 ON apidb.TriTrypExpressionGraphs&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.NaSynteny">
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="dots.Similarity"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.NaSynteny&1 NOLOGGING AS
SELECT
    sim.similarity_id,
    extq.na_sequence_id query_na_sequence_id,
    extt.na_sequence_id target_na_sequence_id,
    extq.source_id query_source_id,
    extt.source_id target_source_id,
    sim.min_subject_start ,
    sim.max_subject_end ,
    sim.min_query_start ,
    sim.max_query_end,
    sim.is_reversed,
    sim.score,
    sim.pvalue_mant,
    sim.pvalue_exp
FROM
    dots.Similarity sim,
    dots.ExternalNaSequence extt,
    dots.ExternalNaSequence extq,
    core.TableInfo qtab,
    core.TableInfo stab
WHERE
    sim.query_id = extq.na_sequence_id and
    sim.subject_id = extt.na_sequence_id and
    sim.subject_table_id = stab.table_id and
    stab.name = 'ExternalNASequence'and
    sim.query_table_id  = qtab.table_id and
    qtab.name = 'ExternalNASequence'
UNION
SELECT
    sim.similarity_id,
    extt.na_sequence_id query_na_sequence_id,
    extq.na_sequence_id target_na_sequence_id,
    extt.source_id query_source_id,
    extq.source_id target_source_id,
    sim.min_query_start min_subject_start,
    sim.max_query_end max_subject_end,
    sim.min_subject_start min_query_start,
    sim.max_subject_end max_query_end,
    sim.is_reversed,
    sim.score,
    sim.pvalue_mant,
    sim.pvalue_exp
FROM
    dots.Similarity sim,
    dots.ExternalNaSequence extt,
    dots.ExternalNaSequence extq,
    core.TableInfo qtab,
    core.TableInfo stab
WHERE
    sim.query_id = extq.na_sequence_id and
    sim.subject_id = extt.na_sequence_id and
    sim.subject_table_id = stab.table_id and
    stab.name = 'ExternalNASequence'and
    sim.query_table_id  = qtab.table_id and
    qtab.name = 'ExternalNASequence'
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE BITMAP INDEX apidb.syn_query_ix&1 ON apidb.NaSynteny&1(query_na_sequence_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE BITMAP INDEX apidb.syn_target_ix&1 ON apidb.NaSynteny&1(target_na_sequence_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.Subcellular">
    <internalDependency name="apidb.GeneAttributes"/>
    <externalDependency name="dots.AaFeatureImp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.Subcellular&1 NOLOGGING AS
select ga.source_id, 'ht' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf, apidb.GeneAttributes ga
where ed.name = 'subcellular motif from Haldar'
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
  and paf.source_id = ga.source_id
union
select ga.source_id, 'pexel' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf, apidb.GeneAttributes ga
where ed.name = 'subcellular motif from Cowman'
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
  and paf.source_id = ga.source_id
union
select ga.source_id, 'apicoplast' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf, apidb.GeneAttributes ga
where ed.name = 'apicoplast targeting data from 4.4'
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
  and paf.source_id = ga.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.subc_ix&1 ON apidb.Subcellular&1(source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.Expression">
    <externalDependency name="apidb.Profile"/>
    <externalDependency name="apidb.ProfileElement"/>
    <externalDependency name="apidb.ProfileElementName"/>
    <externalDependency name="apidb.ProfileSet"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.Expression&1 NOLOGGING AS
  SELECT pct_p.source_id, pct_pe.value, pct_ps.name AS profile_set_name,
       pct_pe.element_order, pen.name AS element_name
  FROM apidb.ProfileSet pct_ps,
     apidb.Profile pct_p, apidb.ProfileElement pct_pe,apidb.ProfileElementName pen,
     apidb.ProfileSet exp_ps,
     apidb.Profile exp_p, apidb.ProfileElement exp_pe
  WHERE pct_ps.profile_set_id = pct_p.profile_set_id
  AND pct_p.profile_id = pct_pe.profile_id
  AND pct_ps.name like '%Pct'
  AND exp_ps.profile_set_id = exp_p.profile_set_id
  AND exp_p.profile_id = exp_pe.profile_id
  AND exp_pe.element_order = pct_pe.element_order
  AND exp_p.source_id = pct_p.source_id
  AND exp_ps.name = REPLACE(pct_ps.name, 'Pct', 'Exp')
  AND pct_ps.profile_set_id = pen.profile_set_id
  AND exp_pe.element_order = pen.element_order
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Exp_value_ix&1 ON apidb.Expression&1 (value, element_order, source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Exp_element_ix&1 ON apidb.Expression&1 (element_order, source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SnpSummary">
    <externalDependency name="dots.AaFeatureImp"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.SnpSummary&1 NOLOGGING AS
SELECT cds_length, na_feature_id, source_id,
       strain_a, strain_b,
       sum(synonymous) as synonymous,
       sum(non_synonymous) as non_synonymous,
       sum(non_coding) as non_coding,
       sum(stop) as stop,
       sum(non_coding) + sum(synonymous) + sum(non_synonymous) as total
FROM  (SELECT greatest(taf.translation_start, taf.translation_stop)
              - least(taf.translation_start, taf.translation_stop) + 1 AS cds_length,
              gf.na_feature_id, gf.source_id,
              edr.external_database_release_id,
              SUBSTR(sva.strain, 1, 30) AS strain_a,
              SUBSTR(svb.strain, 1, 30) AS strain_b,
              CASE WHEN sva.product IS NULL THEN 1 ELSE 0 END AS non_coding,
              CASE WHEN sva.product = svb.product THEN 1 ELSE 0 END AS synonymous,
              CASE WHEN sva.product != svb.product THEN 1 ELSE 0 END AS non_synonymous,
              CASE WHEN sva.product = '*' OR  svb.product = '*' THEN 1 ELSE 0 END AS stop
       FROM dots.SeqVariation sva, dots.SeqVariation svb, dots.SnpFeature sf,
            dots.SplicedNaSequence cds, dots.Transcript, dots.GeneFeature gf,
            dots.TranslatedAaFeature taf, sres.ExternalDatabase ed,
            sres.ExternalDatabaseRelease edr
       WHERE ed.name NOT IN ('Broad SNPs', 'Sanger falciparum SNPs',
                             'Su SNPs')
         AND sva.strain  < svb.strain
         AND sva.allele != svb.allele
         AND sva.parent_id = svb.parent_id
         AND sva.parent_id = sf.na_feature_id
         AND sf.parent_id = gf.na_feature_id
         AND sf.external_database_release_id = edr.external_database_release_id
         AND edr.external_database_id = ed.external_database_id
         AND gf.na_feature_id = transcript.parent_id
         AND transcript.na_sequence_id = cds.na_sequence_id
         AND transcript.na_feature_id = taf.na_feature_id
)
GROUP BY cds_length, na_feature_id, source_id,
         strain_a, strain_b
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SnpSummary_idx&1
       ON apidb.SnpSummary&1(na_feature_id, source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SnpSummary_strain_idx&1
       ON apidb.SnpSummary&1(strain_a, strain_b, source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SnpSummary_strainb_idx&1
       ON apidb.SnpSummary&1(strain_b, strain_a, source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SnpSummary_srcId_idx&1
       ON apidb.SnpSummary&1(source_id, na_feature_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.Scaffold_Map">
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="dots.SequencePiece"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.Scaffold_Map&1 NOLOGGING AS
     SELECT
      na_sequence_id as virtual_na_sequence_id,
      parent_id as virtual_source_id,
      piece_na_sequence_id,
      source_id as piece_source_id,
      (offset + 1) as startm,
      (offset + length) as end,
      strand_orientation,
      length,
      sequence_order
FROM (
(SELECT vs.na_sequence_id, vs.source_id as parent_id, ens.source_id,
       sp.piece_na_sequence_id, sp.sequence_order,
       ens.length, vs.length as chr_length, sp.strand_orientation,
       0 as offset
 FROM dots.VirtualSequence vs, apidb.SequencePieceClosure sp,
     dots.ExternalNaSequence ens
 WHERE vs.na_sequence_id = sp.virtual_na_sequence_id
  and ens.na_sequence_id = sp.piece_na_sequence_id
  and sp.sequence_order = 1
GROUP by vs.na_sequence_id, vs.source_id, ens.source_id, sp.piece_na_sequence_id, sp.sequence_order,
       ens.length, vs.length, sp.strand_orientation)
UNION
(SELECT vs.na_sequence_id, vs.source_id as parent_id, ens.source_id,
       sp.piece_na_sequence_id, sp.sequence_order,
       ens.length, vs.length as chr_length, sp.strand_orientation,
       sum(predecessors.length) as offset
 FROM dots.VirtualSequence vs, apidb.SequencePieceClosure sp,
     dots.ExternalNaSequence ens,
     (select sp2.virtual_na_sequence_id, sp2.sequence_order, ens2.length
      from apidb.SequencePieceClosure sp2,
           dots.ExternalNaSequence ens2
      where sp2.piece_na_sequence_id = ens2.na_sequence_id) predecessors
 WHERE vs.na_sequence_id = sp.virtual_na_sequence_id
  and ens.na_sequence_id = sp.piece_na_sequence_id
  and vs.na_sequence_id = predecessors.virtual_na_sequence_id(+)
  and sp.sequence_order > predecessors.sequence_order
GROUP by vs.source_id, vs.na_sequence_id, ens.source_id, sp.piece_na_sequence_id, sp.sequence_order,
       ens.length, vs.length, sp.strand_orientation )
ORDER by na_sequence_id, offset, sequence_order)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.DistinctLowerProduct">
    <externalDependency name="dots.NaFeatureImp"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.DistinctLowerProduct&1 NOLOGGING AS
select rownum as dlp_id, dlp
from (select distinct lower(product) as dlp
      from dots.GeneFeature)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.GeneProduct">
    <internalDependency name="apidb.DistinctLowerProduct"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GeneProduct&1 NOLOGGING AS
select dlp_id, na_feature_id
from apidb.DistinctLowerProduct, dots.GeneFeature
where lower(product) = dlp
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX geneProduct_ix&1 ON apidb.GeneProduct&1(dlp_id, na_feature_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SimilaritySpanLocation">
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.SimilaritySpan"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.SequencePiece"/>
    <sql>
      <![CDATA[
create table apidb.SimilaritySpanLocation&1 NOLOGGING as
select sim.similarity_id, sim.query_id, sim.subject_id, sim.query_table_id,
       sim.subject_table_id, sim.score as similarity_score, sim.min_query_start,
       sim.max_query_end, sim.is_reversed as similarity_is_reversed,
       sim.pvalue_mant, sim.pvalue_exp,
       round(100 * sim.number_identical / sim.total_match_length,1) as percent_identical,
       round(100 * sim.number_positive / sim.total_match_length,1) as percent_positive,
       sim.min_subject_start, sim.max_subject_end, sim.total_match_length,
       simp.similarity_span_id, simp.score as span_score, simp.query_start, simp.query_end,
       simp.subject_start, simp.subject_end,
       simp.is_reversed as span_is_reversed,
       'direct' as location_mapping, 1 as is_top_level
from dots.similarity sim, dots.similarityspan simp, core.TableInfo ti
where sim.similarity_id = simp.similarity_id
  and sim.query_table_id = ti.table_id
  and ti.name = 'ExternalNASequence'
union
select sim.similarity_id, scaffold.na_sequence_id as query_id, sim.subject_id,
       sim.query_table_id,
       sim.subject_table_id, sim.score as similarity_score,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - greatest(sim.min_query_start, sim.max_query_end) + 1
           else least(sim.min_query_start, sim.max_query_end) + sp.distance_from_left
       end as min_query_start,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - least(sim.min_query_start, sim.max_query_end) + 1
           else greatest(sim.min_query_start, sim.max_query_end) + sp.distance_from_left
       end as max_query_end,
       sim.is_reversed, sim.pvalue_mant, sim.pvalue_exp,
       round(100 * sim.number_identical / sim.total_match_length,1) as percent_identical,
       round(100 * sim.number_positive / sim.total_match_length,1) as percent_positive,
       sim.min_subject_start, sim.max_subject_end, sim.total_match_length, 
       simp.similarity_span_id, simp.score as span_score,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - greatest(simp.query_start, simp.query_end) + 1
           else least(simp.query_start, simp.query_end) + sp.distance_from_left
       end as query_start,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - least(simp.query_start, simp.query_end) + 1
           else greatest(simp.query_start, simp.query_end) + sp.distance_from_left
       end as query_end,
       simp.subject_start, simp.subject_end,
       simp.is_reversed as span_is_reversed,
       'virtual' as location_mapping, 1 as is_top_level
from dots.similarity sim, dots.similarityspan simp, core.TableInfo ti,
     dots.NaSequence contig, dots.SequencePiece sp, dots.NaSequence scaffold
where sim.similarity_id = simp.similarity_id
  and sim.query_table_id = ti.table_id
  and ti.name = 'ExternalNASequence'
  and sim.query_id = sp.piece_na_sequence_id
  and sp.piece_na_sequence_id = contig.na_sequence_id
  and sp.virtual_na_sequence_id = scaffold.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
update apidb.SimilaritySpanLocation&1
set is_top_level = 0
where subject_id in (select piece_na_sequence_id from dots.SequencePiece)
      ]]>
    </sql>
    <sql>
      <![CDATA[
update apidb.SimilaritySpanLocation&1
set pvalue_exp = (select min(pvalue_exp) from apidb.SimilaritySpanLocation&1)
where pvalue_mant = 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index apidb.spanloc_query_ix&1
        on apidb.SimilaritySpanLocation&1 (query_id, min_query_start, max_query_end, query_table_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.IsolateSNPs">
    <externalDependency name="dots.NaFeatureImp"/>
    <internalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="apidb.IsolateAttributes"/>
    <internalDependency name="apidb.SnpAttributes"/>
    <sql>
      <![CDATA[
create table apidb.IsolateSNPs&1 NOLOGGING as
select atr.na_sequence_id as is_na_sequence_id,
       atr.source_id as is_source_id,
       isof.allele,
       sa.source_id as snp_source_id,
       sa.dataset as snp_db_name,
       sa.na_sequence_id as snp_na_sequence_id,
       sa.start_min as snp_start_min
from dots.ISOLATEFEATURE isof,  apidb.featurelocation isol, 
     apidb.SNPATTRIBUTES sa, apidb.ISOLATEATTRIBUTES atr
where atr.na_feature_id = isof.parent_id
and isof.na_feature_id = isol.na_feature_id
and sa.na_sequence_id = isol.na_sequence_id
and sa.start_min = isol.start_min
and sa.dataset in ('PlasmoDB combined SNPs','Broad SNPs')
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index apidb.isolatesnps_is_sid_idx&1 on apidb.isolatesnps&1 (is_source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index apidb.isolatesnps_snp_db_id_idx&1 on apidb.isolatesnps&1 (snp_db_name,snp_source_id,allele)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index apidb.isolatesnps_snp_id_idx&1 on apidb.isolatesnps&1 (snp_source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index apidb.isnps_snp_sq_strt_idx&1 on apidb.isolatesnps&1 (snp_na_sequence_id,snp_start_min)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SnpsWithIsolates">
    <internalDependency name="apidb.IsolateAttributes"/>
    <internalDependency name="apidb.IsolateSNPs"/>
    <sql>
      <![CDATA[
create table apidb.SnpsWithIsolates&1 NOLOGGING as
select iso_ext_db_name,snp_source_id, 
 apidb.tab_to_string(CAST(COLLECT(CASE WHEN frequency < 0.5 THEN allele END) AS apidb.varchartab), ', ') as minor_allele,
 apidb.tab_to_string(CAST(COLLECT(CASE WHEN frequency > 0.5 THEN allele END) AS apidb.varchartab), ', ') as major_allele,
 to_char(min(frequency), '0.99') as minor_allele_frequency,
 min(number_isolates) as number_isolates
from (
 select s.snp_source_id as snp_source_id, s.external_db_name as iso_ext_db_name, s.allele, s.ct/t.tot as frequency, s.ct as allele_count, t.tot as number_isolates
                 from (
                       select ia.external_db_name, isos.snp_source_id,isos.allele,count(*) as ct
                       from apidb.ISOLATESNPS isos,apidb.ISOLATEATTRIBUTES ia
                       where  isos.allele in ('A','C','G','T')
                       and isos.is_source_id = ia.source_id
                       group by ia.external_db_name, isos.snp_source_id,isos.allele
                       ) s,
                       (
                       select ia.external_db_name, isos.snp_source_id, count(*) as tot
                       from apidb.isolatesnps isos,apidb.ISOLATEATTRIBUTES ia
                       where  isos.allele in ('A','C','G','T')
                       and isos.is_source_id = ia.source_id
                       group by ia.external_db_name, isos.snp_source_id
                       ) t
                       where s.snp_source_id = t.snp_source_id
                       and s.external_db_name = t.external_db_name
                       )
                 group by iso_ext_db_name,snp_source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index apidb.snpswiso_id_db_idx&1 on apidb.snpswithisolates&1 (snp_source_id,iso_ext_db_name)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
update SnpsWithIsolates&1 swa
set swa.major_allele = (select max(allele) from apidb.ISOLATEATTRIBUTES ia, apidb.ISOLATESNPS isnp 
                    where isnp.snp_source_id = swa.snp_source_id and ia.EXTERNAL_DB_NAME = swa.iso_ext_db_name
                    group by isnp.snp_source_id,ia.EXTERNAL_DB_NAME),
swa.minor_allele = (select min(allele) from apidb.ISOLATEATTRIBUTES ia, apidb.ISOLATESNPS isnp 
                    where isnp.snp_source_id = swa.snp_source_id and ia.EXTERNAL_DB_NAME = swa.iso_ext_db_name
                    group by isnp.snp_source_id,ia.EXTERNAL_DB_NAME)
where swa.major_allele is null
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.MassSpecGeneTable">
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.AaSequence"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.MassSpecFeature"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
create table apidb.MassSpecGeneTable&1 as
select sequencetable.source_id, substr(sequencetable.sequence, 1, 200) as sequence,
       seq.sum_sequence_count, spec.sum_spectrum_count,
       sequencetable.name as experiment
from (select intseq.aa_sequence_id,count(*) as sum_sequence_count
      from (select mss.aa_sequence_id, count(*) as sum_seq_ct
            from apidb.MassSpecSummary mss, dots.MassSpecFeature msf,
                 dots.AaLocation aal, sres.ExternalDatabase ed,
                 sres.ExternalDatabaseRelease edr
            where mss.mass_spec_summary_id = msf.source_id
              and msf.aa_feature_id = aal.aa_feature_id
              and msf.external_database_release_id = edr.external_database_release_id
              and edr.external_database_id = ed.external_database_id
            group by mss.aa_sequence_id,aal.start_min,aal.end_max ) intseq
      group by intseq.aa_sequence_id) seq,
     (select mss.aa_sequence_id, sum(spectrum_count) as sum_spectrum_count
      from apidb.MassSpecSummary mss
      group by mss.aa_sequence_id) spec,
     (select msf.aa_sequence_id, to_char(substr(aas.sequence, aal.start_min,
             aal.end_max - aal.start_min + 1)) as sequence, ed.name, gf.source_id
      from dots.MassSpecFeature msf,dots.AaLocation aal, dots.AaSequence aas,
           dots.TranslatedAaFeature taaf, sres.ExternalDatabaseRelease edr,
           sres.ExternalDatabase ed, dots.GeneFeature gf, dots.Transcript t
      where t.parent_id = gf.na_feature_id
        and taaf.na_feature_id = t.na_feature_id
        and msf.parent_id = taaf.aa_feature_id
        and msf.aa_feature_id = aal.aa_feature_id
        and msf.aa_sequence_id = aas.aa_sequence_id
        and msf.external_database_release_id = edr.external_database_release_id
        and edr.external_database_id = ed.external_database_id) sequencetable
where seq.aa_sequence_id = sequencetable.aa_sequence_id
  and spec.aa_sequence_id = sequencetable.aa_sequence_id
group by sequencetable.sequence, sequencetable.name, seq.sum_sequence_count,
         spec.sum_spectrum_count, sequencetable.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index apidb.MassSpec_idx&1 on apidb.MassSpecGeneTable&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.Blastp">
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.ExternalAaSequence"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="core.TableInfo"/>
    <internalDependency name="apidb.GeneAttributes"/>
    <internalDependency name="apidb.TaxonSpecies"/>
    <sql>
      <![CDATA[
create table apidb.Blastp&1 as
select rownum as blastp_id, gf.source_id, ga.project_id, sim.similarity_id,
       subject.source_id as subject_source_id, sim.score score, sim.query_id, 
       sim.min_query_start, sim.max_query_end, sim.pvalue_mant, sim.pvalue_exp,
       sim.number_identical, sim.total_match_length,
       substr(replace(subject.description, chr(1), ''), 1, 300) as description,
       sim.number_positive, ed.name as external_database_name,
       SUBSTR(tn.name, 1, 50) AS query_organism
from dots.Similarity sim, core.TableInfo qti, core.TableInfo sti, dots.ExternalAaSequence subject,
     dots.GeneFeature gf, dots.Transcript t, dots.TranslatedAaFeature taf,
     sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
     dots.NaSequence ns, apidb.TaxonSpecies st, sres.TaxonName tn, apidb.GeneAttributes ga
where qti.table_id = sim.query_table_id
  and qti.name = 'TranslatedAASequence'
  and sti.table_id = sim.subject_table_id
  and sti.name = 'ExternalAASequence'
  and subject.aa_sequence_id = sim.subject_id
  and ga.source_id = gf.source_id
  and gf.na_feature_id = t.parent_id
  and t.na_feature_id = taf.na_feature_id
  and taf.aa_sequence_id = sim.query_id
  and subject.external_database_release_id = edr.external_database_release_id
  and edr.external_database_id = ed.external_database_id
  and gf.na_sequence_id = ns.na_sequence_id
  and ns.taxon_id = st.taxon_id
  and st.species_taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
update apidb.Blastp&1
set pvalue_exp = (select min(pvalue_exp) from apidb.Blastp&1)
where pvalue_mant = 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.bplastp_src_ix&1 on apidb.Blastp&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.bplastp_query_ix&1 on apidb.Blastp&1 (query_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
drop index apidb.blastp_text_ix
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.blastp_text_ix on apidb.blastp&1(description) indextype is ctxsys.context
             parameters('DATASTORE CTXSYS.DEFAULT_DATASTORE')
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="apidb.GeneIsolateOverlap">
    <internalDependency name="apidb.IsolateAttributes"/>
    <internalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="dots.Similarity"/>
    <sql>
      <![CDATA[
create table apidb.GeneIsolateOverlap&1 as
select substr(ia.source_id, 1, 30) as isolate_source_id,
       fl.feature_source_id as gene_source_id,
       min(pvalue_exp) as min_pvalue_exp
from apidb.IsolateAttributes ia, dots.Similarity sim, apidb.FeatureLocation fl
where fl.feature_type = 'GeneFeature'
  and fl.na_sequence_id = sim.subject_id
  and fl.start_min < sim.max_subject_end
  and fl.end_max > sim.min_subject_start
  and sim.query_id = ia.na_sequence_id
group by ia.source_id, fl.feature_source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.gi_i_ix&1 on apidb.GeneIsolateOverlap&1 (isolate_source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.gi_g_ix&1 on apidb.GeneIsolateOverlap&1 (gene_source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.TableWeight">
    <sql>
      <![CDATA[
create table TableWeight&1 as
-- genes
  select cast ('GoTerms' as varchar2(80)) as table_name, 1 as weight from dual
union
  select cast ('Product' as varchar2(80)) as table_name, 5 as weight from dual
union
  select cast ('Notes' as varchar2(80)) as table_name, 2 as weight from dual
union
  select cast ('Comments' as varchar2(80)) as table_name, 2 as weight from dual
union
  select cast ('InterPro' as varchar2(80)) as table_name, 1 as weight from dual
union
  select cast ('BlastP' as varchar2(80)) as table_name, 1 as weight from dual
union
  select cast ('EcNumber' as varchar2(80)) as table_name, 1 as weight from dual
-- isolates
union
  select cast ('Reference' as varchar2(80)) as table_name, 1 as weight from dual
union
  select cast ('ProteinSequence' as varchar2(80)) as table_name, 1 as weight from dual
union
  select cast ('GeneOverlap' as varchar2(80)) as table_name, 1 as weight from dual
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index apidb.weight_ix&1 on apidb.TableWeight&1(table_name)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.TaxonSpecies">
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <sql>
      <![CDATA[
create table TaxonSpecies&1 as
select t.taxon_id, species.taxon_id as species_taxon_id
from sres.Taxon species, (select distinct ns.taxon_id
      from dots.NaSequence ns, dots.NaFeature nf
      where ns.na_sequence_id = nf.na_sequence_id) t
where species.taxon_id in (select taxon_id from sres.taxon
                           connect by taxon_id = prior parent_id and prior rank != 'species'
                           start with taxon_id = t.taxon_id)
  and species.rank = 'species'
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.Blastx">
    <externalDependency name="dots.ExternalAaSequence"/>
    <externalDependency name="dots.NaSequence"/>
    <internalDependency name="apidb.SimilaritySpanLocation"/>
    <sql>
      <![CDATA[
create table apidb.blastx&1
      (similarity_id, name, score, pvalue, na_sequence_id, startm, end, strand, atts,
       constraint blastx&1_pk primary key(na_sequence_id, startm, pvalue, end, similarity_id))
organization index
nologging
as
select distinct sim.similarity_id,
       extt.source_id name, 
       substr(sim.similarity_score || '', 1, 6) score, 
       to_number(sim.pvalue_mant || 'e' || sim.pvalue_exp) pvalue,
       extq.na_sequence_id,
       sim.min_query_start startm, 
       sim.max_query_end end, 
       decode (sim.similarity_is_reversed, 0, '+1', 1, '-1', '.') strand, 
       substr('Score=' || sim.similarity_score || ';;' || 
              'Expect=' || (sim.pvalue_mant || 'e' ||sim.pvalue_exp)||';;'|| 
              'Defline=' || extt.description || ';;' || 
              'PercentIdentity=' || sim.percent_identical || ';;' ||
              'PercentPositive=' || sim.percent_positive || ';;' ||
              'TStart=' || sim.min_query_start || ';;' || 
              'TStop=' || sim.max_query_end, 1, 400) atts 
from apidb.SimilaritySpanLocation sim, dots.ExternalAaSequence extt, 
     dots.NaSequence extq
where sim.query_id = extq.na_sequence_id
  and sim.subject_id = extt.aa_sequence_id
  and (sim.max_query_end - sim.min_query_start) < 5000
  and sim.pvalue_exp < -10
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.TranscriptSequence">
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.SplicedNaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <internalDependency name="apidb.GeneAttributes"/>
    <sql>
      <![CDATA[
create table apidb.TranscriptSequence&1 nologging as
select gf.source_id, apidb.project_id(tn.name) as project_id,
       sns.sequence
from apidb.GeneAttributes gf, dots.Transcript t, dots.SplicedNaSequence sns, sres.TaxonName tn
where t.parent_id = gf.na_feature_id
  and sns.na_sequence_id = t.na_sequence_id
  and sns.taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.XScriptSeq_ix&1 on apidb.TranscriptSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.CodingSequence">
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.SplicedNaSequence"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="sres.TaxonName"/>
    <internalDependency name="apidb.GeneAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.CodingSequence&1 NOLOGGING AS
SELECT gf.source_id, apidb.project_id(tn.name) as project_id,
       SUBSTR(sns.sequence, tf.translation_start,                            
              tf.translation_stop - tf.translation_start + 1) as sequence
FROM apidb.GeneAttributes gf, dots.Transcript t, dots.SplicedNaSequence sns,
     dots.TranslatedAaFeature tf, sres.TaxonName tn
WHERE t.parent_id = gf.na_feature_id
  AND sns.na_sequence_id = t.na_sequence_id
  AND t.na_feature_id = tf.na_feature_id
  AND sns.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.CodSeq_ix&1 on apidb.CodingSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.ProteinSequence">
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="sres.TaxonName"/>
    <internalDependency name="apidb.GeneAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.ProteinSequence&1 NOLOGGING AS
SELECT ga.source_id, apidb.project_id(tn.name) as project_id,
       tas.sequence
FROM apidb.GeneAttributes ga, dots.Transcript t, dots.TranslatedAaFeature taf,
     dots.TranslatedAaSequence tas, sres.TaxonName tn
WHERE t.parent_id = ga.na_feature_id
  AND t.na_feature_id = taf.na_feature_id
  AND taf.aa_sequence_id = tas.aa_sequence_id
  AND tas.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.ProtSeq_ix&1 on apidb.ProteinSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.NaSequence">
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <internalDependency name="apidb.SequenceAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.NaSequence&1 NOLOGGING AS
SELECT sa.source_id, apidb.project_id(tn.name) as project_id,
       ns.sequence
FROM apidb.SequenceAttributes sa, dots.NaSequence ns, sres.TaxonName tn
WHERE sa.na_sequence_id = ns.na_sequence_id
  AND ns.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.GenomicSeq_ix&1 on apidb.NaSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.OrfSequence">
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.NaFeature"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.OrfSequence&1 NOLOGGING AS
SELECT nf.source_id,
       apidb.project_id(tn.name) as project_id,
       ts.sequence
FROM dots.TranslatedAaSequence ts, dots.TranslatedAaFeature tf,
      dots.NaFeature nf, sres.SequenceOntology so, sres.TaxonName tn
 WHERE nf.na_feature_id = tf.na_feature_id
   AND ts.aa_sequence_id = tf.aa_sequence_id
   AND so.term_name = 'ORF'
   AND nf.sequence_ontology_id = so.sequence_ontology_id
   AND ts.taxon_id = tn.taxon_id
   AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.OrfSeq_ix&1 on apidb.OrfSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.EstSequence">
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.EstSequence&1 NOLOGGING AS
SELECT ens.source_id,
       apidb.project_id(tn.name) as project_id,
       ens.sequence
FROM dots.ExternalNaSequence ens, sres.SequenceOntology so, sres.TaxonName tn
WHERE so.term_name = 'EST'
  AND so.sequence_ontology_id = ens.sequence_ontology_id
  AND ens.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.EstSeq_ix&1 on apidb.EstSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.AssemblySequence">
    <externalDependency name="dots.Assembly"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.AssemblySequence&1 NOLOGGING AS
SELECT a.source_id,
       apidb.project_id(tn.name) as project_id,
       a.sequence 
FROM dots.Assembly a, sres.TaxonName tn
WHERE a.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.AssemblySeq_ix&1 on apidb.AssemblySequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.IsolateSequence">
    <internalDependency name="apidb.IsolateAttributes"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.IsolateSequence&1 NOLOGGING AS
SELECT ia.source_id,
       apidb.project_id(tn.name) as project_id,
       ns.sequence
FROM apidb.IsolateAttributes ia, dots.NaSequence ns, sres.TaxonName tn
WHERE ia.na_sequence_id = ns.na_sequence_id
  AND ns.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.IsolateSeq_ix&1 on apidb.IsolateSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

<!--
  <tuningTable name="apidb.ChangedGene" alwaysUpdate="true">
    <perl>
      <![CDATA[ 
use strict;
use lib "$ENV{GUS_HOME}/lib/perl";

use DBI;
use Data::Dumper;
use LWP::UserAgent;
use HTTP::Request;
use HTTP::Response;

$| = 1; # turn off buffering of STDOUT

my $insertStatement;

createEmptyTable();

my $genomeListRef = getGenomeList();
my @genomeList = @$genomeListRef;

foreach my $genome (@genomeList) {
  print "genome update: taxonomyId " . $genome->{'taxonomyId'} . " date \"" . $genome->{'sinceDate'} . "\"\n";
  processChangedGenes($genome->{'taxonomyId'}, $genome->{'sinceDate'});
}

sub getGenomeList {

  my $taxa = getOfferedTaxa();

#  my $dbh = getDbHandle();
  my $stmt = $dbh->prepare(<<SQL);
select distinct t.ncbi_tax_id as "taxonomyId", edr.version as "sinceDate"
from dots.GeneFeature gf, dots.NaSequence ns,
     sres.Taxon t, sres.ExternalDatabaseRelease edr
where gf.external_database_release_id = edr.external_database_release_id
  and gf.na_sequence_id = ns.na_sequence_id
  and ns.taxon_id = t.taxon_id
  and t.ncbi_tax_id in ($taxa)
union
select distinct YouSayPotato.sanger_taxon as "taxonomyId", edr.version as "sinceDate"
from dots.GeneFeature gf, dots.NaSequence ns,
     sres.Taxon t, sres.ExternalDatabaseRelease edr,
     (select 'Trypanosoma cruzi'       as organism, 353153 as eupath_taxon,   5693 as sanger_taxon from dual
       union
      select 'Leishmania major'        as organism,   5664 as eupath_taxon, 347515 as sanger_taxon from dual
       union
      select 'Leishmania braziliensis' as organism,   5660 as eupath_taxon, 420245 as sanger_taxon from dual) YouSayPotato
where gf.external_database_release_id = edr.external_database_release_id
  and gf.na_sequence_id = ns.na_sequence_id
  and ns.taxon_id = t.taxon_id
  and t.ncbi_tax_id = YouSayPotato.eupath_taxon
  and YouSayPotato.sanger_taxon in ($taxa)
SQL

  $stmt->execute();
  my @genomeList;
  while (my $ref = $stmt->fetchrow_hashref()) {
    push(@genomeList, $ref);
  }

  # old, hardwired taxon/date pairs
  #   my @genomeList = (
  # 		    {taxonomyId => 185431, sinceDate => '2008-11-13'},  # T. brucei
  # 		    {taxonomyId => 5671, sinceDate => '2008-11-24'} );  # L. infantum

  return \@genomeList;
}


sub getOfferedTaxa {

  # returns a comma-separated string of NCBI taxon IDs for which the Sanger web
  # service can show changes.  The service itself will provide this list, as a
  # response to the URL in the code.  But since it changes slowly, and every
  # component runs the tuning manager, it's hardwired into this RETURN statement
  return <<SANGERTAXA;
   5085, 360910, 518, 95486, 272559, 97084, 519, 520, 28450,
   83555, 1491, 1496, 1717, 42374, 197, 28447, 813, 44689,
   554, 216592, 5759, 5802, 420245, 5661, 5671,347515, 5665,
   1765, 1769, 1781, 1773, 29176, 487, 272831, 5821, 5825,
   5833, 294,5850, 5855, 5861, 384, 46170, 282458, 282459,
   54736, 4932, 1902, 592, 40324, 6183, 615, 561276, 373153,
   1313, 170187, 4896, 1314, 90370, 568708, 1349, 5874,
   5761, 185431, 31285, 5692, 5693, 5699, 2039, 630, 632
SANGERTAXA

  my $ua = new LWP::UserAgent;
  my $url = "http://www.genedb.org/service/genomes/changes.xml?since=2008-12-01";

  print "getting list of available taxa from = $url\n";
  my $request = new HTTP::Request('GET', $url);
  my $response = $ua->request($request);
  if (!$response->is_success) {
    die "trying to get taxon list with URL ->>\"$url\<<-.  Got response ->>" . $response->content . "<<- (end of response to taxon-list request)";
  }

  my $simple = XML::Simple->new();
  my $changeList = $simple->XMLin($response->content, KeyAttr => 'taxonomyID');
  my $results = $changeList->{results};

  my $organisms = $results->{organism};

  my @taxa;
  map {my $taxonomyID = $_->{'taxonomyID'}; push(@taxa, $taxonomyID) if $taxonomyID} @$organisms;

  my $taxa = join(', ', @taxa);
  return $taxa;
}

sub processChangedGenes {

  my ($taxonomyId, $sinceDate) = @_;

  die "bad taxonomyId" if !defined($taxonomyId);

  my $ua = new LWP::UserAgent;
  my $url = "http://www.genedb.org/service/genome/changes.xml?since=$sinceDate&taxonomyID=$taxonomyId";
  print "getting list of gene changes from = $url\n";
  my $request = new HTTP::Request('GET', $url);
  my $response = $ua->request($request);
  if (!$response->is_success) {
    die "trying to get changed-gene list for taxonomy ID $taxonomyId with URL $url .  Got response ->>"
        . $response->content . "<<- (end of response to gene-list request for taxonomy ID $taxonomyId)";
  }

  my $simple = XML::Simple->new();
  my $changeList = $simple->XMLin($response->content);
  my $results = $changeList->{results};

  my $features = $results->{feature};
  my %geneLastChange;
  foreach my $featureId (keys(%$features)) {
    my $gene = $features->{$featureId}->{rootUniquename};
    my $lastMod = $features->{$featureId}->{timelastmodified};
    $geneLastChange{$gene} = $lastMod
      if !defined $geneLastChange{$gene} || $lastMod gt $geneLastChange{$gene};
  }

  my $insertStatement = getInsertStatement();
  foreach my $gene (keys(%geneLastChange)) {
    my $modDate = $geneLastChange{$gene};

    # web service date format: 'yyyy-mm-dd hh24:mi:ss.fff'
    # must truncate fractional seconds to fit into Oracle date
    $modDate =~ s/\..*$//;
    $insertStatement->execute($gene, $modDate)
      or die "Can't insert ChangedGene record (gene $gene, lastModified $modDate)";
  }
}

sub getDbHandle {

  my $username = 'apidb';
  my $password = '<password>';
  my $instance = '<instance>';
  my $dsn = "dbi:Oracle:" . $instance;

  my $dbh = DBI->connect(
                $dsn,
                $username,
                $password,
                { PrintError => 1, RaiseError => 0}
                ) or die "Can't connect to the database: $DBI::errstr\n";

  return $dbh;
}

sub getInsertStatement {

  if (!$insertStatement) {
    # my $dbh = getDbHandle();

    $insertStatement = $dbh->prepare(<<SQL);
      insert into apidb.ChangedGene&1 (gene, last_modified)
      values (?, to_date(?, 'yyyy-mm-dd hh24:mi:ss'))
SQL
  }

  return $insertStatement;
}

sub createEmptyTable {
    # my $dbh = getDbHandle();

    $dbh->do(<<SQL);
create table apidb.ChangedGene&1 (
   gene          varchar2(50),
   last_modified date,
   constraint cdg_pk&1 primary key (gene)
)
SQL

}
      ]]> 
    </perl>
  </tuningTable>
-->

  <tuningIndex name="dots.aaseq_subclassdbrel_ix" table="dots.AaSequenceImp">
    external_database_release_id, subclass_view, aa_sequence_id
  </tuningIndex>

  <tuningIndex name="dots.NaFeat_alleles_ix" table="dots.NaFeatureImp">
    subclass_view, number4, number5, na_sequence_id, na_feature_id
  </tuningIndex>

  <tuningIndex name="dots.AaSequenceImp_string2_ix" table="dots.AaSequenceImp">
    string2, aa_sequence_id
  </tuningIndex>

  <tuningIndex name="dots.AaSequenceImp_class_tax_ix" table="dots.AaSequenceImp">
    subclass_view, taxon_id, aa_sequence_id
  </tuningIndex>

  <tuningIndex name="dots.NaFeat_SubclassIds_ix" table="dots.NaFeatureImp">
    subclass_view, source_id, na_feature_id, na_sequence_id
  </tuningIndex>

  <tuningIndex name="dots.NaFeat_SubclassParent_ix" table="dots.NaFeatureImp">
    subclass_view, parent_id, na_feature_id
  </tuningIndex>

  <tuningIndex name="dots.loc_feat_ix" table="dots.NaLocation">
    na_feature_id, start_min, end_max, is_reversed
  </tuningIndex>

  <tuningIndex name="dots.sim_pval_ix" table="dots.Similarity">
    query_id, pvalue_exp, pvalue_mant, subject_id
  </tuningIndex>

  <tuningIndex name="dots.nasequenceimp_string1_seq_idx" table="dots.NaSequenceImp">
    STRING1, EXTERNAL_DATABASE_RELEASE_ID, NA_SEQUENCE_ID
  </tuningIndex>

  <tuningIndex name="dots.nasequenceimp_string1_idx" table="dots.NaSequenceImp">
    string1, na_sequence_id
  </tuningIndex>

  <tuningIndex name="dots.aafeat_subclassparent_ix" table="dots.AaFeatureImp">
    subclass_view, parent_id, aa_feature_id
  </tuningIndex>

  <tuningIndex name="aafeature_subclasssource_ix" table="dots.AaFeatureImp">
    subclass_view, source_id, aa_feature_id
  </tuningIndex> 

  <tuningIndex name="AnalRes_subclassRow_ix" table="rad.AnalysisResultImp">
    subclass_view, row_id
  </tuningIndex> 

  <tuningIndex name="ExonOrder_ix" table="dots.NaFeatureImp">
    subclass_view, parent_id, number3, na_feature_id
  </tuningIndex> 

  <tuningIndex name="sres.so_term_ix" table="sres.SequenceOntology">
    term_name, sequence_ontology_id
  </tuningIndex> 

<!--
  This index should be unique, except for the SplicedNaSequence records whose source_ids are null.

  <tuningIndex name="dots.NaSequenceImp_UniqSrcid_ix" table="dots.NaSequenceImp">
    string1, external_database_release_id
  </tuningIndex>
-->

<!--
  This index should be unique, except for the TranslatedAaSequence records whose source_ids are null.

  <tuningIndex name="dots.AaSequenceImp_UniqSrcid_ix" table="dots.AaSequenceImp">
    source_id, external_database_release_id
  </tuningIndex>
-->

</tuningConfig>
