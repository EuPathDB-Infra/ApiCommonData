<tuningConfig>

  <tuningTable name="apidb.GeneAlias">
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.NaFeatureNaGene"/>
    <externalDependency name="dots.NaGene"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GeneAlias&1 NOLOGGING AS
SELECT DISTINCT pairs.alias, pairs.gene FROM
(SELECT ng.name AS alias, gf.source_id AS gene
 FROM dots.GeneFeature gf, dots.NaFeatureNaGene nfng, dots.NaGene ng
 WHERE gf.na_feature_id = nfng.na_feature_id
   AND ng.na_gene_id = nfng.na_gene_id
 UNION
 SELECT LOWER(ng.name) AS alias, gf.source_id AS gene
 FROM dots.GeneFeature gf, dots.NaFeatureNaGene nfng, dots.NaGene ng
 WHERE gf.na_feature_id = nfng.na_feature_id
   AND ng.na_gene_id = nfng.na_gene_id
 UNION
 SELECT source_id AS alias, source_id AS gene
 FROM dots.GeneFeature
 UNION
 SELECT lower(source_id) AS alias, source_id AS gene
 FROM dots.GeneFeature) pairs,
      dots.GeneFeature gf, sres.ExternalDatabaseRelease edr,
      sres.ExternalDatabase ed
WHERE pairs.gene = gf.source_id
  AND gf.external_database_release_id = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ed.name NOT IN ('GLEAN predictions', 'GlimmerHMM predictions',
                      'TigrScan', 'TwinScan predictions',
                      'TwinScanEt predictions', 'P. falciparum Evigan Gene Models',
                      'Pfalciparum workshop annotations reviewed and changed',
                      'Old annotation for ME49')
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneAlias_gene_idx&1 ON apidb.GeneAlias&1 (gene)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneAlias_alias_idx&1 ON apidb.GeneAlias&1 (alias)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SequenceAlias">
    <externalDependency name="dots.NaSequenceImp"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.SequenceAlias&1 NOLOGGING AS
SELECT ens.source_id, LOWER(ens.source_id) AS lowercase_source_id
FROM dots.ExternalNaSequence ens
UNION
SELECT ens.source_id, LOWER(ens.source_id) AS lowercase_source_id
FROM dots.VirtualSequence ens
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SequenceAlias_idx&1 ON apidb.SequenceAlias&1(lowercase_source_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.GoTermSummary">
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.AaFeatureImp"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.GoAssociation"/>
    <externalDependency name="dots.GoAssociationInstance"/>
    <externalDependency name="dots.GoAssociationInstanceLoe"/>
    <externalDependency name="dots.GoAssocInstEvidCode"/>
    <externalDependency name="sres.GoEvidenceCode"/>
    <externalDependency name="sres.GoRelationship"/>
    <externalDependency name="sres.GoTerm"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GoTermSummary&1 NOLOGGING AS
SELECT gf.source_id,
       decode(ga.is_not, 0, '', 1, 'not', ga.is_not) as is_not,
                 gt.go_id, o.ontology, gt.name AS go_term_name,
                  gail.name AS source, gec.name as evidence_code
FROM dots.GeneFeature gf, dots.Transcript t,
     dots.TranslatedAaFeature taf, dots.GoAssociation ga,
     sres.GoTerm gt, dots.GoAssociationInstance gai,
     dots.GoAssociationInstanceLoe gail,
     dots.GoAssocInstEvidCode gaiec, sres.GoEvidenceCode gec,
     (SELECT gr.child_term_id AS go_term_id,
             DECODE(gp.name, 'biological_process', 'Biological Process',
                             'molecular_function', 'Molecular Function',
                             'cellular_component', 'Cellular Component',
                              gp.name)
             AS ontology
      FROM sres.GoRelationship gr, sres.GoTerm gp
      WHERE gr.parent_term_id = gp.go_term_id
        AND gp.go_id in ('GO:0008150','GO:0003674','GO:0005575')) o
WHERE gf.na_feature_id = t.parent_id
  AND t.na_feature_id = taf.na_feature_id
  AND taf.aa_sequence_id = ga.row_id
  AND ga.table_id = (SELECT table_id
                     FROM core.TableInfo
                     WHERE name = 'TranslatedAASequence')
  AND ga.go_term_id = gt.go_term_id
  AND ga.go_association_id = gai.go_association_id
  AND gai.go_assoc_inst_loe_id = gail.go_assoc_inst_loe_id
  AND gai.go_association_instance_id
      = gaiec.go_association_instance_id
  AND gaiec.go_evidence_code_id = gec.go_evidence_code_id
  AND gt.go_term_id = o.go_term_id(+)
ORDER BY o.ontology, gt.go_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GoTermSum_sourceId_idx&1 ON apidb.GoTermSummary&1 (source_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.PdbSimilarity">
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.AaFeatureImp"/>
    <externalDependency name="dots.AaSequenceImp"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.PdbSimilarity&1 NOLOGGING AS
SELECT gf.source_id, eas.source_id AS pdb_chain, eas.description AS pdb_title,
       substr(eas.source_id, 1,
              instr(eas.source_id, '_', -1) - 1)
         AS pdb_id,
       s.pvalue_mant, s.pvalue_exp, tn.name AS taxon,
       ROUND( (s.number_identical / s.total_match_length) * 100)
         AS percent_identity,
       ROUND( (s.total_match_length / tas.length) * 100)
         AS percent_plasmo_coverage,
       s.score
FROM dots.TranslatedAaFeature taf,
     dots.TranslatedAaSequence tas, core.TableInfo tas_ti,
     dots.Similarity s, core.TableInfo eas_ti,
     dots.ExternalAaSequence eas,
     sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
     sres.TaxonName tn, dots.Transcript t, dots.GeneFeature gf
WHERE taf.aa_sequence_id = tas.aa_sequence_id
  AND tas_ti.name = 'TranslatedAASequence'
  AND tas_ti.table_id = s.query_table_id
  AND s.query_id = tas.aa_sequence_id
  AND eas_ti.name = 'ExternalAASequence'
  AND eas_ti.table_id = s.subject_table_id
  AND s.subject_id = eas.aa_sequence_id
  AND tn.name_class = 'scientific name'
  AND eas.external_database_release_id
      = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ed.name = 'PDB protein sequences'
  AND eas.taxon_id = tn.taxon_id
  AND t.na_feature_id = taf.na_feature_id
  AND gf.na_feature_id = t.parent_id
ORDER BY taf.source_id, eas.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.PdbSim_sourceId_ix&1
ON apidb.PdbSimilarity&1 (source_id, score DESC)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SequencePieceClosure">
    <externalDependency name="dots.SequencePiece"/>
    <sql>
      <![CDATA[
        create table apidb.SequencePieceClosure&1 nologging as
        select sp.*, 1 as edge_level from dots.SequencePiece sp
      ]]>
    </sql>
    <sql>
      <![CDATA[
        /* known issue: this should be run not just once, but iteratively
           until it doesn't create new records.  Currently (7/2008),
           SequencePieces aren't nested even once. */
        insert into apidb.SequencePieceClosure&1
                    (edge_level, virtual_na_sequence_id, piece_na_sequence_id,
                     distance_from_left, strand_orientation, modification_date)
        select 2, higher.virtual_na_sequence_id, lower.piece_na_sequence_id,
               higher.distance_from_left
               + case
                   when nvl(higher.strand_orientation, '+') = '+'
                   then lower.distance_from_left
                   else higher_piece.length - lower_piece.length - lower.distance_from_left
                 end as distance_from_left,
               case
                 when nvl(higher.strand_orientation, '+') = nvl(lower.strand_orientation, '+')
                 then '+'
                 else '-'
               end as strand_orientation,
               sysdate
        from apidb.SequencePieceClosure&1 higher, apidb.SequencePieceClosure&1 lower,
             dots.NaSequence higher_piece, dots.NaSequence lower_piece
        where higher.piece_na_sequence_id = lower.virtual_na_sequence_id
          and higher.piece_na_sequence_id = higher_piece.na_sequence_id
          and lower.piece_na_sequence_id = lower_piece.na_sequence_id
          and (higher.virtual_na_sequence_id, lower.piece_na_sequence_id)
              not in (select virtual_na_sequence_id, piece_na_sequence_id
                      from apidb.SequencePieceClosure&1)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.FeatureLocation">
    <internalDependency name="apidb.SequencePieceClosure"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.NaLocation"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
create table apidb.FeatureLocation&1 NOLOGGING as
select case
         when nf.subclass_view = 'GeneFeature'
              and db.name in ('GLEAN predictions', 'GlimmerHMM predictions',
                              'TigrScan', 'TwinScan predictions',
                              'TwinScanEt predictions', -- not 'tRNAscan-SE',
                              'P. falciparum Evigan Gene Models',
                              'Pfalciparum workshop annotations reviewed and changed',
                              'Old annotation for ME49')
           then 'GenePrediction'
         else nf.subclass_view
       end as feature_type,
       nf.source_id as feature_source_id, ns.source_id as sequence_source_id,
       nf.na_sequence_id, nf.na_feature_id,
       least(nl.start_min, nl.start_max, nl.end_min, nl.end_max) as start_min,
       greatest(nl.start_min, nl.start_max, nl.end_min, nl.end_max) as end_max,
       nl.is_reversed, nf.parent_id, nf.sequence_ontology_id,
       cast (null as number) as is_top_level, ef.coding_start, ef.coding_end,
       nf.external_database_release_id
from dots.NaFeature nf, dots.NaLocation nl, dots.NaSequence ns,
     dots.ExonFeature ef,
     (select edr.external_database_release_id, ed.name
      from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      where edr.external_database_id = ed.external_database_id) db
where nf.na_feature_id = nl.na_feature_id
  and nf.external_database_release_id = db.external_database_release_id(+)
  and nf.na_sequence_id = ns.na_sequence_id
  and nl.na_feature_id = ef.na_feature_id(+)
union
select -- virtual feature locations mapped through SequencePiece
       case
         when nf.subclass_view = 'GeneFeature'
              and  db.name in ('GLEAN predictions', 'GlimmerHMM predictions',
                          'TigrScan', 'TwinScan predictions',
                          'TwinScanEt predictions', -- not 'tRNAscan-SE',
                          'P. falciparum Evigan Gene Models',
                          'Pfalciparum workshop annotations reviewed and changed',
                          'Old annotation for ME49')
           then 'GenePrediction'
         else nf.subclass_view
       end as feature_type,
       nf.source_id as feature_source_id, scaffold.source_id as sequence_source_id,
       sp.virtual_na_sequence_id, nf.na_feature_id,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - greatest(nl.start_min, nl.start_max, nl.end_min, nl.end_max)
           else sp.distance_from_left + least(nl.start_min, nl.start_max, nl.end_min, nl.end_max)
       end as start_min,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - least(nl.start_min, nl.start_max, nl.end_min, nl.end_max)
         else sp.distance_from_left + greatest(nl.start_min, nl.start_max, nl.end_min, nl.end_max)
       end as end_max,
       case
         when sp.strand_orientation in ('-', '-1')
         then decode(nvl(nl.is_reversed, 0),
                     0, 1,  1, 0,  1)
         else nl.is_reversed
       end as is_reversed,
       nf.parent_id, nf.sequence_ontology_id,
       cast (null as number) as is_top_level,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - coding_start
           else sp.distance_from_left + ef.coding_start
       end as coding_start,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - coding_end
         else sp.distance_from_left + coding_end
       end as coding_end, nf.external_database_release_id
from dots.NaFeature nf, dots.NaLocation nl, dots.NaSequence contig,
     apidb.SequencePieceClosure sp, dots.NaSequence scaffold, dots.ExonFeature ef,
     (select edr.external_database_release_id, ed.name
      from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      where edr.external_database_id = ed.external_database_id) db
where nf.na_feature_id = nl.na_feature_id
  and nf.external_database_release_id = db.external_database_release_id(+)
  and nf.na_sequence_id = contig.na_sequence_id
  and nf.na_sequence_id = sp.piece_na_sequence_id
  and sp.virtual_na_sequence_id = scaffold.na_sequence_id
  and nl.na_feature_id = ef.na_feature_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
update apidb.FeatureLocation&1
set is_top_level = 1
      ]]>
    </sql>
    <sql>
      <![CDATA[
update apidb.FeatureLocation&1
set is_top_level = 0
where na_sequence_id in (select piece_na_sequence_id from dots.SequencePiece)
      ]]>
    </sql>
    <sql>
      <![CDATA[
commit
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.featloc_ix&1 on apidb.FeatureLocation&1
             (feature_type, na_sequence_id, start_min, end_max, is_reversed, feature_source_id, na_feature_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.featloc2_ix&1 on apidb.FeatureLocation&1
             (na_sequence_id, start_min, end_max, is_reversed, sequence_ontology_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.fl_seq_st_end_feat_idx&1
      on apidb.FeatureLocation&1 (na_sequence_id,start_min,end_max,na_feature_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.featloc3_ix&1 on apidb.FeatureLocation&1
             (na_feature_id, na_sequence_id, is_top_level)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.GeneId">
    <internalDependency name="apidb.GeneAlias"/>
    <internalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GeneId&1 NOLOGGING AS
SELECT lower(substr(t.protein_id, 1, instr(t.protein_id, '.') - 1)) AS id,
       gf.source_id AS gene
FROM dots.Transcript t, dots.GeneFeature gf
WHERE t.parent_id = gf.na_feature_id
  AND lower(substr(t.protein_id, 1, instr(t.protein_id, '.') - 1)) IS NOT NULL
UNION
SELECT lower(t.protein_id) AS id,
       gf.source_id AS gene
FROM dots.Transcript t, dots.GeneFeature gf
WHERE t.parent_id = gf.na_feature_id
  AND t.protein_id IS NOT NULL
UNION
SELECT LOWER(dr.primary_identifier) AS id, gf.source_id AS gene
FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
     sres.DbRef dr, sres.ExternalDatabaseRelease edr,
     sres.ExternalDatabase ed
WHERE dr.primary_identifier IS NOT NULL
  AND gf.na_feature_id = drnf.na_feature_id
  AND drnf.db_ref_id = dr.db_ref_id
  AND dr.external_database_release_id
        = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
--AND ed.name IN ('NRDB_gb_dbXRefBySeqIdentity',
--                'NRDB_pdb_dbXRefBySeqIdentity',
--                'NRDB_ref_dbXRefBySeqIdentity',
--                'NRDB_sp_dbXRefBySeqIdentity',
--                'Predicted protein structures',
--                'GenBank', 'gb', 'GI', 'Giardia gene aliases 1')
UNION
SELECT LOWER(dr.secondary_identifier) AS id, gf.source_id AS gene
FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
     sres.DbRef dr, sres.ExternalDatabaseRelease edr,
     sres.ExternalDatabase ed
WHERE dr.secondary_identifier IS NOT NULL
  AND gf.na_feature_id = drnf.na_feature_id
  AND drnf.db_ref_id = dr.db_ref_id
  AND dr.external_database_release_id
        = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ed.name IN ('NRDB_gb_dbXRefBySeqIdentity',
                  'NRDB_pdb_dbXRefBySeqIdentity',
                  'NRDB_ref_dbXRefBySeqIdentity',
                  'NRDB_sp_dbXRefBySeqIdentity',
                  'Predicted protein structures',
                  'GenBank')
UNION
SELECT lower(dr.primary_identifier) AS id, gf.source_id AS gene
FROM dots.GeneFeature gf, dots.Transcript t, dots.dbrefNaSequence drns,
     sres.DbRef dr, sres.ExternalDatabaseRelease edr,
      sres.ExternalDatabase ed
WHERE gf.na_feature_id = t.parent_id
  AND t.na_sequence_id = drns.na_sequence_id
  AND drns.db_ref_id = dr.db_ref_id
  AND dr.external_database_release_id = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ed.name = 'GenBank'
UNION
SELECT LOWER(alias) AS id, gene FROM apidb.GeneAlias
UNION
SELECT pred_loc.feature_source_id AS alias, gene_loc.feature_source_id AS gene
FROM apidb.FeatureLocation gene_loc, apidb.FeatureLocation pred_loc
WHERE pred_loc.feature_type = 'GenePrediction'
  AND gene_loc.feature_type = 'GeneFeature'
  AND pred_loc.na_sequence_id = gene_loc.na_sequence_id
  AND gene_loc.start_min <= pred_loc.end_max
  AND gene_loc.end_max >= pred_loc.start_min
  AND pred_loc.is_reversed = gene_loc.is_reversed
UNION
SELECT lower(pred_loc.feature_source_id) AS alias,
       gene_loc.feature_source_id AS gene
FROM apidb.FeatureLocation gene_loc, apidb.FeatureLocation pred_loc
WHERE pred_loc.feature_type = 'GenePrediction'
  AND gene_loc.feature_type = 'GeneFeature'
  AND pred_loc.na_sequence_id = gene_loc.na_sequence_id
  AND gene_loc.start_min <= pred_loc.end_max
  AND gene_loc.end_max >= pred_loc.start_min
  AND pred_loc.is_reversed = gene_loc.is_reversed
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneId_gene_idx&1 ON apidb.GeneId&1 (gene)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneId_id_idx&1 ON apidb.GeneId&1 (id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SequenceId">
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.SequenceOntology"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.SequenceId&1 NOLOGGING AS
SELECT DISTINCT substr(id, 1, 50) as id, substr(sequence, 1, 50) AS sequence
FROM (
  SELECT lower(source_id) as id, source_id as sequence
  FROM dots.NaSequence ns, sres.SequenceOntology so
  WHERE ns.sequence_ontology_id = so.sequence_ontology_id
    AND so.term_name in ('contig', 'supercontig', 'chromosome')
UNION
  SELECT LOWER(dr.primary_identifier) AS id, ns.source_id AS sequence
  FROM dots.NaSequence ns, dots.DbRefNaSequence drnf,
       sres.DbRef dr, sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase ed
  WHERE dr.primary_identifier IS NOT NULL
    AND ns.na_sequence_id = drnf.na_sequence_id
    AND drnf.db_ref_id = dr.db_ref_id
    AND dr.external_database_release_id
          = edr.external_database_release_id
    AND edr.external_database_id = ed.external_database_id
)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SequenceId_sequence_idx&1 ON apidb.SequenceId&1 (sequence)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SequenceId_id_idx&1 ON apidb.SequenceId&1 (id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.EpitopeSummary">
    <externalDependency name="dots.AaFeatureImp"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.AaSequenceDbRef"/>
    <externalDependency name="dots.AaSequenceImp"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.EpitopeSummary&1 NOLOGGING AS
SELECT gf.source_id, dr.primary_identifier AS iedb_id,
       al.start_min||'-'||al.end_max AS location,
       mas.sequence, tn.name,
       DECODE(ef.type, 'Not Full Set Not on Blast Hit', 'Low',
                       'Not Full Set On Blast Hit', 'Medium',
                       'Full Set Not on Blast Hit', 'Medium',
                       'Full Set On Blast Hit', 'High',
                       'unknown epitope type') AS confidence
FROM dots.GeneFeature gf, dots.Transcript t,
     dots.TranslatedAaFeature taf, dots.MotifAaSequence mas,
     dots.TranslatedAaSequence tas, dots.EpitopeFeature ef,
     dots.AaLocation al, dots.AaSequenceDbRef asdr,
     sres.DbRef dr, sres.ExternalDatabaseRelease edr,
     sres.ExternalDatabase ed, Sres.TaxonName tn
WHERE t.parent_id = gf.na_feature_id
  AND taf.na_feature_id = t.na_feature_id
  AND taf.aa_sequence_id = tas.aa_sequence_id
  AND tas.aa_sequence_id = ef.aa_sequence_id
  AND ef.aa_feature_id = al.aa_feature_id
  AND ef.motif_aa_sequence_id = mas.aa_sequence_id
  AND mas.aa_sequence_id = asdr.aa_sequence_id
  AND asdr.db_ref_id = dr.db_ref_id
  AND tas.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
  AND ef.external_database_release_id
      = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ed.name = 'Links to IEDB epitopes'
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Epi_srcId_ix&1 ON apidb.EpitopeSummary&1 (source_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.GeneCentromereDistance">
    <internalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="sres.SequenceOntology"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GeneCentromereDistance&1 NOLOGGING AS
SELECT gfl.feature_source_id AS gene,
       LEAST(ABS(mfl.start_min - gfl.end_max),
             ABS(mfl.end_max - gfl.start_min)) AS centromere_distance,
       gfl.sequence_source_id AS genomic_sequence
FROM apidb.FeatureLocation gfl, apidb.FeatureLocation mfl,
     sres.SequenceOntology so
WHERE gfl.na_sequence_id = mfl.na_sequence_id
  AND mfl.feature_type = 'Miscellaneous'
  AND gfl.feature_type = 'GeneFeature'
  AND mfl.sequence_ontology_id = so.sequence_ontology_id
  AND so.term_name = 'centromere'
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GCent_loc_ix&1
       ON apidb.GeneCentromereDistance&1 (genomic_sequence, centromere_distance)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SageTagGene">
    <internalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="rad.DataTransformationResult"/>
    <externalDependency name="dots.SageTagFeature"/>
    <intermediateTable name="apidb.SageTagGeneFivePrime"/>
    <intermediateTable name="apidb.SageTagGeneThreePrime"/>
    <sql>
      <![CDATA[
create table apidb.SageTagGeneFivePrime NOLOGGING as
   select '5' as direction, g.feature_source_id AS gene_source_id,
          s.feature_source_id as tag_source_id,
             min (case
                    when g.is_reversed = 1 and s.end_max - g.end_max < 0
                      then 0
                    when g.is_reversed = 1 and s.end_max - g.end_max >= 0
                      then s.end_max - g.end_max
                    when g.is_reversed = 0 and g.start_min - s.start_min < 0
                      then 0
                    when g.is_reversed = 0 and g.start_min - s.start_min >= 0
                      then g.start_min - s.start_min
                  end) as distance,
           dr.analysis_id, max(dr.float_value) as tag_count,
           max(ct.occurrence) as occurrence,
           g.na_feature_id as gene_feature_id, s.na_feature_id as tag_feature_id,
           case when s.is_reversed = g.is_reversed then 0
                else 1
           end as antisense
      from apidb.FeatureLocation g, apidb.FeatureLocation s,
           rad.DataTransformationResult dr,
           (select source_id , count(*) as occurrence
            from dots.SageTagFeature
            group by source_id) ct
      where g.feature_type = 'GeneFeature'
        and s.feature_type = 'SAGETagFeature'
        and g.na_sequence_id = s.na_sequence_id
        and s.feature_source_id = dr.row_id
        and dr.row_id = ct.source_id
        and (case
               when g.is_reversed = 0
                 then g.start_min - s.start_min
               else s.end_max - g.end_max
             end <= 1000
            and case
                  when g.is_reversed = 0
                    then g.end_max - s.end_max
                  else s.start_min - g.start_min
                end >= 0)
      group by g.feature_source_id, s.feature_source_id, dr.analysis_id,
               g.na_feature_id, s.na_feature_id,
               case when s.is_reversed = g.is_reversed then 0
                    else 1
               end
      ]]>
    </sql>
    <sql>
      <![CDATA[
create table apidb.SageTagGeneThreePrime NOLOGGING as
      select '3' as direction, g.feature_source_id AS gene_source_id,
             s.feature_source_id as tag_source_id,
             min (case
                    when g.is_reversed = 1 and g.start_min - s.start_min < 0
                      then 0
                    when g.is_reversed = 1 and g.start_min - s.start_min  >= 0
                      then g.start_min - s.start_min
                    when g.is_reversed = 0 and s.end_max - g.end_max < 0
                      then 0
                    when g.is_reversed = 0 and s.end_max - g.end_max >= 0
                      then s.end_max - g.end_max
                  end) as distance,
           dr.analysis_id, max(dr.float_value) as tag_count,
           max(ct.occurrence) as occurrence,
           g.na_feature_id as gene_feature_id, s.na_feature_id as tag_feature_id,
           case when s.is_reversed = g.is_reversed then 0
                else 1
           end as antisense
      from apidb.FeatureLocation g, apidb.FeatureLocation s,
           rad.DataTransformationResult dr,
           (select source_id , count(*) as occurrence
            from dots.SageTagFeature
            group by source_id) ct
            where g.feature_type = 'GeneFeature'
              and s.feature_type = 'SAGETagFeature'
              and g.na_sequence_id = s.na_sequence_id
              and s.feature_source_id = dr.row_id
              and dr.row_id = ct.source_id
              and (case
                     when g.is_reversed = 0
                       then s.end_max - g.end_max
                     else g.start_min - s.start_min end <= 1000
                  and
                   case
                     when g.is_reversed = 0
                       then s.start_min - g.start_min
                     else g.end_max - s.end_max
                   end >= 0)
            group by g.feature_source_id, s.feature_source_id, dr.analysis_id,
                     g.na_feature_id, s.na_feature_id,
                     case when s.is_reversed = g.is_reversed then 0
                          else 1
                     end
      ]]>
    </sql>
    <sql>
      <![CDATA[
create table apidb.SageTagGene&1 NOLOGGING as
select t.direction, t.gene_source_id, t.tag_source_id, t.distance,
       t.analysis_id, t.occurrence, t.gene_feature_id, t.tag_feature_id,
       t.tag_count, t.antisense,
       case
         when t.antisense = 0 then t.tag_count
         else 0
       end as sense_count,
       case
         when t.antisense = 0 then 0
         else t.tag_count
       end as antisense_count
from
  (select * from apidb.SageTagGeneFivePrime
   union all
   select * from apidb.SageTagGeneThreePrime) t
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SageTagAnalysisAttributes">
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="rad.Analysis"/>
    <externalDependency name="rad.AnalysisInput"/>
    <externalDependency name="rad.AnalysisResultImp"/>
    <externalDependency name="rad.Assay"/>
    <externalDependency name="rad.CompositeElementImp"/>
    <externalDependency name="rad.CompositeElementResultImp"/>
    <externalDependency name="rad.LogicalGroup"/>
    <externalDependency name="rad.LogicalGroupLink"/>
    <externalDependency name="rad.Protocol"/>
    <externalDependency name="rad.Quantification"/>
    <sql>
      <![CDATA[
create table apidb.SageTagAnalysisAttributes&1 NOLOGGING as
select dtr.analysis_id, max(dtr.float_value) as tag_count,
       max(ct.occurrence) as occurrence, substr(st.tag, 1, 30) as sequence,
       st.composite_element_id, a.name as library_name,
       library_total.total_count as library_total_tag_count,
       (max(dtr.float_value) * 100) / library_total.total_count
         as library_tag_percentage,
       r.tag_count as raw_count, tot.total_raw_count,
       100 *(r.tag_count / tot.total_raw_count ) as raw_percent
from dots.SageTagFeature stf, -- apidb.FeatureLocation nl,
     rad.DataTransformationResult dtr, rad.SageTag st, core.TableInfo ti,
     rad.AnalysisInput ai, rad.LogicalGroup lg, rad.LogicalGroupLink ll,
     rad.Assay a, core.TableInfo quant_ti, --core.DatabaseInfo di,
     rad.SageTagResult r, rad.Quantification q,
     (select source_id , count(*) as occurrence
      from dots.SageTagFeature
      group by source_id) ct,
     (select dt.analysis_id, sum(float_value) as total_count
      from rad.DataTransformationResult dt, rad.Analysis a, rad.Protocol p
      where dt.analysis_id = a.analysis_id
        and a.protocol_id = p.protocol_id
        and p.name = 'Normalization of SAGE tag frequencies to a target total intensity'
      group by dt.analysis_id) library_total,
     (select quantification_id, sum(tag_count) as total_raw_count
      from rad.SageTagResult
      group by quantification_id) tot
where ti.name = 'SAGETag'
  and quant_ti.name = 'Assay'
  --and di.name = 'RAD'
  and dtr.table_id = ti.table_id
  and st.composite_element_id = dtr.row_id
  and stf.source_id = st.composite_element_id
  and st.composite_element_id = r.composite_element_id
  and q.quantification_id = r.quantification_id
  and tot.quantification_id = r.quantification_id
--  and nl.na_feature_id = stf.na_feature_id
  and ct.source_id = stf.source_id
  and dtr.analysis_id = ai.analysis_id
  and ai.logical_group_id = lg.logical_group_id
  and lg.logical_group_id = ll.logical_group_id
  and ll.row_id = a.assay_id
  and a.name = q.name
  and ll.table_id = quant_ti.table_id
  --and di.database_id = quant_ti.database_id
  and dtr.analysis_id = library_total.analysis_id
group by stf.source_id, dtr.analysis_id, st.tag, st.composite_element_id,
         a.name, library_total.total_count,
         q.name, r.tag_count, tot.total_raw_count
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index apidb.staa_ix&1 on apidb.SageTagAnalysisAttributes&1 (analysis_id, composite_element_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.GeneAttributes">
    <internalDependency name="apidb.GeneId"/>
    <internalDependency name="apidb.GeneAlias"/>
    <internalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="apidb.GenomicSequence"/>
    <externalDependency name="apidb.AaSequenceAttribute"/>
    <externalDependency name="apidb.DeprecatedGenes"/>
    <externalDependency name="apidb.Profile"/>
    <externalDependency name="apidb.ProfileSet"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.AaFeatureImp"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.AaSequenceEnzymeClass"/>
    <externalDependency name="dots.AaSequenceImp"/>
    <externalDependency name="dots.GeneInstance"/>
    <externalDependency name="dots.GoAssociation"/>
    <externalDependency name="dots.GoAssociationInstance"/>
    <externalDependency name="dots.GoAssociationInstanceLoe"/>
    <externalDependency name="dots.GoAssocInstEvidCode"/>
    <externalDependency name="dots.NaFeatureComment"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="rad.Analysis"/>
    <externalDependency name="rad.AnalysisInput"/>
    <externalDependency name="rad.AnalysisResultImp"/>
    <externalDependency name="rad.CompositeElementImp"/>
    <externalDependency name="rad.LogicalGroup"/>
    <externalDependency name="rad.Protocol"/>
    <externalDependency name="sres.EnzymeClass"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.GoEvidenceCode"/>
    <externalDependency name="sres.GoRelationship"/>
    <externalDependency name="sres.GoTerm"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <intermediateTable name="apidb.GoTermList"/>
    <intermediateTable name="apidb.GeneGoAttributes"/>
    <intermediateTable name="apidb.DerisiExpn"/>
    <intermediateTable name="apidb.WinzelerExpn"/>
    <intermediateTable name="apidb.ToxoExpn"/>
    <intermediateTable name="apidb.GeneProteinAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GoTermList NOLOGGING AS
SELECT *
FROM (  -- work around sometime Oracle bug ORA-00942
      SELECT source_id, ontology, source,
             apidb.tab_to_string(CAST(COLLECT(name) AS apidb.varchartab), ', ')
               AS go_terms
      FROM (SELECT DISTINCT gf.source_id, o.ontology, gt.name,
                        DECODE(gail.name, 'Interpro', 'predicted', 'annotated')
                              AS source
            FROM dots.GeneFeature gf, dots.Transcript t,
                 dots.TranslatedAaFeature taf, dots.GoAssociation ga,
                 sres.GoTerm gt, dots.GoAssociationInstance gai,
                 dots.GoAssociationInstanceLoe gail,
                 dots.GoAssocInstEvidCode gaiec, sres.GoEvidenceCode gec,
                 (SELECT gr.child_term_id AS go_term_id, gp.name AS ontology
                  FROM sres.GoRelationship gr, sres.GoTerm gp
                  WHERE gr.parent_term_id = gp.go_term_id
                    AND gp.go_id in ('GO:0008150','GO:0003674','GO:0005575')) o
            WHERE gf.na_feature_id = t.parent_id
              AND t.na_feature_id = taf.na_feature_id
              AND taf.aa_sequence_id = ga.row_id
              AND ga.table_id = (SELECT table_id
                                 FROM core.TableInfo
                                 WHERE name = 'TranslatedAASequence')
              AND ga.go_term_id = gt.go_term_id
              AND ga.go_association_id = gai.go_association_id
              AND gai.go_assoc_inst_loe_id = gail.go_assoc_inst_loe_id
              AND gai.go_association_instance_id
                  = gaiec.go_association_instance_id
              AND gaiec.go_evidence_code_id = gec.go_evidence_code_id
              AND gt.go_term_id = o.go_term_id)
      GROUP BY source_id, ontology, source)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GeneGoAttributes NOLOGGING AS
SELECT DISTINCT gene.source_id,
       substr(annotated_go_component.go_terms, 1, 300) AS annotated_go_component,
       substr(annotated_go_function.go_terms, 1, 300) AS annotated_go_function,
       substr(annotated_go_process.go_terms, 1, 300) AS annotated_go_process,
       substr(predicted_go_component.go_terms, 1, 300) AS predicted_go_component,
       substr(predicted_go_function.go_terms, 1, 300) AS predicted_go_function,
       substr(predicted_go_process.go_terms, 1, 300) AS predicted_go_process
FROM (SELECT DISTINCT gene AS source_id FROM apidb.GeneId) gene,
     (SELECT * FROM apidb.GoTermList
      WHERE source = 'annotated' AND ontology = 'cellular_component')
       annotated_go_component,
     (SELECT * FROM apidb.GoTermList
      WHERE source = 'annotated' AND ontology = 'molecular_function')
       annotated_go_function,
     (SELECT * FROM apidb.GoTermList
      WHERE source = 'annotated' AND ontology = 'biological_process')
       annotated_go_process,
     (SELECT * FROM apidb.GoTermList
      WHERE source = 'predicted' AND ontology = 'cellular_component')
       predicted_go_component,
     (SELECT * FROM apidb.GoTermList
      WHERE source = 'predicted' AND ontology = 'molecular_function')
       predicted_go_function,
     (SELECT * FROM apidb.GoTermList
      WHERE source = 'predicted' AND ontology = 'biological_process')
       predicted_go_process
WHERE gene.source_id = annotated_go_component.source_id(+)
  AND 'annotated' = annotated_go_component.source(+)
  AND 'cellular_component' = annotated_go_component.ontology(+)
  AND gene.source_id = annotated_go_function.source_id(+)
  AND 'annotated' = annotated_go_function.source(+)
  AND 'molecular_function' = annotated_go_function.ontology(+)
  AND gene.source_id = annotated_go_process.source_id(+)
  AND 'annotated' = annotated_go_process.source(+)
  AND 'biological_process' = annotated_go_process.ontology(+)
  AND gene.source_id = predicted_go_component.source_id(+)
  AND 'predicted' = predicted_go_component.source(+)
  AND 'cellular_component' = predicted_go_component.ontology(+)
  AND gene.source_id = predicted_go_function.source_id(+)
  AND 'predicted' = predicted_go_function.source(+)
  AND 'molecular_function' = predicted_go_function.ontology(+)
  AND gene.source_id = predicted_go_process.source_id(+)
  AND 'predicted' = predicted_go_process.source(+)
  AND 'biological_process' = predicted_go_process.ontology(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneGoAttr_sourceId ON apidb.GeneGoAttributes (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.DerisiExpn NOLOGGING AS
SELECT gene.source_id, expn.derisi_max_level, derisi_max_pct,
       derisi_max_timing, derisi_min_timing, derisi_min_level,
       max_fold_induction as derisi_max_fold_induction
FROM (SELECT DISTINCT gene AS source_id from apidb.GeneId) gene,
     (SELECT * FROM (SELECT p.source_id,
                            p.max_expression AS derisi_max_level,
                            p.equiv_max AS derisi_max_timing,
                            p.equiv_min AS derisi_min_timing,
                            p.min_expression AS derisi_min_level,
                            p.ind_ratio as max_fold_induction,
                            row_number() over (partition by p.source_id order by p.ind_ratio desc) row_number
                     FROM apidb.Profile p, apidb.ProfileSet ps
                     WHERE ps.name like 'DeRisi % Smoothed Averaged'
                       AND p.profile_set_id = ps.profile_set_id)
      WHERE row_number = 1) expn,
     (SELECT p.source_id, max(p.max_percentile) as derisi_max_pct
      FROM apidb.Profile p, apidb.ProfileSet ps
      WHERE ps.name like 'DeRisi % Smoothed Averaged'
        AND p.profile_set_id = ps.profile_set_id
      GROUP BY p.source_id) percentile
WHERE gene.source_id = expn.source_id(+)
  AND gene.source_id = percentile.source_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Derisi_sourceId ON apidb.DerisiExpn (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.WinzelerExpn NOLOGGING AS
SELECT gene.source_id, expn.winzeler_max_level, winzeler_max_pct,
       winzeler_max_timing, winzeler_min_timing, winzeler_min_level
FROM (SELECT DISTINCT gene AS source_id from apidb.GeneId) gene,
     (SELECT p.source_id,
             p.max_expression AS winzeler_max_level,
             p.max_percentile AS winzeler_max_pct,
             p.time_of_max_expr AS winzeler_max_timing,
             p.time_of_min_expr AS winzeler_min_timing,
             p.min_expression AS winzeler_min_level
      FROM apidb.Profile p, apidb.ProfileSet ps, core.TableInfo ti
      WHERE ps.name = 'winzeler_cc_sorbExp'
        AND ti.name = 'GeneFeature'
        AND p.profile_set_id = ps.profile_set_id
        AND ti.table_id = p.subject_table_id) expn
WHERE gene.source_id = expn.source_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Winzeler_sourceId ON apidb.WinzelerExpn (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.ToxoExpn NOLOGGING AS
select g.source_id, 
       type3_type1_fold_change,
       type3_type2_fold_change,
       type2_type1_fold_change
From dots.genefeature g, 
     (select gf.source_id, dr.fold_change as type3_type1_fold_change
      from rad.analysis a, rad.differentialexpression dr, 
           core.tableinfo t, dots.genefeature gf
      where a.analysis_id = dr.analysis_id
       and dr.table_id = t.table_id
       and dr.row_id = gf.na_feature_id
       and t.name = 'GeneFeature'
       and a.name = 'Type3vsType1') type3vstype1,
 (select gf.source_id, dr.fold_change as type3_type2_fold_change
      from rad.analysis a, rad.differentialexpression dr, 
           core.tableinfo t, dots.genefeature gf
      where a.analysis_id = dr.analysis_id
       and dr.table_id = t.table_id
       and dr.row_id = gf.na_feature_id
       and t.name = 'GeneFeature'
       and a.name = 'Type3vsType2') type3vstype2,
 (select gf.source_id, dr.fold_change as type2_type1_fold_change
      from rad.analysis a, rad.differentialexpression dr, 
           core.tableinfo t, dots.genefeature gf
      where a.analysis_id = dr.analysis_id
       and dr.table_id = t.table_id
       and dr.row_id = gf.na_feature_id
       and t.name = 'GeneFeature'
       and a.name = 'Type2vsType1') type2vstype1
where g.source_id = type3vstype1.source_id
 and g.source_id = type3vstype2.source_id
 and g.source_id = type2vstype1.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Toxo_sourceId ON apidb.ToxoExpn (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GeneProteinAttributes NOLOGGING AS
SELECT gene.source_id,
       protein.tm_count, protein.molecular_weight,
       protein.isoelectric_point, protein.min_molecular_weight,
       protein.max_molecular_weight, protein.hydropathicity_gravy_score,
       protein.aromaticity_score, protein.cds_length, protein.protein_length,
       protein.ec_numbers,
       protein.signalp_scores,protein.signalp_peptide
FROM (SELECT DISTINCT gene AS source_id from apidb.GeneId) gene,
     (SELECT gf.source_id, taf.na_feature_id, tas.aa_sequence_id,tas.molecular_weight,
             tas.length AS protein_length,
             greatest(taf.translation_start, taf.translation_stop)
             - least(taf.translation_start, taf.translation_stop) + 1 AS cds_length,
             asa.isoelectric_point,
             asa.min_molecular_weight, asa.max_molecular_weight,
             asa.hydropathicity_gravy_score,
             asa.aromaticity_score,
             NVL(transmembrane.tm_domains, 0) AS tm_count,
             ec.ec_numbers,
             sigp.scores as signalp_scores,
             substr(sigp.pep, 1, 200) as signalp_peptide
      FROM  dots.GeneFeature gf, dots.Transcript t,
            dots.TranslatedAaFeature taf,
            dots.TranslatedAaSequence tas,
            apidb.AaSequenceAttribute asa,
            (SELECT aa_sequence_id, max(tm_domains) AS tm_domains
             FROM (SELECT tmaf.aa_sequence_id, COUNT(*) AS tm_domains
                   FROM dots.TransmembraneAaFeature tmaf, dots.AaLocation al
                   WHERE tmaf.aa_feature_id = al.aa_feature_id
                   GROUP BY tmaf.aa_sequence_id) tms
             GROUP BY tms.aa_sequence_id) transmembrane,
            (SELECT aa_sequence_id,
                    SUBSTR(apidb.tab_to_string(CAST(COLLECT(ec_number)
                                               AS apidb.varchartab), '; '),
                           1, 300)
                      AS ec_numbers
             FROM (SELECT DISTINCT asec.aa_sequence_id,
                          ec.ec_number || ' (' || ec.description || ')' AS ec_number
                   FROM dots.aaSequenceEnzymeClass asec, sres.enzymeClass ec
                   WHERE ec.enzyme_class_id = asec.enzyme_class_id)
             GROUP BY aa_sequence_id) ec,
             (SELECT spf.aa_sequence_id,'NN Sum: ' || ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) ||
              ', NN D: ' || round(((spf.means_score + spf.maxy_score) / 2),2) || ', HMM Prob: ' || round(spf.signal_probability,2) as scores,
               apidb.tab_to_string(CAST(COLLECT(decode(spf.algorithm_name,'SignalPhmm','HMM: ','NN: ') || dbms_lob.substr(s.sequence,aal.end_max,1)) AS apidb.varchartab), ', ') as pep
              FROM dots.signalpeptidefeature spf, dots.aalocation aal,dots.AASEQUENCE s
              WHERE spf.aa_sequence_id = s.aa_sequence_id 
              and  aal.aa_feature_id = spf.aa_feature_id
              and (spf.signal_probability >= .5
              or ((spf.means_score + spf.maxy_score) / 2) >= .5
              or ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) >= 3)
              group by spf.aa_sequence_id,'NN Sum: ' || ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) ||
              ', NN D: ' || round(((spf.means_score + spf.maxy_score) / 2),2) || ', HMM Prob: ' || round(spf.signal_probability,2)) sigp
      WHERE gf.na_feature_id = t.parent_id
        AND t.na_feature_id = taf.na_feature_id
        AND taf.aa_sequence_id = tas.aa_sequence_id
        AND taf.aa_sequence_id = asa.aa_sequence_id
        and tas.aa_sequence_id = sigp.aa_sequence_id(+)
        AND tas.aa_sequence_id = transmembrane.aa_sequence_id(+)
        AND tas.aa_sequence_id = ec.aa_sequence_id(+)) protein
WHERE gene.source_id = protein.source_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GPA_sourceId ON apidb.GeneProteinAttributes (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GeneAttributes&1 NOLOGGING AS
SELECT CASE
         WHEN SUBSTR(tn.name, 1, 6) = 'Crypto'
           THEN 'CryptoDB'
         WHEN SUBSTR(tn.name, 1, 6) = 'Plasmo'
           THEN 'PlasmoDB'
         WHEN SUBSTR(tn.name, 1, 4) = 'Toxo'
           THEN 'ToxoDB'
         WHEN tn.name like 'Neospora%'
           THEN 'ToxoDB'
         WHEN SUBSTR(tn.name, 1, 5) = 'Trich'
           THEN 'TrichDB'
         WHEN SUBSTR(tn.name, 1, 7) = 'Giardia'
           THEN 'GiardiaDB'
         ELSE 'ERROR: setting project in tuningManager'
       END as project_id,
       gf.source_id, gf.na_feature_id,
       REPLACE(so.term_name, '_', ' ') AS gene_type,
       SUBSTR(gf.product, 1, 200) AS product,
       gf.is_pseudo,
       LEAST(nl.start_min, nl.end_max) AS start_min,
       GREATEST(nl.start_min, nl.end_max) AS end_max,
       first_exon.coding_start,
       last_exon.coding_end,
       nl.is_reversed,
       sns.length AS transcript_length,
       GREATEST(0, least(nl.start_min, nl.end_max) - 15000)
           AS context_start,
       LEAST(sequence.length, greatest(nl.start_min, nl.end_max) + 15000)
           AS context_end,
       DECODE(nvl(nl.is_reversed, 0), 0, 'forward', 1, 'reverse',
              nl.is_reversed) AS strand,
       SUBSTR(sequence.source_id, 1, 50) AS sequence_id,
       SUBSTR(tn.name, 1, 40) AS organism,
       taxon.ncbi_tax_id,
       so_id, SUBSTR(so.term_name, 1, 150) AS so_term_name,
       SUBSTR(so.definition, 1, 150) AS so_term_definition,
       so.ontology_name, SUBSTR(so.so_version, 1, 7) AS so_version,
       SUBSTR(NVL(rt1.anticodon, rt2.anticodon), 1, 3) AS anticodon,
       protein.tm_count, protein.molecular_weight,
       protein.isoelectric_point, protein.min_molecular_weight,
       protein.max_molecular_weight, protein.hydropathicity_gravy_score,
       protein.aromaticity_score, protein.cds_length, protein.protein_length,
       protein.ec_numbers,
       ed.name AS external_db_name,
       SUBSTR(edr.version, 1, 10) AS external_db_version,
       exons.exon_count, SUBSTR(cmnt.comment_string, 1, 300) AS comment_string,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.chromosome_order_num, sequence.na_sequence_id,
       go.annotated_go_component,
       go.annotated_go_function,
       go.annotated_go_process,
       go.predicted_go_component,
       go.predicted_go_function,
       go.predicted_go_process,
       DerisiExpn.derisi_max_level,
       DerisiExpn.derisi_max_pct,
       DerisiExpn.derisi_max_timing,
       DerisiExpn.derisi_min_timing,
       DerisiExpn.derisi_min_level,
       DerisiExpn.derisi_max_fold_induction,
       WinzelerExpn.winzeler_max_level,
       WinzelerExpn.winzeler_max_pct,
       WinzelerExpn.winzeler_max_timing,
       WinzelerExpn.winzeler_min_timing,
       WinzelerExpn.winzeler_min_level,
       ToxoExpn.type3_type1_fold_change,
       ToxoExpn.type3_type2_fold_change,
       ToxoExpn.type2_type1_fold_change,
       nvl(deprecated.is_deprecated, 0) as is_deprecated, gi.gene_id,
       nvl(totsnps.total_snps,0) as total_snps, 
       nvl(nssnps.nonsyn_snps,0) as nonsynonymous_snps,
       nvl(synsnps.syn_snps,0) as synonymous_snps,
       CASE WHEN (nssnps.nonsyn_snps is null or synsnps.syn_snps is null) THEN 0 
            ELSE round((nssnps.nonsyn_snps / synsnps.syn_snps),2) END as nonsyn_syn_ratio,
       protein.signalp_scores,protein.signalp_peptide
FROM dots.GeneFeature gf, apidb.FeatureLocation nl, sres.SequenceOntology so,
     sres.Taxon, sres.TaxonName tn, dots.RnaType rt1, dots.RnaType rt2,
     dots.Transcript t, sres.ExternalDatabase ed,
     sres.ExternalDatabaseRelease edr, dots.SplicedNaSequence sns,
     apidb.GeneProteinAttributes protein, apidb.GeneGoAttributes go,
     apidb.DerisiExpn DerisiExpn, apidb.WinzelerExpn WinzelerExpn,
     apidb.ToxoExpn ToxoExpn, apidb.GenomicSequence sequence,
     dots.geneinstance gi,
     (SELECT parent_id, count(*) AS exon_count
      FROM dots.ExonFeature
      GROUP BY parent_id) exons,
     (SELECT ef.parent_id, fl.coding_start
      FROM dots.ExonFeature ef, apidb.FeatureLocation fl
      WHERE ef.order_number = 1
        AND ef.na_feature_id = fl.na_feature_id
        AND fl.is_top_level = 1) first_exon,
     (SELECT ef.parent_id, ef.order_number, fl.coding_end
      FROM dots.ExonFeature ef, apidb.FeatureLocation fl
      WHERE ef.na_feature_id = fl.na_feature_id
        AND fl.is_top_level = 1) last_exon,
     (SELECT nfc.na_feature_id,
             MAX(DBMS_LOB.SUBSTR(nfc.comment_string, 300, 1))
               AS comment_string
      FROM dots.NaFeatureComment nfc
      GROUP BY nfc.na_feature_id) cmnt,
     (SELECT distinct source_id, 1 as is_deprecated from apidb.DeprecatedGenes) deprecated,
     (select sf.parent_id,count(*) as total_snps
      from dots.snpfeature sf, sres.externaldatabaserelease rel, sres.EXTERNALDATABASE d
      where d.name not in ('Broad SNPs','Sanger falciparum SNPs',
            'Winzeler Array - Plasmodium Genetic Variation','Su SNPs','Sanger reichenowi SNPs')
      and d.external_database_id = rel.external_database_id
      and sf.external_database_release_id = rel.external_database_release_id
      and sf.parent_id is not null
      group by sf.parent_id) totsnps,
      (select sf.parent_id,count(*) as nonsyn_snps
       from dots.snpfeature sf, sres.externaldatabaserelease rel, sres.EXTERNALDATABASE d
       where d.name not in ('Broad SNPs','Sanger falciparum SNPs',
             'Winzeler Array - Plasmodium Genetic Variation','Su SNPs','Sanger reichenowi SNPs')
       and d.external_database_id = rel.external_database_id
       and sf.external_database_release_id = rel.external_database_release_id
       and sf.parent_id is not null
       and sf.has_nonsynonymous_allele = 1
       group by sf.parent_id) nssnps,
      (select sf.parent_id,count(*) as syn_snps
       from dots.snpfeature sf, sres.externaldatabaserelease rel, sres.EXTERNALDATABASE d
       where d.name not in ('Broad SNPs','Sanger falciparum SNPs',
             'Winzeler Array - Plasmodium Genetic Variation','Su SNPs','Sanger reichenowi SNPs')
       and d.external_database_id = rel.external_database_id
       and sf.external_database_release_id = rel.external_database_release_id
       and sf.parent_id is not null
       and sf.has_nonsynonymous_allele is null
       and sf.is_coding = 1
       group by sf.parent_id) synsnps
WHERE gf.source_id is not null
  AND gf.na_feature_id = nl.na_feature_id
  AND nl.is_top_level = 1
  AND nl.na_sequence_id = sequence.na_sequence_id
  AND gf.sequence_ontology_id = so.sequence_ontology_id
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
  AND gf.source_id = protein.source_id(+)
  AND gf.source_id = go.source_id(+)
  AND gf.source_id = DerisiExpn.source_id(+)
  AND gf.source_id = WinzelerExpn.source_id(+)
  AND gf.source_id = ToxoExpn.source_id(+)
  AND t.na_sequence_id = sns.na_sequence_id(+)
  AND gf.na_feature_id = t.parent_id(+)
  AND t.na_feature_id = rt1.parent_id(+)
  AND gf.na_feature_id = rt2.parent_id(+)
  AND gf.external_database_release_id
       = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND gf.na_feature_id = exons.parent_id(+)
  AND gf.na_feature_id = first_exon.parent_id(+)
  AND exons.parent_id = last_exon.parent_id(+)
  AND exons.exon_count = last_exon.order_number(+)
  AND gf.na_feature_id = cmnt.na_feature_id(+)
  AND gf.source_id = deprecated.source_id(+)
  AND gf.na_feature_id = gi.na_feature_id(+)
  AND gf.na_feature_id = totsnps.parent_id(+)
  AND gf.na_feature_id = nssnps.parent_id(+)
  AND gf.na_feature_id = synsnps.parent_id(+)
  -- skip toxo predictions (except tRNAs)
  -- skip new plasmo annotation
  AND ed.name NOT IN ('GLEAN predictions', 'GlimmerHMM predictions',
                      'TigrScan', 'TwinScan predictions',
                      'TwinScanEt predictions',
                      'Annotation for T. gondii ME49 - typeII:2005-08-01',
                      'Old annotation for ME49','P. falciparum Evigan Gene Models',
                      'Pfalciparum workshop annotations reviewed and changed',
                      'Annotation for T. gondii ME49 - typeII:2005-08-01')
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.GeneAttr_sourceId&1
       ON apidb.GeneAttributes&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneAttr_exon_ix&1
       ON apidb.GeneAttributes&1 (exon_count, source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneAttr_loc_ix&1
       ON apidb.GeneAttributes&1 (na_sequence_id, start_min, end_max, is_reversed)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneAttr_feat_ix&1
       ON apidb.GeneAttributes&1 (na_feature_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GeneAttr_geneid_ix&1
       ON apidb.GeneAttributes&1 (gene_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.GenomicSequence">
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.SequenceOntology"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GenomicSequence&1 NOLOGGING AS
  SELECT ens.na_sequence_id, ens.taxon_id,
         SUBSTR(ens.source_id, 1, 50) AS source_id,
         LOWER(SUBSTR(ens.source_id, 1, 50)) AS lowercase_source_id,
         ens.a_count, ens.c_count, ens.g_count, ens.t_count, ens.length,
         SUBSTR(ens.description, 1, 400) AS description,
         ens.external_database_release_id,
         SUBSTR(ens.chromosome, 1, 40) AS chromosome,
         ens.chromosome_order_num, ens.sequence_ontology_id
  FROM dots.ExternalNaSequence ens, sres.SequenceOntology so
  WHERE ens.sequence_ontology_id = so.sequence_ontology_id
    AND so.term_name != 'EST'
    AND -- see both? use the VirtualSequence.
        ens.source_id IN (SELECT source_id FROM dots.ExternalNaSequence
                         MINUS
                          SELECT source_id FROM dots.VirtualSequence)
UNION
  SELECT na_sequence_id, taxon_id, SUBSTR(source_id, 1, 50) AS source_id,
         LOWER(SUBSTR(source_id, 1, 50)) AS lowercase_source_id,
         a_count, c_count, g_count, t_count, length,
         SUBSTR(description, 1, 400) AS description,
         external_database_release_id, SUBSTR(chromosome, 1, 40) AS chromosome,
         chromosome_order_num, sequence_ontology_id
  FROM dots.VirtualSequence
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GS_sourceId&1 ON apidb.GenomicSequence&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GS_lcSourceId&1 ON apidb.GenomicSequence&1 (lowercase_source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.GS_naSeqId&1 ON apidb.GenomicSequence&1 (na_sequence_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SequenceAttributes">
    <internalDependency name="apidb.GenomicSequence"/>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="dots.SequencePiece"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.SequenceAttributes&1 NOLOGGING AS
SELECT CASE
         WHEN SUBSTR(tn.name, 1, 6) = 'Crypto'
           THEN 'CryptoDB'
         WHEN SUBSTR(tn.name, 1, 6) = 'Plasmo'
           THEN 'PlasmoDB'
         WHEN SUBSTR(tn.name, 1, 4) = 'Toxo'
           THEN 'ToxoDB'
         WHEN tn.name like 'Neospora%'
           THEN 'ToxoDB'
         WHEN SUBSTR(tn.name, 1, 5) = 'Trich'
           THEN 'TrichDB'
         WHEN SUBSTR(tn.name, 1, 7) = 'Giardia'
           THEN 'GiardiaDB'
         ELSE 'ERROR: setting project in tuningManager'
       END as project_id,
       SUBSTR(sequence.source_id, 1, 60) AS source_id, sequence.a_count,
       sequence.c_count, sequence.g_count, sequence.t_count,
       (sequence.length
        - (sequence.a_count + sequence.c_count + sequence.g_count + sequence.t_count))
         AS other_count,
       sequence.length,
       to_char((sequence.a_count + sequence.t_count) / sequence.length * 100, '99.99')
         AS at_percent,
       SUBSTR(tn.name, 1, 40) AS organism,
       taxon.ncbi_tax_id,
       SUBSTR(sequence.description, 1, 400) AS sequence_description,
       SUBSTR(genbank.genbank_accession, 1, 20) AS genbank_accession,
       SUBSTR(db.database_version, 1, 30) AS database_version, db.database_name,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.chromosome_order_num, so.so_id,
       nvl(virtualization.is_top_level, 1) as is_top_level,
       sequence.na_sequence_id
FROM sres.TaxonName tn, sres.Taxon, sres.SequenceOntology so,
     apidb.GenomicSequence sequence,
     (SELECT drns.na_sequence_id, max(dr.primary_identifier) AS genbank_accession
      FROM dots.dbrefNaSequence drns, sres.DbRef dr,
           sres.ExternalDatabaseRelease gb_edr, sres.ExternalDatabase gb_ed
      WHERE drns.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
            = gb_edr.external_database_release_id
        AND gb_edr.external_database_id = gb_ed.external_database_id
        AND gb_ed.name = 'GenBank'
      GROUP BY drns.na_sequence_id) genbank,
     (SELECT edr.external_database_release_id,
             edr.version AS database_version, ed.name AS database_name
      FROM sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      WHERE edr.external_database_id = ed.external_database_id) db,
     (SELECT piece_na_sequence_id, 0 as is_top_level
      FROM dots.SequencePiece) virtualization
WHERE sequence.taxon_id = tn.taxon_id(+)
  AND tn.name_class = 'scientific name'
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.sequence_ontology_id = so.sequence_ontology_id
  AND so.term_name IN ('chromosome', 'contig', 'supercontig')
  AND sequence.na_sequence_id = genbank.na_sequence_id(+)
  AND sequence.external_database_release_id = db.external_database_release_id(+)
  AND sequence.na_sequence_id = virtualization.piece_na_sequence_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.SeqAttr_source_id&1 ON apidb.SequenceAttributes&1 (source_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SnpAttributes">
    <internalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <sql>
      <![CDATA[
       CREATE TABLE apidb.SnpAttributes&1 NOLOGGING AS
       SELECT CASE
         WHEN SUBSTR(tn.name, 1, 6) = 'Crypto'
           THEN 'CryptoDB'
         WHEN SUBSTR(tn.name, 1, 6) = 'Plasmo'
           THEN 'PlasmoDB'
         WHEN SUBSTR(tn.name, 1, 4) = 'Toxo'
           THEN 'ToxoDB'
         WHEN tn.name like 'Neospora%'
           THEN 'ToxoDB'
         WHEN SUBSTR(tn.name, 1, 5) = 'Trich'
           THEN 'TrichDB'
         WHEN SUBSTR(tn.name, 1, 7) = 'Giardia'
           THEN 'GiardiaDB'
         ELSE 'ERROR: setting project in tuningManager'
       END as project_id,
       snp.source_id,
       snp.na_feature_id,
       CASE WHEN ed.name = 'Su SNPs' THEN 'NIH SNPs'
       ELSE ed.name END AS dataset,
       CASE WHEN ed.name = 'Su SNPs' THEN 'Su_SNPs'
       WHEN ed.name = 'Broad SNPs' THEN 'Broad_SNPs'
       WHEN ed.name = 'Sanger falciparum SNPs' THEN 'sangerItGhanaSnps'
       WHEN ed.name = 'Sanger reichenowi SNPs' THEN 'sangerReichenowiSnps'
       WHEN ed.name = 'PlasmoDB combined SNPs' THEN 'plasmoDbCombinedSnps'
       END AS dataset_hidden,
       sequence.na_sequence_id,
       sequence.source_id AS seq_source_id,
       snp_loc.start_min,
       SUBSTR(snp.reference_strain, 1, 200) AS reference_strain,
       SUBSTR(snp.reference_na, 1, 200) AS reference_na,
       DECODE(snp.is_coding, 0, 'no', 1, 'yes') AS is_coding,
       snp.position_in_CDS,
       snp.position_in_protein,
       SUBSTR(snp.reference_aa, 1, 200) AS reference_aa,
       DECODE(snp.has_nonsynonymous_allele, 0, 'no', 1, 'yes')
         AS has_nonsynonymous_allele,
       SUBSTR(snp.major_allele, 1, 40) AS major_allele,
       SUBSTR(snp.major_product, 1, 40) AS major_product,
       SUBSTR(strain_info.minor_allele, 1, 40) AS minor_allele,
       SUBSTR(strain_info.minor_product, 1, 40) AS minor_product,
       strain_info.major_strains,strain_info.minor_strains,
       snp.major_allele_count, 
       round(snp.major_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as major_allele_frequency,
       snp.minor_allele_count,
       round(snp.minor_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as minor_allele_frequency,
       snp.major_allele_count + snp.minor_allele_count as strain_count,
       SUBSTR(snp.strains, 1, 1000) AS strains,
       SUBSTR(snp.strains_revcomp, 1, 1000) AS strains_revcomp,
       gene_info.source_id AS gene_source_id,
       DECODE(gene_info.is_reversed, 0, 'forward', 1, 'reverse')
         AS gene_strand,
       SUBSTR(DBMS_LOB.SUBSTR(sequence.sequence, 60, snp_loc.start_min - 60), 1, 60)
         AS lflank,
       SUBSTR(DBMS_LOB.SUBSTR(sequence.sequence, 60, snp_loc.start_min + 1), 1, 60)
         AS rflank,
       SUBSTR(tn.name, 1, 40) AS organism,
       taxon.ncbi_tax_id,
       SUBSTR(chromosome_info.chromosome, 1, 20) AS chromosome,
       chromosome_info.chromosome_order_num
FROM dots.SnpFeature snp, apidb.FeatureLocation snp_loc,
     sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, sres.Taxon,
     sres.TaxonName tn, dots.NaSequence sequence,
     (SELECT gene.source_id, gene_loc.is_reversed, gene.na_feature_id,
             gene_loc.na_sequence_id
      FROM dots.GeneFeature gene, apidb.FeatureLocation gene_loc
      WHERE gene.na_feature_id = gene_loc.na_feature_id
            and gene_loc.is_top_level = 1) gene_info,
     (SELECT na_sequence_id, chromosome, chromosome_order_num
      FROM dots.ExternalNaSequence
     UNION
      SELECT na_sequence_id, chromosome, chromosome_order_num
      FROM dots.VirtualSequence
     UNION
      SELECT na_sequence_id, null as chromosome, null as chromosome_order_num
      FROM dots.NaSequence
      WHERE subclass_view not in ('ExternalNASequence', 'VirtualSequence')
     ) chromosome_info,
     (select sf.na_feature_id, 
             apidb.tab_to_string(CAST(COLLECT(distinct CASE WHEN sv.allele != sf.major_allele THEN sv.allele END) AS apidb.varchartab), ', ') as minor_allele,                
             apidb.tab_to_string(CAST(COLLECT(distinct CASE WHEN sv.allele != sf.major_allele THEN sv.product END) AS apidb.varchartab), ', ') as minor_product,
             apidb.tab_to_string(CAST(COLLECT(CASE WHEN sv.allele != sf.major_allele THEN sv.strain END) AS apidb.varchartab), ', ') as minor_strains,
             apidb.tab_to_string(CAST(COLLECT(CASE WHEN sv.allele = sf.major_allele THEN sv.strain END) AS apidb.varchartab), ', ') as major_strains
      from dots.SNPFEATURE sf, dots.SEQVARIATION sv
      where sv.parent_id = sf.na_feature_id
      group by sf.na_feature_id) strain_info
WHERE edr.external_database_release_id = snp.external_database_release_id
  AND ed.external_database_id = edr.external_database_id
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
  AND snp_loc.na_feature_id = snp.na_feature_id
  AND snp_loc.is_top_level = 1
  AND sequence.na_sequence_id = snp_loc.na_sequence_id
  AND chromosome_info.na_sequence_id = snp_loc.na_sequence_id
  and strain_info.na_feature_id = snp.na_feature_id
  AND gene_info.na_feature_id(+) = snp.parent_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.SnpAttr_source_id&1 ON apidb.SnpAttributes&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create INDEX apidb.Snp_nafeat_dataset_ix&1
       ON apidb.SnpAttributes&1 (na_feature_id, dataset)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Snp_Seq_ix&1
       ON apidb.SnpAttributes&1 (na_sequence_id, dataset, start_min, na_feature_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Snp_Freq_ix&1
       ON apidb.SnpAttributes&1 (dataset,strain_count,major_allele_frequency,minor_allele_frequency)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.OrfAttributes">
    <internalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="apidb.GenomicSequence"/>
    <externalDependency name="dots.AaFeatureImp"/>
    <externalDependency name="dots.AaSequenceImp"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.OrfAttributes&1 NOLOGGING AS
SELECT distinct CASE
         WHEN SUBSTR(tn.name, 1, 6) = 'Crypto'
           THEN 'CryptoDB'
         WHEN SUBSTR(tn.name, 1, 6) = 'Plasmo'
           THEN 'PlasmoDB'
         WHEN SUBSTR(tn.name, 1, 4) = 'Toxo'
           THEN 'ToxoDB'
         WHEN tn.name like 'Neospora%'
           THEN 'ToxoDB'
         WHEN SUBSTR(tn.name, 1, 5) = 'Trich'
           THEN 'TrichDB'
         WHEN SUBSTR(tn.name, 1, 7) = 'Giardia'
           THEN 'GiardiaDB'
         ELSE 'ERROR: setting project in tuningManager'
       END as project_id,
       SUBSTR(m.source_id, 1, 60) AS source_id,
       LOWER(SUBSTR(m.source_id, 1, 60)) AS lowercase_source_id,
       SUBSTR(tn.name, 1, 40) AS organism,
       taxon.ncbi_tax_id,
       SUBSTR(sequence.source_id, 1, 30) AS nas_id,
       tas.length,
       nl.start_min, nl.end_max, nl.is_reversed,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.chromosome_order_num, sequence.na_sequence_id
FROM dots.Miscellaneous m, dots.TranslatedAaFeature taaf,
     dots.TranslatedAaSequence tas, sres.Taxon, sres.TaxonName tn,
     sres.SequenceOntology so, apidb.FeatureLocation nl,
     (  select gs.na_sequence_id, gs.source_id, gs.chromosome, gs.chromosome_order_num, gs.taxon_id
        from apidb.GenomicSequence gs
      union
        select ens.na_sequence_id, ens.source_id, ens.chromosome, ens.chromosome_order_num, ens.taxon_id
        from dots.ExternalNaSequence ens
        where ens.na_sequence_id in (select distinct na_sequence_id from dots.Miscellaneous
                                  minus select na_sequence_id
                                        from apidb.GenomicSequence)) sequence
WHERE m.na_feature_id = taaf.na_feature_id
  AND taaf.aa_sequence_id = tas.aa_sequence_id
  AND sequence.na_sequence_id = nl.na_sequence_id
  AND sequence.taxon_id = tn.taxon_id
  AND sequence.taxon_id = taxon.taxon_id
  AND m.sequence_ontology_id = so.sequence_ontology_id
  AND m.na_feature_id = nl.na_feature_id
  AND nl.is_top_level = 1
  AND so.term_name = 'ORF'
  AND tn.name_class='scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.OrfAttr_source_id&1 ON apidb.OrfAttributes&1 (source_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.EstAttributes">
    <externalDependency name="dots.AssemblySequence"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.Est"/>
    <externalDependency name="dots.Library"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.EstAttributes&1 NOLOGGING AS
SELECT CASE
         WHEN SUBSTR(tn.name, 1, 6) = 'Crypto'
           THEN 'CryptoDB'
         WHEN SUBSTR(tn.name, 1, 6) = 'Plasmo'
           THEN 'PlasmoDB'
         WHEN SUBSTR(tn.name, 1, 4) = 'Toxo'
           THEN 'ToxoDB'
         WHEN tn.name like 'Neospora%'
           THEN 'ToxoDB'
         WHEN SUBSTR(tn.name, 1, 5) = 'Trich'
           THEN 'TrichDB'
         WHEN SUBSTR(tn.name, 1, 7) = 'Giardia'
           THEN 'GiardiaDB'
         ELSE 'ERROR: setting project in tuningManager'
       END as project_id,
       ens.source_id,
       e.seq_primer AS primer,
       ens.a_count,
       ens.c_count,
       ens.g_count,
       ens.t_count,
       (ens.length - (ens.a_count + ens.c_count + ens.g_count + ens.t_count))
         AS other_count,
       ens.length,
       l.dbest_name,
       NVL(l.vector, 'unknown') AS vector,
       NVL(l.stage, 'unknown') AS stage,
       SUBSTR(tn.name, 1, 40) AS organism,
       taxon.ncbi_tax_id,
       ed.name AS external_db_name,
       nvl(best.best_alignment_count, 0) AS best_alignment_count,
       l.library_id, l.dbest_name as library_dbest_name,
       aseq.assembly_na_sequence_id, asm.source_id as assembly_source_id,
       asm.number_of_contained_sequences AS assembly_est_count
FROM dots.Est e, dots.ExternalNaSequence ens, dots.Library l, sres.Taxon,
     sres.TaxonName tn, sres.ExternalDatabase ed,
     sres.ExternalDatabaseRelease edr, sres.SequenceOntology so,
     dots.AssemblySequence aseq, dots.Assembly asm,
     (select query_na_sequence_id,max(ct) as best_alignment_count
      from (
            SELECT query_na_sequence_id, COUNT(*) AS ct
             FROM dots.BlatAlignment ba
             WHERE is_best_alignment = 1
             GROUP BY target_external_db_release_id,query_na_sequence_id)
      group by query_na_sequence_id) best
WHERE e.na_sequence_id = ens.na_sequence_id
  AND e.library_id = l.library_id
  AND ens.taxon_id = tn.taxon_id
  AND ens.taxon_id = taxon.taxon_id
  AND tn.name_class='scientific name'
  AND ens.external_database_release_id = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ens.sequence_ontology_id = so.sequence_ontology_id
  AND so.term_name = 'EST'
  AND best.query_na_sequence_id(+) = ens.na_sequence_id
  AND ens.na_sequence_id = aseq.na_sequence_id(+)
  AND aseq.assembly_na_sequence_id = asm.na_sequence_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.EstAttr_source_id&1 ON apidb.EstAttributes&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.EstAttr_seqsrc_id&1 ON apidb.EstAttributes&1 (assembly_source_id, source_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.AssemblyAttributes">
    <sql>
      <![CDATA[
CREATE TABLE apidb.AssemblyAttributes&1 NOLOGGING AS
SELECT a.source_id,
       CASE
         WHEN SUBSTR(tn.name, 1, 6) = 'Crypto'
           THEN 'CryptoDB'
         WHEN SUBSTR(tn.name, 1, 6) = 'Plasmo'
           THEN 'PlasmoDB'
         WHEN SUBSTR(tn.name, 1, 4) = 'Toxo'
           THEN 'ToxoDB'
         WHEN tn.name like 'Neospora%'
           THEN 'ToxoDB'
         WHEN SUBSTR(tn.name, 1, 5) = 'Trich'
           THEN 'TrichDB'
         WHEN SUBSTR(tn.name, 1, 7) = 'Giardia'
           THEN 'GiardiaDB'
         ELSE 'ERROR: setting project in tuningManager'
       END as project_id,
       tn.name AS organism,
       a.number_of_contained_sequences AS est_count,
       a.length,
       a.a_count,
       a.c_count,
       a.g_count,
       a.t_count,
       a.other_count
FROM  dots.Assembly a, sres.TaxonName tn
WHERE a.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.AsmAttr_source_id&1
ON apidb.AssemblyAttributes&1 (source_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.ArrayElementAttributes">
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.ArrayElementAttributes&1 NOLOGGING AS
SELECT CASE
         WHEN SUBSTR(tn.name, 1, 6) = 'Crypto'
           THEN 'CryptoDB'
         WHEN SUBSTR(tn.name, 1, 6) = 'Plasmo'
           THEN 'PlasmoDB'
         WHEN SUBSTR(tn.name, 1, 4) = 'Toxo'
           THEN 'ToxoDB'
         WHEN tn.name like 'Neospora%'
           THEN 'ToxoDB'
         WHEN SUBSTR(tn.name, 1, 5) = 'Trich'
           THEN 'TrichDB'
         WHEN SUBSTR(tn.name, 1, 7) = 'Giardia'
           THEN 'GiardiaDB'
         ELSE 'ERROR: setting project in tuningManager'
       END as project_id,
       ens.source_id, ed.name AS provider,
       SUBSTR(tn.name, 1, 40) AS organism,
       taxon.ncbi_tax_id
FROM sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr,
     dots.ExternalNaSequence ens, sres.TaxonName tn, sres.Taxon,
     sres.SequenceOntology so
WHERE ens.external_database_release_id = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND tn.taxon_id = ens.taxon_id
  AND tn.name_class = 'scientific name'
  AND taxon.taxon_id = ens.taxon_id
  AND ens.sequence_ontology_id = so.sequence_ontology_id
  AND so.term_name = 'oligo'
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.AEAttr_source_id&1
ON apidb.ArrayElementAttributes&1 (source_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.BlatAlignmentLocation">
    <externalDependency name="dots.NaSequenceImp"/>
    <sql>
      <![CDATA[ 
      CREATE TABLE apidb.BlatAlignmentLocation&1 NOLOGGING AS
      SELECT blat_alignment_id, query_na_sequence_id, target_na_sequence_id,
             query_table_id, query_taxon_id, query_external_db_release_id,
             target_table_id, target_taxon_id, target_external_db_release_id,
             is_consistent, is_genomic_contaminant, unaligned_3p_bases,
             unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
             is_5p_complete, percent_identity, max_query_gap, max_target_gap,
             number_of_spans, query_start, query_end, target_start, target_end,
             is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
             is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
             tstarts, cast('direct' as varchar2(7)) as location_mapping
      FROM dots.BlatAlignment
      ]]> 
    </sql>
    <perl>
      <![CDATA[ 
      use strict;
      use lib "$ENV{GUS_HOME}/lib/perl";

      my $sql = <<SQL;
        select blat_alignment_id, query_na_sequence_id, target_na_sequence_id,
               query_table_id, query_taxon_id, query_external_db_release_id, 
               target_table_id, target_taxon_id, target_external_db_release_id,
               is_consistent, is_genomic_contaminant, unaligned_3p_bases,
               unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
               is_5p_complete, percent_identity, max_query_gap, max_target_gap,
               number_of_spans, query_start, query_end, target_start, target_end,
               is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
               is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
               tstarts, sp.virtual_na_sequence_id, sp.distance_from_left,
               sp.strand_orientation, virtualseq.length, vti.table_id as virtual_target_table_id
        from dots.BlatAlignment ba, apidb.SequencePieceClosure sp, dots.NaSequence virtualseq,
             core.TableInfo vti
        where ba.target_na_sequence_id = sp.piece_na_sequence_id(+)
          and sp.virtual_na_sequence_id = virtualseq.na_sequence_id
          and virtualseq.subclass_view = vti.name
SQL
      
      my $queryHandle = $dbh->prepare($sql);
      $queryHandle->execute();

      $sql = <<SQL;
        insert into apidb.BlatAlignmentLocation&1(blat_alignment_id,
               query_na_sequence_id, target_na_sequence_id,
               query_table_id, query_taxon_id, query_external_db_release_id, 
               target_table_id, target_taxon_id, target_external_db_release_id,
               is_consistent, is_genomic_contaminant, unaligned_3p_bases,
               unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
               is_5p_complete, percent_identity, max_query_gap, max_target_gap,
               number_of_spans, query_start, query_end, target_start, target_end,
               is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
               is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
               tstarts, location_mapping)
         values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?)
SQL

      my $insertHandle = $dbh->prepare($sql);
      my ($virtual_target_start, $virtual_target_end, $virtual_tstarts);

      while (my ($blat_alignment_id, $query_na_sequence_id, $target_na_sequence_id,
               $query_table_id, $query_taxon_id, $query_external_db_release_id,
               $target_table_id, $target_taxon_id, $target_external_db_release_id,
               $is_consistent, $is_genomic_contaminant, $unaligned_3p_bases,
               $unaligned_5p_bases, $has_3p_polya, $has_5p_polya, $is_3p_complete,
               $is_5p_complete, $percent_identity, $max_query_gap, $max_target_gap,
               $number_of_spans, $query_start, $query_end, $target_start, $target_end,
               $is_reversed, $query_bases_aligned, $repeat_bases_aligned, $num_ns, $score,
               $is_best_alignment, $blat_alignment_quality_id, $blocksizes, $qstarts,
               $tstarts, $virtual_na_sequence_id, $distance_from_left,
               $strand_orientation, $length, $virtual_target_table_id)
             = $queryHandle->fetchrow_array()) {

        if ($virtual_na_sequence_id) {
          if ($strand_orientation eq '-') {
            $virtual_target_start = $distance_from_left + $length - $target_end;
            $virtual_target_end = $distance_from_left + $length - $target_start;
            $virtual_tstarts = &getReversedTstarts($distance_from_left,$length,$tstarts,$blocksizes);
          } else {
            $virtual_target_start = $target_start + $distance_from_left;
            $virtual_target_end = $target_end + $distance_from_left;
            $virtual_tstarts = join( ',', map{ $_ + $distance_from_left } split( /,/, $tstarts));
          }

          # insert virtual locations
          $insertHandle->execute($blat_alignment_id,
                 $query_na_sequence_id, $virtual_na_sequence_id,
                 $query_table_id, $query_taxon_id, $query_external_db_release_id,
                 $virtual_target_table_id, $target_taxon_id, $target_external_db_release_id,
                 $is_consistent, $is_genomic_contaminant, $unaligned_3p_bases,
                 $unaligned_5p_bases, $has_3p_polya, $has_5p_polya, $is_3p_complete,
                 $is_5p_complete, $percent_identity, $max_query_gap, $max_target_gap,
                 $number_of_spans, $query_start, $query_end, $virtual_target_start,
                 $virtual_target_end,
                 $is_reversed, $query_bases_aligned, $repeat_bases_aligned, $num_ns, $score,
                 $is_best_alignment, $blat_alignment_quality_id, $blocksizes, $qstarts,
                 $virtual_tstarts, 'virtual');
        }
      }

      $insertHandle->finish();
      $queryHandle->finish();

sub getReversedTstarts {
  my($dfl,$len,$tstart,$blocksizes) = @_;
  my @ts = split(',',$tstart);
  my @bs = split(',',$blocksizes);
  my @new;
  for(my $a = scalar(@ts) - 1;$a >= 0;$a--){
    push(@new,($dfl + $len - $ts[$a] - $bs[$a] + 2));
  }
  return join(',',@new);
}
      ]]> 
    </perl>
  </tuningTable>

  <tuningTable name="apidb.EstAlignmentGeneSummary">
    <internalDependency name="apidb.GenomicSequence"/>
    <internalDependency name="apidb.GeneAttributes"/>
    <internalDependency name="apidb.BlatAlignmentLocation"/>
    <externalDependency name="dots.AssemblySequence"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.Est"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.SequenceOntology"/>
    <intermediateTable name="apidb.EstAlignmentGene"/>
    <intermediateTable name="apidb.EstAlignmentNoGene"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.EstAlignmentGene NOLOGGING AS
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, e.accession,
         e.library_id, ba.query_taxon_id, ba.target_na_sequence_id,
         ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
         ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
         sequence.source_id AS target_sequence_source_id,
         least(ba.target_end, ga.end_max)
         - greatest(ba.target_start, ga.start_min) + 1
           AS est_gene_overlap_length,
         ba.query_bases_aligned / (query_sequence.length)
         * 100 AS percent_est_bases_aligned,
         ga.source_id AS gene
  FROM apidb.BlatAlignmentLocation ba, dots.est e, dots.AssemblySequence aseq,
       apidb.GeneAttributes ga, apidb.GenomicSequence sequence,
       dots.NaSequence query_sequence, sres.SequenceOntology so
  WHERE e.na_sequence_id = ba.query_na_sequence_id
    AND aseq.na_sequence_id = ba.query_na_sequence_id
    AND sequence.na_sequence_id = ba.target_na_sequence_id
    AND ga.sequence_id = sequence.source_id
    AND least(ba.target_end, ga.end_max) - greatest(ba.target_start, ga.start_min) >= 0
    AND query_sequence.na_sequence_id = ba.query_na_sequence_id
    AND query_sequence.sequence_ontology_id = so.sequence_ontology_id
    AND so.term_name = 'EST'
    AND ba.target_na_sequence_id = sequence.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.EstAlignmentNoGene NOLOGGING AS
SELECT * from EstAlignmentGene WHERE 1=0 UNION -- define datatype for null column
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, e.accession,
       e.library_id, ba.query_taxon_id, ba.target_na_sequence_id,
       ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
       ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
       sequence.source_id AS target_sequence_source_id,
       NULL AS est_gene_overlap_length,
       ba.query_bases_aligned / (query_sequence.length)
       * 100 AS percent_est_bases_aligned,
       NULL AS gene
FROM dots.blatalignment ba, dots.est e, dots.AssemblySequence aseq,
     dots.NaSequence sequence, dots.NaSequence query_sequence
WHERE e.na_sequence_id = ba.query_na_sequence_id
  AND e.na_sequence_id = query_sequence.na_sequence_id
  AND aseq.na_sequence_id = ba.query_na_sequence_id
  AND ba.target_na_sequence_id = sequence.na_sequence_id
  AND ba.blat_alignment_id IN
   ( -- set of blat_alignment_ids not in in first leg of UNION
    -- (because they overlap no genes)
    SELECT ba.blat_alignment_id
    FROM dots.BlatAlignment ba, dots.NaSequence query_sequence,
         sres.SequenceOntology so
    WHERE query_sequence.na_sequence_id = ba.query_na_sequence_id
      AND query_sequence.sequence_ontology_id = so.sequence_ontology_id
      AND so.term_name = 'EST'
  MINUS
    SELECT blat_alignment_id FROM apidb.EstAlignmentGene)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE EstAlignmentGeneSummary&1 NOLOGGING AS
SELECT * FROM apidb.EstAlignmentNoGene
UNION
SELECT * FROM apidb.EstAlignmentGene
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.EstSumm_libOverlap_ix&1
             ON apidb.EstAlignmentGeneSummary&1
                (library_id, percent_identity, is_consistent,
                 est_gene_overlap_length, percent_est_bases_aligned)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.EstSumm_estSite_ix&1
             ON apidb.EstAlignmentGeneSummary&1
                (target_sequence_source_id, target_start, target_end,
                 library_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.FeatureSo">
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="sres.SequenceOntology"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.FeatureSo&1 NOLOGGING AS
  SELECT t.na_feature_id, so.sequence_ontology_id, so.term_name
  FROM dots.NaFeature gf, dots.NaFeature t, sres.SequenceOntology so
  WHERE  gf.na_feature_id =  t.parent_id
  AND gf.sequence_ontology_id = so.sequence_ontology_id
UNION
  SELECT na_feature_id, so.sequence_ontology_id, so.term_name
  FROM dots.Miscellaneous misc, sres.SequenceOntology so
  WHERE misc.sequence_ontology_id = so.sequence_ontology_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX featso_id_ix&1 ON apidb.FeatureSo&1(na_feature_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.Polymorphism">
    <internalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="dots.SnpFeature"/>
    <externalDependency name="dots.SeqVariation"/>
    <externalDependency name="dots.NaLocation"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.Polymorphism&1 NOLOGGING AS
  SELECT snp.na_feature_id AS snp_na_feature_id, fl.na_sequence_id,
         fl.start_min AS start_min,
         substr(snp.source_id, 1, 25) AS snp_source_id,
         snp.position_in_protein,
         sa.na_feature_id as na_feature_id_a,
         sb.na_feature_id as na_feature_id_b,
         substr(sa.strain, 1, 12) AS strain_a,
         substr(sb.strain, 1, 12) AS strain_b,
         substr(sa.allele, 1, 1) AS allele_a,
         substr(sb.allele, 1, 1) AS allele_b,
         substr(sa.product, 1, 1) AS product_a,
         substr(sb.product, 1, 1) AS product_b,
         snp.external_database_release_id,
         snp.parent_id as gene_na_feature_id,
         nl.is_reversed as gene_is_reversed, gf.source_id as gene_source_id
  FROM dots.SnpFeature snp, dots.SeqVariation sa, dots.SeqVariation sb,
       apidb.FeatureLocation fl, dots.NaLocation nl, dots.GeneFeature gf
  WHERE sa.strain < sb.strain
    AND sa.allele != sb.allele
    AND sa.parent_id = sb.parent_id
    AND sa.parent_id = snp.na_feature_id
    AND sa.na_feature_id = fl.na_feature_id
    AND snp.parent_id = nl.na_feature_id (+)
    AND snp.parent_id = gf.na_feature_id (+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX polymorphism_ix&1 ON apidb.Polymorphism&1(na_sequence_id, strain_a, strain_b, start_min)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX polymorphism_loc_ix&1
ON apidb.Polymorphism&1(external_database_release_id, na_sequence_id, strain_a, strain_b, start_min)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.IsolateAttributes">
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.IsolateAttributes&1 NOLOGGING AS
SELECT A.na_sequence_id, A.external_database_release_id, A.source_id,
       A.organism, A.strain, A.specific_host, A.isolation_source, A.country,
       A.note, A.description, A.pcr_primers, A.query_name, A.target_name,
       A.min_subject_start, A.max_subject_end, A.map, B.product, A.project_id,
       A.is_reference, B.product_alias, A.sequence, A.collected_by, A.data_type
FROM (SELECT etn.na_sequence_id, etn.external_database_release_id,
             substr(etn.source_id, 1, 20) as source_id,
             substr(src.organism, 1, 60) as organism,
             substr(src.strain || ' ' || src.isolate, 1, 60) as strain,
             substr(src.specific_host || src.lab_host, 1, 50) as specific_host,
             decode(src.isolation_source, null, 'Unknown',
                    substr(upper(substr(src.isolation_source,0,1))
                    || substr(src.isolation_source,2), 1, 160)) as isolation_source,
             decode(src.country, null, 'Unknown', substr(src.country, 1, 80)) as country,
             substr(src.note, 1, 400) as note,
             substr(etn.description, 1, 400) as description,
             substr(src.pcr_primers, 1, 100) as pcr_primers,
             substr(aln.query_name, 1, 20) as query_name,
             substr(aln.target_name, 1, 20) as target_name,
             aln.min_subject_start, aln.max_subject_end,
             substr(aln.map, 1, 60) as map, 'CryptoDB' as project_id,
             src.is_reference,
             dbms_lob.substr(etn.sequence) as sequence,
             src.collected_by,
             'PopSet' data_type
      FROM dots.ExternalNaSequence etn, dots.IsolateSource src,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase edb,
           (SELECT extq.source_id, extq.source_id query_name,
                   extt.source_id target_name,
                   sim.min_subject_start min_subject_start,
                   sim.max_subject_end max_subject_end,
                   extt.source_id || ':' || sim.min_subject_start || '..'
                   || sim.max_subject_end as map
            FROM dots.Similarity sim, dots.ExternalNaSequence extt,
                 dots.ExternalNaSequence extq,
                 sres.ExternalDatabaseRelease edr,
                 sres.ExternalDatabase edb
            WHERE edr.external_database_id = edb.external_database_id
              AND edr.external_database_release_id = extq.external_database_release_id
              AND edb.name = 'C. parvum isolate data'
              AND sim.query_id = extq.na_sequence_id
              AND sim.subject_id = extt.na_sequence_id) aln
      WHERE aln.source_id(+) = etn.source_id
        AND etn.na_sequence_id = src.na_sequence_id
        AND edr.external_database_id = edb.external_database_id
        AND edr.external_database_release_id = etn.external_database_release_id
        AND edb.name = 'C. parvum isolate data'
        ) A,
     (SELECT etn.source_id,
             substr(apidb.tab_to_string(cast(collect(distinct if.product)
                                        as apidb.varchartab), ' | '), 1, 80)
               as product,
             substr(apidb.tab_to_string(cast(collect(distinct if.product_alias)
                                        as apidb.varchartab), ' | '), 1, 400)
               as product_alias
      FROM dots.ExternalNaSequence etn, dots.IsolateFeature if,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase edb
      WHERE etn.na_sequence_id = if.na_sequence_id
        AND edr.external_database_id = edb.external_database_id
        AND edr.external_database_release_id = etn.external_database_release_id
        AND edb.name = 'C. parvum isolate data'
      GROUP BY etn.source_id) B
WHERE A.source_id = B.source_id(+)
UNION
SELECT etn.na_sequence_id, 
       etn.external_database_release_id,
       'BC.' || etn.na_sequence_id as source_id,
       src.organism,
       src.strain,
       src.specific_host,
       src.isolation_source,
       src.country,
       src.note,
       etn.description,
       src.pcr_primers,
       CAST (NULL AS VARCHAR2(1)) as query_name,
       CAST (NULL AS VARCHAR2(1)) as target_name,
       CAST (NULL AS NUMBER) as min_subject_start,
       CAST (NULL AS NUMBER) as max_subject_end,
       CAST (NULL AS VARCHAR2(1)) as map,
       CAST (NULL AS VARCHAR2(1)) as product,
       'PlasmoDB' as project_id,
       src.is_reference,
       CAST (NULL AS VARCHAR2(1)) as product_alias,
       dbms_lob.substr(etn.sequence),
       src.collected_by,
       'Barcode' as data_type
FROM   dots.ExternalNaSequence etn,
       dots.IsolateSource src,
       sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase edb
WHERE  etn.na_sequence_id = src.na_sequence_id
   AND edr.external_database_id = edb.external_database_id
   AND edr.external_database_release_id = etn.external_database_release_id
   AND edb.name = 'Isolate barcode data from Broad'
   AND edr.version = '2008-06-13'
UNION
SELECT etn.na_sequence_id,
       etn.external_database_release_id,
       'CP.' || etn.na_sequence_id as source_id,
       src.organism,
       src.strain,
       src.specific_host,
       src.isolation_source,
       src.country,
       src.note,
       etn.description,
       src.pcr_primers,
       CAST (NULL AS VARCHAR2(1)) as query_name,
       CAST (NULL AS VARCHAR2(1)) as target_name,
       CAST (NULL AS NUMBER) as min_subject_start,
       CAST (NULL AS NUMBER) as max_subject_end,
       CAST (NULL AS VARCHAR2(1)) as map,
       CAST (NULL AS VARCHAR2(1)) as product,
       'PlasmoDB' as project_id,
       src.is_reference,
       CAST (NULL AS VARCHAR2(1)) as product_alias,
       dbms_lob.substr(etn.sequence),
       src.collected_by,
       '3kChip' as data_type
FROM   dots.ExternalNaSequence etn,
       dots.IsolateSource src,
       sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase edb
WHERE  etn.na_sequence_id = src.na_sequence_id
   AND edr.external_database_id = edb.external_database_id
   AND edr.external_database_release_id = etn.external_database_release_id
   AND edb.name = 'Broad 3K genotyping chip'
   AND edr.version = '2008-06-13'
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.IsolateAttr_sourceId_idx&1 ON apidb.IsolateAttributes&1 (source_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.ChIPFeature">
    <internalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="rad.DataTransformationResult"/>
    <externalDependency name="rad.Analysis"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.ChIPFeature&1 NOLOGGING AS
SELECT f.na_feature_id   as na_feature_id,
       l.na_sequence_id  as na_sequence_id,
       f.source_id       as name,
       r.float_value     as score,
       l.start_min       as start_min,
       l.end_max         as end_max,
       substr(a.name, 1, 40) as analysis_name,
       substr(p.name, 1, 40) as protocol_name,
       decode(p.name, 'ChIP_chip_Einstein', 'raw', 'called_peaks') as protocol_type,
       CASE 
          WHEN a.name like '%RH%' then 'RH'
          WHEN a.name like '%TypeIII%' then 'CTG'
          WHEN a.name like '%PLK%' then 'PLK'
       ELSE 'unknown' 
       END as strain,
       CASE 
          WHEN a.name like '%H3K9%' then 'H3K9ac'
          WHEN a.name like '%H3K4%' then 'H3K4me3'
       ELSE 'unknown' 
       END as antibody,
       CASE 
          WHEN a.name like '%Rep1%' then '1'
          WHEN a.name like '%Rep2%' then '2'
       ELSE '0' 
       END as rep 
FROM   rad.DataTransformationResult r, 
       rad.Analysis a, 
       rad.Protocol p, 
       core.Tableinfo t, 
       dots.ArrayElementFeature f, 
       apidb.FeatureLocation l 
WHERE  a.analysis_id = r.analysis_id 
   AND p.protocol_id = a.protocol_id
   AND t.table_id = r.table_id
   AND r.row_id = f.na_feature_id
   AND t.name = 'ArrayElementFeature'
	 AND f.na_feature_id = l.na_feature_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Chfe_id_st_end_prn_str_idx&1
ON apidb.ChipFeature&1(na_sequence_id, protocol_name, strain, start_min, end_max)
      ]]>
    </sql>
    <sql>
      <![CDATA[
         CREATE INDEX apidb.Chfe_big_idx_&1
         ON apidb.ChipFeature&1 (na_sequence_id, protocol_name, strain, start_min, end_max, na_feature_id, antibody, rep, score)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.ChIPchipGene">
    <internalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="apidb.GeneAttributes"/>
    <internalDependency name="apidb.ChIPFeature"/>
    <internalDependency name="apidb.SequenceAttributes"/>
    <sql>
      <![CDATA[
        create table apidb.chipchipgene&1 NOLOGGING AS
         SELECT distinct
         ga.source_id as gene_source_id, 
         cf.name as probe_id,cf.score,
         cf.analysis_name,cf.strain,cf.antibody,cf.rep,
         CASE WHEN fl.is_reversed = 0 THEN round(abs(fl.start_min - (((cf.end_max - cf.start_min) / 2) + cf.start_min)),0)
              ELSE round(abs(fl.end_max - (((cf.end_max - cf.start_min) / 2) + cf.start_min)),0) END as distance,
         CASE WHEN CASE WHEN fl.is_reversed = 0 THEN round(abs(fl.start_min - (((cf.end_max - cf.start_min) / 2) + cf.start_min)),0)
                        ELSE round(abs(fl.end_max - (((cf.end_max - cf.start_min) / 2) + cf.start_min)),0) END > 0 THEN 
              CASE WHEN ga.is_reversed = 0 THEN '-' ELSE '+' END ELSE 
              CASE WHEN ga.is_reversed = 1 THEN '-' ELSE '+' END END as direction
         FROM apidb.chipfeature cf,
            apidb.geneattributes ga,
            apidb.featurelocation fl
         WHERE cf.protocol_type = 'called_peaks'
            AND cf.na_sequence_id = fl.na_sequence_id
            AND fl.is_top_level = 1
            and fl.na_feature_id = ga.na_feature_id
            and ( (fl.is_reversed = 0 and abs((((cf.end_max - cf.start_min) / 2) + cf.start_min) - fl.start_min) <= 3000)
                  or (fl.is_reversed = 1 and abs((((cf.end_max - cf.start_min) / 2) + cf.start_min) - fl.end_max) <= 3000) )
      ]]>
    </sql>
    <sql>
      <![CDATA[
       CREATE INDEX apidb.chpgene_str_anti_rep_idx&1 ON apidb.chipchipgene&1 (strain,antibody,rep)
      ]]>
    </sql>
    <sql>
      <![CDATA[
       CREATE INDEX apidb.chpgene_geneid_idx&1 ON apidb.chipchipgene&1 (gene_source_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SageTagAttributes">
    <internalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="apidb.SageTagGene"/>
    <internalDependency name="apidb.GeneAttributes"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="rad.CompositeElementImp"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.SageTagAttributes&1 NOLOGGING AS
SELECT CASE
         WHEN SUBSTR(tn.name, 1, 6) = 'Crypto'
           THEN 'CryptoDB'
         WHEN SUBSTR(tn.name, 1, 6) = 'Plasmo'
           THEN 'PlasmoDB'
         WHEN SUBSTR(tn.name, 1, 4) = 'Toxo'
           THEN 'ToxoDB'
         WHEN tn.name like 'Neospora%'
           THEN 'ToxoDB'
         WHEN SUBSTR(tn.name, 1, 5) = 'Trich'
           THEN 'TrichDB'
         WHEN SUBSTR(tn.name, 1, 7) = 'Giardia'
           THEN 'GiardiaDB'
         ELSE 'ERROR: setting project in tuningManager'
       END as project_id,
       substr(s.source_id || '-' || l.start_min || '-' || l.end_max || '.'
              || l.is_reversed, 1, 40) as source_id,
       f.na_feature_id, f.source_id as feature_source_id,
       substr(s.source_id, 1, 40) as sequence_source_id, s.na_sequence_id,
       l.start_min, l.end_max, substr(st.tag, 1, 20) as sequence,
       st.composite_element_id, st.source_id as rad_source_id,
       l.is_reversed, substr(tn.name, 1, 60) as organism,
       gene.gene_source_id, nvl(gene.gene_count, 0) gene_count,
       gene.gene_product
from dots.SageTagFeature f, apidb.FeatureLocation l, dots.NaSequence s,
     sres.TaxonName tn, rad.SageTag st,
     (select a.na_feature_id,
             apidb.tab_to_string(CAST(COLLECT(b.gene_source_id) AS apidb.varchartab),'; ') as gene_source_id,
             apidb.tab_to_string(CAST(COLLECT(ga.product) AS apidb.varchartab),'; ') as gene_product,
             count(b.gene_source_id) as gene_count
      from dots.sagetagfeature a, (
                             select distinct a.na_feature_id,
                                            sg.gene_source_id as gene_source_id
                             from dots.SageTagFeature a left join apidb.SageTagGene sg on a.na_feature_id = sg.tag_feature_id
                             where (sg.distance = 0 or sg.distance is null)
                             and (sg.antisense = 0 or sg.antisense is null)
                             ) b, apidb.GeneAttributes ga
       where a.na_feature_id = b.na_feature_id
        and b.gene_source_id = ga.source_id
       group by a.na_feature_id
      ) gene
where f.na_feature_id = gene.na_feature_id (+)
  and f.na_feature_id = l.na_feature_id
  and l.is_top_level = 1
  and s.na_sequence_id = l.na_sequence_id
  and s.taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
  and f.source_id = st.composite_element_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE UNIQUE INDEX apidb.SageTagAttr_sourceId_idx&1 ON apidb.SageTagAttributes&1
             (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SageTagAttr_loc_idx&1 ON apidb.SageTagAttributes&1
             (na_sequence_id, start_min, end_max, is_reversed, source_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.AsmAlignmentGeneSummary">
    <internalDependency name="apidb.GeneAttributes"/>
    <internalDependency name="apidb.GenomicSequence"/>
    <internalDependency name="apidb.BlatAlignmentLocation"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.SequenceOntology"/>
    <intermediateTable name="apidb.AsmAlignmentGene"/>
    <intermediateTable name="apidb.AsmAlignmentNoGene"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.AsmAlignmentGene NOLOGGING AS
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, a.source_id, a.number_of_contained_sequences AS est_count, a.length,
         ba.query_taxon_id, ba.target_na_sequence_id,
         ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
         ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
         sequence.source_id AS target_sequence_source_id,
         least(ba.target_end, ga.end_max)
         - greatest(ba.target_start, ga.start_min) + 1
           AS assembly_gene_overlap_length,
         ba.query_bases_aligned / (a.length)
         * 100 AS percent_assembly_bases_aligned,
         ga.source_id AS gene
  FROM dots.assembly a, 
       apidb.BlatAlignmentLocation ba,
       apidb.GeneAttributes ga, 
       apidb.GenomicSequence sequence
  WHERE ba.query_na_sequence_id = a.na_sequence_id 
   AND ba.target_na_sequence_id = sequence.na_sequence_id
   AND ga.sequence_id = sequence.source_id
   AND least(ba.target_end, ga.end_max) - greatest(ba.target_start, ga.start_min) >= 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE apidb.AsmAlignmentNoGene NOLOGGING AS
SELECT * from AsmAlignmentGene WHERE 1=0 UNION -- define datatype for null column
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, a.source_id, a.number_of_contained_sequences AS est_count, a.length,
         ba.query_taxon_id, ba.target_na_sequence_id,
         ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
         ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
         sequence.source_id AS target_sequence_source_id,
         NULL
           AS assembly_gene_overlap_length,
         ba.query_bases_aligned / (a.length)
         * 100 AS percent_assembly_bases_aligned,
         NULL AS gene
  FROM dots.blatalignment ba, dots.assembly a,
      dots.NaSequence sequence
  WHERE a.na_sequence_id = ba.query_na_sequence_id
    AND sequence.na_sequence_id = ba.target_na_sequence_id
    AND ba.blat_alignment_id IN
   ( -- set of blat_alignment_ids not in in first leg of UNION
    -- (because they overlap no genes)
    SELECT ba.blat_alignment_id
    FROM dots.BlatAlignment ba, dots.NaSequence query_sequence,
         sres.SequenceOntology so
    WHERE query_sequence.na_sequence_id = ba.query_na_sequence_id
      AND query_sequence.sequence_ontology_id = so.sequence_ontology_id
      AND so.term_name = 'assembly'
  MINUS
    SELECT blat_alignment_id FROM apidb.AsmAlignmentGene)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE AsmAlignmentGeneSummary&1 NOLOGGING AS
SELECT * FROM apidb.AsmAlignmentNoGene
UNION
SELECT * FROM apidb.AsmAlignmentGene
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.PlasmoExpressionGraphs">
    <externalDependency name="apidb.Profile"/>
    <externalDependency name="apidb.ProfileSet"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.PlasmoExpressionGraphs&1 NOLOGGING AS
SELECT gf.source_id,
       COUNT(derisi_winzeler) AS graph_derisi_winzeler,
       COUNT(winzeler) AS graph_winzeler, COUNT(ThreeD7) AS graph_3d7,
       COUNT(HB3) AS graph_hb3, COUNT(Dd2) AS graph_dd2,
       COUNT(waters) AS graph_waters, COUNT(gametocyte) as graph_gametocyte,
       COUNT(cowman) AS graph_cowman, COUNT(mexp128) AS graph_mexp128,
       COUNT(mexp494) AS graph_mexp494, COUNT(kappe) as graph_kappe,
       COUNT(daily) as graph_daily
FROM dots.GeneFeature gf,
     (SELECT p1.source_id, 1 AS derisi_winzeler
      FROM apidb.profile p1, apidb.profileSet ps1,
           apidb.profile p3, apidb.profileSet ps3,
           apidb.profile p5, apidb.profileSet ps5,
           apidb.profile p7, apidb.profileSet ps7
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND p3.profile_set_id = ps3.profile_set_id
        AND p5.profile_set_id = ps5.profile_set_id
        AND p7.profile_set_id = ps7.profile_set_id
        AND p1.source_id = p3.source_id
        AND p1.source_id = p5.source_id
        AND p1.source_id = p7.source_id
        AND ps1.name = 'DeRisi HB3 Smoothed Averaged'
        AND ps3.name = 'DeRisi 3D7 Smoothed Averaged'
        AND ps5.name = 'DeRisi Dd2 Smoothed Averaged'
        AND ps7.name = 'winzeler_cc_sorbExp') combo,
     (SELECT p1.source_id, 1 AS winzeler
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND ps1.name = 'winzeler_cc_sorbExp') winzeler,
     (SELECT p1.source_id, 1 AS threeD7
      FROM apidb.profile p1, apidb.profileSet ps1,
           apidb.profile p2, apidb.profileSet ps2,
           apidb.profile p3, apidb.profileSet ps3
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND p2.profile_set_id = ps2.profile_set_id
        AND p3.profile_set_id = ps3.profile_set_id
        AND p1.source_id = p2.source_id
        AND p1.source_id = p3.source_id
        AND ps1.name = 'DeRisi 3D7 Smoothed Averaged'
        AND ps2.name = 'DeRisi 3D7 Normalized repsCollapsed Averaged'
         AND ps3.name = 'DeRisi 3D7 Percents Averaged') threeD7,
     (SELECT p1.source_id, 1 AS HB3
      FROM apidb.profile p1, apidb.profileSet ps1,
           apidb.profile p2, apidb.profileSet ps2,
           apidb.profile p3, apidb.profileSet ps3
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND p2.profile_set_id = ps2.profile_set_id
        AND p3.profile_set_id = ps3.profile_set_id
        AND p1.source_id = p2.source_id
        AND p1.source_id = p3.source_id
        AND ps1.name = 'DeRisi HB3 Smoothed Averaged'
        AND ps2.name = 'DeRisi HB3 Normalized repsCollapsed Averaged'
         AND ps3.name = 'DeRisi HB3 Percents Averaged') HB3,
     (SELECT p1.source_id, 1 AS Dd2
      FROM apidb.profile p1, apidb.profileSet ps1,
           apidb.profile p2, apidb.profileSet ps2,
           apidb.profile p3, apidb.profileSet ps3
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND p2.profile_set_id = ps2.profile_set_id
        AND p3.profile_set_id = ps3.profile_set_id
        AND p1.source_id = p2.source_id
        AND p1.source_id = p3.source_id
        AND ps1.name = 'DeRisi Dd2 Smoothed Averaged'
        AND ps2.name = 'DeRisi Dd2 Normalized repsCollapsed Averaged'
         AND ps3.name = 'DeRisi Dd2 Percents Averaged') Dd2,
     (SELECT p1.source_id, 1 AS waters
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND ps1.name = 'Waters HPE Percents Averaged') waters,
     (SELECT p1.source_id, 1 AS gametocyte
      FROM apidb.profile p1, apidb.profileSet ps1,
           apidb.profile p2, apidb.profileSet ps2
      WHERE p1.profile_set_id = ps1.profile_set_id
        AND p2.profile_set_id = ps2.profile_set_id
        AND p1.source_id = p2.source_id
        AND ps1.name = 'winzeler_NF54_gametocyte'
        AND ps2.name = 'winzeler_3D7_gametocyte') gametocyte,
    (SELECT p.source_id, 1 AS cowman
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'P.falciparum strain 3D7, SIR2 knockout'
        AND p.profile_set_id = ps.profile_set_id) cowman,
    (SELECT p.source_id, 1 AS mexp128
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'Expression profile of 3D7 clones 3D7AH1S2 and 3D7S8.4 at ring, trophozite and schizont stages.-Averaged'
        AND p.profile_set_id = ps.profile_set_id) mexp128,
    (SELECT p.source_id, 1 AS mexp494
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'Identification of genome wide gene copy number polymorphisms in Plasmodium falciparum'
        AND p.profile_set_id = ps.profile_set_id) mexp494,
    (SELECT p1.source_id, 1 AS kappe
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE ps1.name = 'kappe_fold_changes'
       AND p1.profile_set_id = ps1.profile_set_id) kappe,
    (SELECT p1.source_id, 1 AS daily
      FROM apidb.profile p1, apidb.profileSet ps1
      WHERE ps1.name = 'daily correlations'
       AND p1.profile_set_id = ps1.profile_set_id) daily
  WHERE gf.source_id = combo.source_id(+)
  AND gf.source_id = winzeler.source_id(+)
  AND gf.source_id = threeD7.source_id(+)
  AND gf.source_id = HB3.source_id(+)
  AND gf.source_id = Dd2.source_id(+)
  AND gf.source_id = waters.source_id(+)
  AND gf.source_id = gametocyte.source_id(+)
  AND gf.source_id = cowman.source_id(+)
  AND gf.source_id = mexp128.source_id(+)
  AND gf.source_id = mexp494.source_id(+)
  AND gf.source_id = kappe.source_id(+)
  AND gf.source_id = daily.source_id(+)
GROUP BY gf.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.PlasmoExp_sourceId_idx&1 ON apidb.PlasmoExpressionGraphs&1 (source_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.ToxoExpressionGraphs">
    <internalDependency name="apidb.GeneAttributes"/>
    <externalDependency name="apidb.Profile"/>
    <externalDependency name="apidb.ProfileSet"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.ToxoExpressionGraphs&1 NOLOGGING AS
SELECT ga.source_id,
        COUNT(archetypal) AS graph_archetypal
FROM Apidb.GeneAttributes ga,
     (SELECT p.source_id, 1 AS archetypal
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'Expression profiling of the 3 archetypal T. gondii lineages'
        AND p.profile_set_id = ps.profile_set_id) archetypal
  WHERE ga.source_id = archetypal.source_id(+)
GROUP BY ga.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.ToxoExp_sourceId_idx&1 ON apidb.ToxoExpressionGraphs&1 (source_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.GiardiaExpressionGraphs">
    <internalDependency name="apidb.GeneAttributes"/>
    <externalDependency name="apidb.Profile"/>
    <externalDependency name="apidb.ProfileSet"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GiardiaExpressionGraphs&1 NOLOGGING AS
SELECT ga.source_id,
       COUNT(stress) as graph_stress
FROM apidb.GeneAttributes ga,
     (SELECT p.source_id, 1 AS stress
      FROM apidb.profile p, apidb.profileSet ps
      WHERE ps.name = 'Stress Response in Giardia lamblia Trophozoites-Averaged'
        AND p.profile_set_id = ps.profile_set_id) stress
  WHERE ga.source_id = stress.source_id(+)
GROUP BY ga.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.ExpGraphSum_sourceId_idx&1 ON apidb.GiardiaExpressionGraphs&1 (source_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.NaSynteny">
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="dots.Similarity"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.NaSynteny&1 NOLOGGING AS
SELECT
    sim.similarity_id,
    extq.na_sequence_id query_na_sequence_id,
    extt.na_sequence_id target_na_sequence_id,
    extq.source_id query_source_id,
    extt.source_id target_source_id,
    sim.min_subject_start ,
    sim.max_subject_end ,
    sim.min_query_start ,
    sim.max_query_end,
    sim.is_reversed,
    sim.score,
    sim.pvalue_mant,
    sim.pvalue_exp
FROM
    dots.Similarity sim,
    dots.ExternalNaSequence extt,
    dots.ExternalNaSequence extq,
    core.TableInfo qtab,
    core.TableInfo stab
WHERE
    sim.query_id = extq.na_sequence_id and
    sim.subject_id = extt.na_sequence_id and
    sim.subject_table_id = stab.table_id and
    stab.name = 'ExternalNASequence'and
    sim.query_table_id  = qtab.table_id and
    qtab.name = 'ExternalNASequence'
UNION
SELECT
    sim.similarity_id,
    extt.na_sequence_id query_na_sequence_id,
    extq.na_sequence_id target_na_sequence_id,
    extt.source_id query_source_id,
    extq.source_id target_source_id,
    sim.min_query_start min_subject_start,
    sim.max_query_end max_subject_end,
    sim.min_subject_start min_query_start,
    sim.max_subject_end max_query_end,
    sim.is_reversed,
    sim.score,
    sim.pvalue_mant,
    sim.pvalue_exp
FROM
    dots.Similarity sim,
    dots.ExternalNaSequence extt,
    dots.ExternalNaSequence extq,
    core.TableInfo qtab,
    core.TableInfo stab
WHERE
    sim.query_id = extq.na_sequence_id and
    sim.subject_id = extt.na_sequence_id and
    sim.subject_table_id = stab.table_id and
    stab.name = 'ExternalNASequence'and
    sim.query_table_id  = qtab.table_id and
    qtab.name = 'ExternalNASequence'
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE BITMAP INDEX apidb.syn_query_ix&1 ON apidb.NaSynteny&1(query_na_sequence_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE BITMAP INDEX apidb.syn_target_ix&1 ON apidb.NaSynteny&1(target_na_sequence_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.Subcellular">
    <internalDependency name="apidb.GeneAttributes"/>
    <externalDependency name="dots.AaFeatureImp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.Subcellular&1 NOLOGGING AS
select ga.source_id, 'ht' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf, apidb.GeneAttributes ga
where ed.name = 'subcellular motif from Haldar'
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
  and paf.source_id = ga.source_id
union
select ga.source_id, 'pexel' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf, apidb.GeneAttributes ga
where ed.name = 'subcellular motif from Cowman'
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
  and paf.source_id = ga.source_id
union
select ga.source_id, 'apicoplast' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf, apidb.GeneAttributes ga
where ed.name = 'apicoplast targeting data from 4.4'
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
  and paf.source_id = ga.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.subc_ix&1 ON apidb.Subcellular&1(source_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.Expression">
    <externalDependency name="apidb.Profile"/>
    <externalDependency name="apidb.ProfileElement"/>
    <externalDependency name="apidb.ProfileElementName"/>
    <externalDependency name="apidb.ProfileSet"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.Expression&1 NOLOGGING AS
SELECT pct_p.source_id, pct_pe.value, pct_ps.name AS profile_set_name,
       pct_pe.element_order, pen.name AS element_name
FROM apidb.ProfileSet pct_ps,
     apidb.Profile pct_p, apidb.ProfileElement pct_pe,
     apidb.ProfileSet exp_ps,
     apidb.Profile exp_p, apidb.ProfileElement exp_pe,
     apidb.ProfileSet lgp_ps,
     apidb.Profile lgp_p, apidb.ProfileElement lgp_pe,
     apidb.ProfileElementName pen
WHERE pct_ps.profile_set_id = pct_p.profile_set_id
  AND pct_p.profile_id = pct_pe.profile_id
  AND exp_ps.profile_set_id = exp_p.profile_set_id
  AND exp_p.profile_id = exp_pe.profile_id
  AND exp_pe.element_order = pct_pe.element_order
  AND exp_p.source_id = pct_p.source_id
  AND exp_ps.name = REPLACE(pct_ps.name, 'Pct', 'Exp')
  AND lgp_ps.profile_set_id = lgp_p.profile_set_id
  AND lgp_p.profile_id = lgp_pe.profile_id
  AND lgp_pe.element_order = exp_pe.element_order
  AND lgp_p.source_id = pct_p.source_id
  AND lgp_ps.name = REPLACE(pct_ps.name, 'Pct', 'Lgp')
  AND lgp_ps.name LIKE '%Lgp'
  AND pct_ps.profile_set_id = pen.profile_set_id
  AND exp_pe.element_order = pen.element_order
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Exp_value_ix&1 ON apidb.Expression&1 (value, element_order, source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.Exp_element_ix&1 ON apidb.Expression&1 (element_order, source_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SnpSummary">
    <externalDependency name="dots.AaFeatureImp"/>
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.SnpSummary&1 NOLOGGING AS
SELECT cds_length, na_feature_id, source_id,
       strain_a, strain_b,
       sum(synonymous) as synonymous,
       sum(non_synonymous) as non_synonymous,
       sum(non_coding) as non_coding,
       sum(stop) as stop,
       sum(non_coding) + sum(synonymous) + sum(non_synonymous) as total
FROM  (SELECT greatest(taf.translation_start, taf.translation_stop)
              - least(taf.translation_start, taf.translation_stop) + 1 AS cds_length,
              gf.na_feature_id, gf.source_id,
              edr.external_database_release_id,
              SUBSTR(sva.strain, 1, 30) AS strain_a,
              SUBSTR(svb.strain, 1, 30) AS strain_b,
              CASE WHEN sva.product IS NULL THEN 1 ELSE 0 END AS non_coding,
              CASE WHEN sva.product = svb.product THEN 1 ELSE 0 END AS synonymous,
              CASE WHEN sva.product != svb.product THEN 1 ELSE 0 END AS non_synonymous,
              CASE WHEN sva.product = '*' OR  svb.product = '*' THEN 1 ELSE 0 END AS stop
       FROM dots.SeqVariation sva, dots.SeqVariation svb, dots.SnpFeature sf,
            dots.SplicedNaSequence cds, dots.Transcript, dots.GeneFeature gf,
            dots.TranslatedAaFeature taf, sres.ExternalDatabase ed,
            sres.ExternalDatabaseRelease edr
       WHERE ed.name NOT IN ('Broad SNPs', 'Sanger falciparum SNPs',
                             'Su SNPs')
         AND sva.strain  < svb.strain
         AND sva.allele != svb.allele
         AND sva.parent_id = svb.parent_id
         AND sva.parent_id = sf.na_feature_id
         AND sf.parent_id = gf.na_feature_id
         AND sf.external_database_release_id = edr.external_database_release_id
         AND edr.external_database_id = ed.external_database_id
         AND gf.na_feature_id = transcript.parent_id
         AND transcript.na_sequence_id = cds.na_sequence_id
         AND transcript.na_feature_id = taf.na_feature_id
)
GROUP BY cds_length, na_feature_id, source_id,
         strain_a, strain_b
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SnpSummary_idx&1
       ON apidb.SnpSummary&1(na_feature_id, source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SnpSummary_strain_idx&1
       ON apidb.SnpSummary&1(strain_a, strain_b, source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SnpSummary_strainb_idx&1
       ON apidb.SnpSummary&1(strain_b, strain_a, source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX apidb.SnpSummary_srcId_idx&1
       ON apidb.SnpSummary&1(source_id, na_feature_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.Scaffold_Map">
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="dots.SequencePiece"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.Scaffold_Map&1 NOLOGGING AS
     SELECT
      na_sequence_id as virtual_na_sequence_id,
      parent_id as virtual_source_id,
      piece_na_sequence_id,
      source_id as piece_source_id,
      (offset + 1) as startm,
      (offset + length) as end,
      strand_orientation,
      length,
      sequence_order
FROM (
(SELECT vs.na_sequence_id, vs.source_id as parent_id, ens.source_id,
       sp.piece_na_sequence_id, sp.sequence_order,
       ens.length, vs.length as chr_length, sp.strand_orientation,
       0 as offset
 FROM dots.VirtualSequence vs, apidb.SequencePieceClosure sp,
     dots.ExternalNaSequence ens
 WHERE vs.na_sequence_id = sp.virtual_na_sequence_id
  and ens.na_sequence_id = sp.piece_na_sequence_id
  and sp.sequence_order = 1
GROUP by vs.na_sequence_id, vs.source_id, ens.source_id, sp.piece_na_sequence_id, sp.sequence_order,
       ens.length, vs.length, sp.strand_orientation)
UNION
(SELECT vs.na_sequence_id, vs.source_id as parent_id, ens.source_id,
       sp.piece_na_sequence_id, sp.sequence_order,
       ens.length, vs.length as chr_length, sp.strand_orientation,
       sum(predecessors.length) as offset
 FROM dots.VirtualSequence vs, apidb.SequencePieceClosure sp,
     dots.ExternalNaSequence ens,
     (select sp2.virtual_na_sequence_id, sp2.sequence_order, ens2.length
      from apidb.SequencePieceClosure sp2,
           dots.ExternalNaSequence ens2
      where sp2.piece_na_sequence_id = ens2.na_sequence_id) predecessors
 WHERE vs.na_sequence_id = sp.virtual_na_sequence_id
  and ens.na_sequence_id = sp.piece_na_sequence_id
  and vs.na_sequence_id = predecessors.virtual_na_sequence_id(+)
  and sp.sequence_order > predecessors.sequence_order
GROUP by vs.source_id, vs.na_sequence_id, ens.source_id, sp.piece_na_sequence_id, sp.sequence_order,
       ens.length, vs.length, sp.strand_orientation )
ORDER by na_sequence_id, offset, sequence_order)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.DistinctLowerProduct">
    <externalDependency name="dots.NaFeatureImp"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.DistinctLowerProduct&1 NOLOGGING AS
select rownum as dlp_id, dlp
from (select distinct lower(product) as dlp
      from dots.GeneFeature)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.GeneProduct">
    <internalDependency name="apidb.DistinctLowerProduct"/>
    <sql>
      <![CDATA[
CREATE TABLE apidb.GeneProduct&1 NOLOGGING AS
select dlp_id, na_feature_id
from apidb.DistinctLowerProduct, dots.GeneFeature
where lower(product) = dlp
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX geneProduct_ix&1 ON apidb.GeneProduct&1(dlp_id, na_feature_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.SimilaritySpanLocation">
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.SimilaritySpan"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.SequencePiece"/>
    <sql>
      <![CDATA[
create table apidb.SimilaritySpanLocation&1 NOLOGGING as
select sim.similarity_id, sim.query_id, sim.subject_id, sim.query_table_id,
       sim.subject_table_id, sim.score as similarity_score, sim.min_query_start,
       sim.max_query_end, sim.is_reversed as similarity_is_reversed,
       sim.pvalue_mant, sim.pvalue_exp,
       round(100 * sim.number_identical / sim.total_match_length,1) as percent_identical,
       round(100 * sim.number_positive / sim.total_match_length,1) as percent_positive,
       sim.min_subject_start, sim.max_subject_end, simp.similarity_span_id,
       simp.score as span_score, simp.query_start, simp.query_end,
       simp.subject_start, simp.subject_end,
       simp.is_reversed as span_is_reversed,
       'direct' as location_mapping
from dots.similarity sim, dots.similarityspan simp, core.TableInfo ti
where sim.similarity_id = simp.similarity_id
  and sim.query_table_id = ti.table_id
  and ti.name = 'ExternalNASequence'
union
select sim.similarity_id, scaffold.na_sequence_id as query_id, sim.subject_id,
       sim.query_table_id,
       sim.subject_table_id, sim.score as similarity_score,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - greatest(sim.min_query_start, sim.max_query_end)
           else least(sim.min_query_start, sim.max_query_end) + sp.distance_from_left
       end as min_query_start,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - least(sim.min_query_start, sim.max_query_end)
           else greatest(sim.min_query_start, sim.max_query_end) + sp.distance_from_left
       end as max_query_end,
       sim.is_reversed, sim.pvalue_mant, sim.pvalue_exp,
       round(100 * sim.number_identical / sim.total_match_length,1) as percent_identical,
       round(100 * sim.number_positive / sim.total_match_length,1) as percent_positive,
       sim.min_subject_start, sim.max_subject_end, simp.similarity_span_id,
       simp.score as span_score,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - greatest(simp.query_start, simp.query_end)
           else least(simp.query_start, simp.query_end) + sp.distance_from_left
       end as query_start,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + contig.length
                - least(simp.query_start, simp.query_end)
           else greatest(simp.query_start, simp.query_end) + sp.distance_from_left
       end as query_end,
       simp.subject_start, simp.subject_end,
       simp.is_reversed as span_is_reversed,
       'virtual' as location_mapping
from dots.similarity sim, dots.similarityspan simp, core.TableInfo ti,
     dots.NaSequence contig, dots.SequencePiece sp, dots.NaSequence scaffold
where sim.similarity_id = simp.similarity_id
  and sim.query_table_id = ti.table_id
  and ti.name = 'ExternalNASequence'
  and sim.query_id = sp.piece_na_sequence_id
  and sp.piece_na_sequence_id = contig.na_sequence_id
  and sp.virtual_na_sequence_id = scaffold.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index apidb.spanloc_query_ix&1
        on apidb.SimilaritySpanLocation&1 (query_id, query_table_id, min_query_start, max_query_end)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.IsolateSNPs">
    <externalDependency name="dots.NaFeatureImp"/>
    <externalDependency name="dots.NaSequenceImp"/>
    <externalDependency name="dots.NaLocation"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <internalDependency name="apidb.IsolateAttributes"/>
    <sql>
      <![CDATA[
create table apidb.IsolateSNPs&1 NOLOGGING as
select s.na_sequence_id as is_na_sequence_id,atr.source_id as is_source_id, s.name,s.isolate, 
f.allele,snpf.source_id as snp_source_id,d.name as snp_db_name,snpf.na_sequence_id as snp_na_sequence_id,snpl.start_min as snp_start_min
from dots.ISOLATEFEATURE f, dots.ISOLATESOURCE s, dots.NALOCATION il, dots.SNPFEATURE snpf, 
dots.NALOCATION snpl,apidb.ISOLATEATTRIBUTES atr, sres.externaldatabaserelease rel, sres.externaldatabase d
where s.na_feature_id = f.parent_id
and s.na_sequence_id = atr.NA_SEQUENCE_ID
and il.na_feature_id = f.na_feature_id
and snpf.na_sequence_id = f.na_sequence_id
and snpl.na_feature_id = snpf.na_feature_id
and snpl.start_min = il.start_min
and snpf.external_database_release_id = rel.external_database_release_id
and rel.external_database_id = d.external_database_id
and d.name in ('PlasmoDB combined SNPs','Broad SNPs','Sanger falciparum SNPs','Su SNPs')
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index apidb.isolatesnps_is_sid_idx&1 on apidb.isolatesnps&1 (is_source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index apidb.isolatesnps_snp_db_id_idx&1 on apidb.isolatesnps&1 (snp_db_name,snp_source_id,allele)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index apidb.isolatesnps_snp_id_idx&1 on apidb.isolatesnps&1 (snp_source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index apidb.isnps_snp_sq_strt_idx&1 on apidb.isolatesnps&1 (snp_na_sequence_id,snp_start_min)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="apidb.MassSpecGeneTable">
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.AaSequence"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.MassSpecFeature"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
create table apidb.MassSpecGeneTable&1 as
select sequencetable.source_id, substr(sequencetable.sequence, 1, 200) as sequence,
       seq.sum_sequence_count, spec.sum_spectrum_count,
       sequencetable.name as experiment
from (select intseq.aa_sequence_id,count(*) as sum_sequence_count
      from (select mss.aa_sequence_id, count(*) as sum_seq_ct
            from apidb.MassSpecSummary mss, dots.MassSpecFeature msf,
                 dots.AaLocation aal, sres.ExternalDatabase ed,
                 sres.ExternalDatabaseRelease edr
            where mss.mass_spec_summary_id = msf.source_id
              and msf.aa_feature_id = aal.aa_feature_id
              and msf.external_database_release_id = edr.external_database_release_id
              and edr.external_database_id = ed.external_database_id
            group by mss.aa_sequence_id,aal.start_min,aal.end_max ) intseq
      group by intseq.aa_sequence_id) seq,
     (select mss.aa_sequence_id, sum(spectrum_count) as sum_spectrum_count
      from apidb.MassSpecSummary mss
      group by mss.aa_sequence_id) spec,
     (select msf.aa_sequence_id, to_char(substr(aas.sequence, aal.start_min,
             aal.end_max - aal.start_min + 1)) as sequence, ed.name, gf.source_id
      from dots.MassSpecFeature msf,dots.AaLocation aal, dots.AaSequence aas,
           dots.TranslatedAaFeature taaf, sres.ExternalDatabaseRelease edr,
           sres.ExternalDatabase ed, dots.GeneFeature gf, dots.Transcript t
      where t.parent_id = gf.na_feature_id
        and taaf.na_feature_id = t.na_feature_id
        and msf.parent_id = taaf.aa_feature_id
        and msf.aa_feature_id = aal.aa_feature_id
        and msf.aa_sequence_id = aas.aa_sequence_id
        and msf.external_database_release_id = edr.external_database_release_id
        and edr.external_database_id = ed.external_database_id) sequencetable
where seq.aa_sequence_id = sequencetable.aa_sequence_id
  and spec.aa_sequence_id = sequencetable.aa_sequence_id
group by sequencetable.sequence, sequencetable.name, seq.sum_sequence_count,
         spec.sum_spectrum_count, sequencetable.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index apidb.MassSpec_idx&1 on apidb.MassSpecGeneTable&1 (source_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningIndex name="dots.aaseq_subclassdbrel_ix" table="dots.AaSequenceImp">
    external_database_release_id, subclass_view, aa_sequence_id
  </tuningIndex>

  <tuningIndex name="dots.NaFeat_alleles_ix" table="dots.NaFeatureImp">
    subclass_view, number4, number5, na_sequence_id, na_feature_id
  </tuningIndex>

  <tuningIndex name="dots.AaSequenceImp_string2_ix" table="dots.AaSequenceImp">
    string2, aa_sequence_id
  </tuningIndex>

  <tuningIndex name="dots.AaSequenceImp_class_tax_ix" table="dots.AaSequenceImp">
    subclass_view, taxon_id, aa_sequence_id
  </tuningIndex>

  <tuningIndex name="dots.NaFeat_SubclassIds_ix" table="dots.NaFeatureImp">
    subclass_view, source_id, na_feature_id, na_sequence_id
  </tuningIndex>

  <tuningIndex name="dots.NaFeat_SubclassParent_ix" table="dots.NaFeatureImp">
    subclass_view, parent_id, na_feature_id
  </tuningIndex>

  <tuningIndex name="dots.loc_feat_ix" table="dots.NaLocation">
    na_feature_id, start_min, end_max, is_reversed
  </tuningIndex>

  <tuningIndex name="dots.sim_pval_ix" table="dots.Similarity">
    query_id, pvalue_exp, pvalue_mant, subject_id
  </tuningIndex>

  <tuningIndex name="dots.nasequenceimp_string1_seq_idx" table="dots.NaSequenceImp">
    STRING1, EXTERNAL_DATABASE_RELEASE_ID, NA_SEQUENCE_ID
  </tuningIndex>

  <tuningIndex name="dots.nasequenceimp_string1_idx" table="dots.NaSequenceImp">
    string1, na_sequence_id
  </tuningIndex>

  <tuningIndex name="dots.aafeat_subclassparent_ix" table="dots.AaFeatureImp">
    subclass_view, parent_id, aa_feature_id
  </tuningIndex>

  <tuningIndex name="aafeature_subclasssource_ix" table="dots.AaFeatureImp">
    subclass_view, source_id, aa_feature_id
  </tuningIndex> 

  <tuningIndex name="AnalRes_subclassRow_ix" table="rad.AnalysisResultImp">
    subclass_view, row_id
  </tuningIndex> 

  <tuningIndex name="ExonOrder_ix" table="dots.NaFeatureImp">
    subclass_view, parent_id, number3, na_feature_id
  </tuningIndex> 

</tuningConfig>
