package ApiCommonData::Load::Plugin::InsertRnaSeqPatch;
@ISA = qw(ApiCommonData::Load::Plugin::InsertStudyResults);

use lib "$ENV{GUS_HOME}/lib/perl";
use ApiCommonData::Load::Plugin::InsertStudyResults;
use GUS::PluginMgr::Plugin;
use GUS::Model::Study::ProtocolAppNode;
use GUS::Model::SRes::OntologyTerm;

use Data::Dumper;

use strict;
use warnings;

my $argsDeclaration =                                                                                                                             
[
    fileArg({name           => 'inputDir',
        descr          => 'Directory in which to find input files',
        reqd           => 1,
        mustExist      => 1,
        format         => '',
        constraintFunc => undef,
        isList         => 0, }),

    stringArg({name => 'extDbSpec',
          descr => 'External database from whence this data came|version',
          constraintFunc=> undef,
          reqd  => 1,
          isList => 0
         }),

    stringArg({name => 'studyName',
          descr => 'Name of the Study;  Will be added if it does not already exist',
          constraintFunc=> undef,
          reqd  => 1,
          isList => 0
         }),

    fileArg({name           => 'configFile',
        descr          => 'Name of config file, describes the profiles being loaded - this is generated by the plugin.',
        reqd           => 1,
        mustExist      => 0,
        format         => 'Tab file with header',
        constraintFunc => undef,
        isList         => 0
      }), # Needs to be here even though always the same as InsertStudyResults uses this value.

];

my $purpose = <<PURPOSE;                                                                                                                          
To update RNAseq profiles after a patch build
PURPOSE

my $purposeBrief = <<PURPOSE_BRIEF;
To update RNAseq profiles after a patch build
PURPOSE_BRIEF

my $notes = <<NOTES;
NOTES

my $tablesAffected = <<TABLES_AFFECTED;
TABLES_AFFECTED

my $tablesDependedOn = <<TABLES_DEPENDED_ON;
TABLES_DEPENDED_ON

my $howToRestart = <<RESTART;
There are no restart facilities for this plugin
RESTART

my $failureCases = <<FAIL_CASES;
FAIL_CASES

my $documentation = {purpose   => $purpose,
              purposeBrief     => $purposeBrief,
              notes            => $notes,
              tablesAffected   => $tablesAffected,
              tablesDependedOn => $tablesDependedOn,
              howToRestart     => $howToRestart,
              failureCases     => $failureCases };

sub new {
    my ($class) = @_;
    my $self = {};
    bless($self, $class);

    $self->initialize({ requiredDbVersion => 4.0,
                        cvsRevision => '$Revision$',
                        name => ref($self),
                        argsDeclaration => $argsDeclaration,
                        documentation => $documentation});
}

sub run {
    my ($self) = @_;
    $self->SUPER::run();
}

sub makeProtocolAppNode {
    my ($self, $nodeName, $existingAppNodes, $nodeOrderNum, $appNodeType) = @_;
    print Dumper "In InsertRnaSeqPatch subclass\n";
       
    my $ontologyTerm = GUS::Model::SRes::OntologyTerm->new({name => $appNodeType});
    unless ($ontologyTerm->retrieveFromDB()) {
        $self->error("Required ontology term \"$appNodeType\" either is not found in the database or returns more than one row from the database");
    }

    foreach my $e (@$existingAppNodes) {
        my $existingName = $e->getName();

        if ($nodeName eq $existingName) {
            $self->log("WARN:  Study already contains ProtocolAppNode Named $nodeName. In the InsertRnaSeqPatch plugin, this is expected for htseq-union and DESeq2Analysis nodes, but should be checked if other node types are reported here\n");
            return $e;
        }
    }
    my $protocolAppNode = GUS::Model::Study::ProtocolAppNode->new({name => $nodeName, node_order_num => $nodeOrderNum, type_id => $ontologyTerm->getId()});
    return $protocolAppNode;
}

#undo using this plugin will only back out profiles and leave everything else
sub undoTables {
    my ($self) = @_;
    
    return (
        'Study.Input',
        'Study.Output',
        'Results.NAFeatureExpression',
        'Results.NAFeatureDiffResult',
        );
}

1;  
