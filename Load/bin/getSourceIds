#!/usr/bin/perl
use strict;

use lib "$ENV{GUS_HOME}/lib/perl";

use Getopt::Long;
use GUS::Supported::GusConfig;
use GUS::ObjRelP::DbiDatabase;
use Data::Dumper;

my ($verbose,$outputFile,$inputFile, $blockFile, $clusterDir, $gusConfigFile);
&GetOptions("verbose!"=> \$verbose,
            "gusConfigFile=s" => \$gusConfigFile,
            "outputFile=s" => \$outputFile,
            "inputFile=s" => \$inputFile,
	    "blockFile=s" => \$blockFile,
	    "clusterDir=s" => \$clusterDir);

print STDERR "Establishing dbi login\n";

my $gusconfig = GUS::Supported::GusConfig->new($gusConfigFile);

my $db = GUS::ObjRelP::DbiDatabase->new($gusconfig->getDbiDsn(),
                                        $gusconfig->getDatabaseLogin(),
                                        $gusconfig->getDatabasePassword(),
                                        $verbose,0,1,
                                        $gusconfig->getCoreSchemaName());
my ($countEST, $countBLAT); 

my $dbh = $db->getQueryHandle(0);

my $idSQLEST = "select distinct e.na_sequence_id from dots.ExternalNASequence e, sres.sequenceontology s where e.taxon_id in($taxonIdList) and s.term_name in ('EST') and e.sequence_ontology_id = s.sequence_ontology_id";

my $idSQLBLAT = "select distinct query_na_sequence_id from dots.blatalignment where target_taxon_id=$targetTaxonId and is_best_alignment=1 and query_na_sequence_id=?";

my $idSQLBLOCK = "select distinct assembly_sequence_id from DoTS.assemblysequence where na_sequence_id = ?";

#get na_sequence_id from EnxternalNASequence for ESTs
print STDERR "idSQLEST: $idSQLEST\n idSQLBLAT: $idSQLBLAT\n " if $verbose;

my $stmt1 = $dbh->prepareAndExecute($idSQLEST);

print STDERR "idSQLEST: $idSQLEST\n";

my (%sourceidEST, %assembleidEST);

while(my ($sourceId) = $stmt1->fetchrow_array()) {

  $sourceidEST{$sourceId}= 1;

  $countEST++;
}

$stmt1->finish();

#Delete query_na_sequence_id from dots.Blatalignment
my $stmt2 = $dbh->prepare($idSQLBLAT);

print STDERR "idSQLBLAT: $idSQLBLAT\n";

foreach my $sourceId (keys %sourceidEST){

    $stmt2->execute($sourceId);

    while(my ($NaSeqBLAT) = $stmt2->fetchrow_array()){

	delete $sourceidEST{$NaSeqBLAT};

        $countBLAT++;
  }
}

my $count = keys %sourceidEST;

$stmt2->finish();

#print Dumper(\%sourceidEST);

print STDERR "Total # NA_sequence_id of ESTs: $countEST \n";

print STDERR "Total #  NA_sequence_id of BLATAlignments in ESTs: $countBLAT \n";

print STDERR "Total # of Possible  NA_sequence_ids for cluster before check block.err:  $count\n";

#convert na_sequence_id to assembly_sequence_id
my $stmt3 = $dbh->prepare($idSQLBLOCK);

print STDERR "idSQLBLOCK: $idSQLBLOCK\n";

foreach my $NaSeqId (keys %sourceidEST){

    $stmt3->execute($NaSeqId);

    while(my ($AssSeqId) = $stmt3->fetchrow_array()){

	 $assembleidEST{$AssSeqId}= 1;;
    }
}

$stmt3->finish();

$count = keys %assembleidEST;

print STDERR "Total # of Possible assembly_sequence_id for cluster before check block.err:  $count\n";

#delete assembly_sequence_id from block.err

open (FILE,$blockFile) or die "Cannot open file $blockFile  for reading \n";

while (<FILE>){

    chomp;

    if ($_ =~ /\>(\d+)/){

       delete $assembleidEST{$1};

    }
}

close(FILE);


$count = keys %assembleidEST;

print STDERR "Total # of Final assembly_sequence_id for cluster:  $count\n";

my $clusterNum=`wc -l $inputFile`;

$clusterNum++;

open(OUT,">$clusterDir/unAlignedCluster.out"); 

my @myArray = keys %assembleidEST;

my $line = join(", ",@myArray);

my $clusterline ="Cluster_$clusterNum ($count sequences): (".$line.")";

print OUT "$clusterline\n";

close("$clusterDir/unAlignedCluster.out");

print STDERR "$count clusters have been added.\n";

system "cat $inputFile $clusterDir/unAlignedCluster.out > $outputFile";

print STDERR "Cluster $clusterNum has been added to $outputFile.\n";
