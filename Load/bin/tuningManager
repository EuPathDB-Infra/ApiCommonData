#!/usr/bin/perl

use strict;
use lib "$ENV{GUS_HOME}/lib/perl";
use Data::Dumper;
use XML::Simple;
use DBI;
use Getopt::Long qw(GetOptions);
use ApiCommonData::Load::TuningConfig::InternalTable;
use ApiCommonData::Load::TuningConfig::ExternalTable;
use ApiCommonData::Load::TuningConfig::Log;

my ($configFile, $model, $instance, $password, $doUpdate, $debug, $notifyEmail);
GetOptions("configFile=s" => \$configFile,
           "model=s" => \$model,
           "instance=s" => \$instance,
           "password=s" => \$password,
           "doUpdate!" => \$doUpdate,
           "notifyEmail=s" => \$notifyEmail,
           "debug!" => \$debug,
	  );

ApiCommonData::Load::TuningConfig::Log->addLog("missing parameter: configFile") unless $configFile;
ApiCommonData::Load::TuningConfig::Log->addLog("missing parameter: notifyEmail") unless $notifyEmail;
ApiCommonData::Load::TuningConfig::Log->addLog("parameter error: either model or both instance and password must be specified")
  unless ($model || $instance && $password);
&usage unless ($configFile && $notifyEmail && ($model || $instance && $password));

my ($config) = &parseConfigFile($configFile);

my $dbh = getDbHandle($model, $instance, $password);

my %tuningTables;
my %externalTables;
foreach my $tuningTable (@{$config->{tuningTable}}) {

  $tuningTables{$tuningTable->{name}}
    = ApiCommonData::Load::TuningConfig::InternalTable->
      new($tuningTable->{name},
	  $tuningTable->{internalDependency},
	  $tuningTable->{externalDependency},
	  $tuningTable->{intermediateTable},
	  $tuningTable->{sql},
	  $tuningTable->{perl}, $dbh);
}

# validate config
my $undefinedInternal;
my $nonexistentExternal;
my $dependencyCycle;
foreach my $tableName (keys(%tuningTables)) {

  # check for internalDependencies that aren't in the list of tuningTables
  if ($tuningTables{$tableName}->getInternalDependencyNames()) {
    foreach my $dependency (@{$tuningTables{$tableName}->getInternalDependencyNames()}) {
      if (!$tuningTables{$dependency->{name}}) {
	ApiCommonData::Load::TuningConfig::Log::addLog("ERROR: $tableName has an InternalDependency on $dependency->{name}, for which no description is supplied");
	$undefinedInternal = 1;
      } else {
	# add object to list of internal dependencies
	$tuningTables{$tableName}->addInternalDependency($tuningTables{$dependency->{name}});
      }
    }
  }

  # check for externalDependencies that aren't in the database
  if ($tuningTables{$tableName}->getExternalDependencyNames()) {
    foreach my $dependency (@{$tuningTables{$tableName}->getExternalDependencyNames()}) {

      # new ExternalTable instance in the hash, if we haven't seen this
      $externalTables{$dependency->{name}}
	= ApiCommonData::Load::TuningConfig::ExternalTable->
	  new($dependency->{name}, $dbh)
	    unless ($externalTables{$dependency->{name}});

      # add external-table object to list of external dependencies
      $tuningTables{$tableName}->addExternalDependency($externalTables{$dependency->{name}});

      if (!$externalTables{$dependency->{name}}->exists()) {
	ApiCommonData::Load::TuningConfig::Log::addLog("ERROR: $tableName has an ExternalDependency on $dependency->{name}, but no such table exists");
	$nonexistentExternal = 1;
      }
    }
  }
}

# also, check for cycles in graph of dependencies (how?)
foreach my $table (keys(%tuningTables)) {
  $dependencyCycle = 1
    if $tuningTables{$table}->hasDependencyCycle([]);
}

ApiCommonData::Load::TuningConfig::Log::addLog("Note that ExternalDependencies must be tables, not views or synonyms.")
  if $nonexistentExternal;

if ($undefinedInternal || $nonexistentExternal || $dependencyCycle) {
  ApiCommonData::Load::TuningConfig::Log::addLog("\n\n****************\n\n"
						 . "INVALID CONFIGURATION -- NOT UPDATING DATABASE"
						 . "\n\n****************\n\n");
  $doUpdate = 0;
}

foreach my $table (keys(%tuningTables)) {
    $tuningTables{$table}->getState($doUpdate, $dbh);
}

print "\n\n*******\n" . ApiCommonData::Load::TuningConfig::Log->getLog() . "\n\n*******\n";
###############################################################################

sub usage {
  ApiCommonData::Load::TuningConfig::Log::addLog(
q{
Create/update "tuning tables", denormalized copies of data used to improve web site performance.

Usage: tuningManager --configFile <configXmlPath> {--model <modelName>}
                     {--instance <dbInstance>} {--password <dbPassword>}
                     {--doUpdate} --notifyEmail <emailAddressList> { --debug }

options:
  configFile  an xml file describing the tables to be created
  instance    the database instance to login and craete objects in
  password    database login password
  doUpdate    update any tables found to be out of date
  debug       print debugging info

Sample config file XML:
<tuningConfig>

  <tuningIndex table="dots.NaSequence" name="naSeq_srcSubclass_ix">
     source_id, subclass_id
  </tuningIndex>

  <tuningTable name="apidb.EstAlignmentGeneSummary">
    <internalDependency name="apidb.BlatAlignmentLocation"/>
    <internalDependency name="apidb.GeneAttributes"/>
    <externalDependency name="sres.SequenceOntology"/>
    <intermediateTables name="apidb.EstAlignmentGene"/>
    <sql>
      CREATE TABLE apidb.EstAlignmentGene AS
      SELECT ba.blat_alignment_id, ba.query_na_sequence_id, e.accession,
               e.library_id, ba.query_taxon_id, ba.target_na_sequence_id,
               ba.query_bases_aligned / (query_sequence.length)
               * 100 AS percent_est_bases_aligned,
               ga.source_id AS gene
        FROM apidb.BlatAlignmentLocation ba, dots.Est e, dots.AssemblySequence aseq,
             apidb.GeneAttributes ga, apidb.GenomicSequence sequence,
             dots.NaSequence query_sequence, sres.SequenceOntology so
        WHERE e.na_sequence_id = ba.query_na_sequence_id
          AND query_sequence.sequence_ontology_id = so.sequence_ontology_id
          AND so.term_name = 'EST'
          AND ba.target_na_sequence_id = sequence.na_sequence_id
    </sql>
    <sql>
      CREATE TABLE EstAlignmentGeneSummary&1 AS
      SELECT * FROM apidb.EstAlignmentNoGene
      UNION
      SELECT * FROM apidb.EstAlignmentGene
    </sql>
    <sql>
      CREATE INDEX apidb.EstSumm_libOverlap_ix&1
                   ON apidb.EstAlignmentGeneSummary&1
                      (library_id, percent_identity, is_consistent,
                       est_gene_overlap_length, percent_est_bases_aligned)
    </sql>
    <sql>
      CREATE INDEX apidb.EstSumm_estSite_ix&1
                   ON apidb.EstAlignmentGeneSummary&1
                      (target_sequence_source_id, target_start, target_end,
                       library_id)
    </sql>
  </tuningTable>

</tuningConfig>
});
}

sub parseConfigFile {
  my ($configFile) = @_;

  open(FILE, $configFile) || die "can't open configuration file '$configFile' for reading\n";
  my $simple = XML::Simple->new();

  # use forcearray so elements with one child are still arrays
  # and, use keyattr so that unions are given as an ordered list
  # rather than a hash
  my $config = $simple->XMLin($configFile,
			    forcearray => 1,
			    KeyAttr => {sqlValue=>'+name'});
  if ($debug) {
    print Dumper($config);
    print "\n\n";
  }

  return ($config);
}

sub getDbHandle {
  my ($model, $instance, $password) = @_;

  my $dsn = "dbi:Oracle:" . $instance;
  my $username = 'apidb';

  if ($model) {
    use ApiCommonWebsite::Model::ModelConfig;

    my $cfg = new ApiCommonWebsite::Model::ModelConfig($model);
    $username = $cfg->getLogin;
    $password = $cfg->getPassword;
    $dsn = $cfg->getDbiDsn;
  }

  my $dbh = DBI->connect(
                $dsn,
                $username,
                $password,
                { PrintError => 1, RaiseError => 0}
                ) or die "Can't connect to the database: $DBI::errstr\n";
  $dbh->{LongReadLen} = 1000;
  $dbh->{LongTruncOk} = 1;
  print "db info:\n  dsn=$instance\n  login=$username\n\n" if $debug;
  return $dbh;
}
