#!/usr/bin/perl

use strict;
use lib "$ENV{GUS_HOME}/lib/perl";

use DBI;
use Data::Dumper;
use XML::Simple;
use Getopt::Long qw(GetOptions);
use ApiCommonData::Load::TuningConfig::Log;
use ApiCommonData::Load::TuningConfig::Utils;
use ReFlow::DataSource::DataSource;
use ReFlow::DataSource::DataSources;
use CBIL::Util::PropertySet;

BEGIN {
  # This variable is declared inside a BEGIN block, to make it behave
  # like a Java "static" variable, whose state persists from one invocation to
  # another.
  my $errorFlag;

  sub setErrorFlag {
    $errorFlag = 1;
  }

  sub getErrorFlag {
    return $errorFlag;
  }
}

my ($propfile, $instance, $schema, $password, $logfile, $suffix, $project, $version, $debug);
GetOptions("propfile=s" => \$propfile,
           "instance=s" => \$instance,
           "schema=s" => \$schema,
           "password=s" => \$password,
           "logfile=s" => \$logfile,
           "suffix=s" => \$suffix,
           "project=s" => \$project,
           "version=s" => \$version,
           "debug!" => \$debug,
	  );

($instance, $schema, $password) = ApiCommonData::Load::TuningConfig::Utils::getDbLoginInfo($instance, $propFile, $schema, $password);
my $dbh = ApiCommonData::Load::TuningConfig::Utils::getDbHandle($instance, $schema, $password);


createTables($dbh, $suffix);

chdir "$ENV{GUS_HOME}/lib/xml/datasources";

my $projectQuery = $dbh->prepare(<<SQL);
  select project_id, lower(project_id) as lower_project_id
  from (select distinct project_id from ApidbTuning.SequenceAttributes)
SQL

$projectQuery->execute() or die "getting a list of project IDs";
while (my ($project, $lowerProject) = $projectQuery->fetchrow_array()) {

  loadDataSources($dbh, "globalResources.xml", $project, $version, $suffix, $debug);

  foreach my $file (`ls $lowerProject/*.xml`) {
    loadDataSources($dbh, $file, $project, $version, $suffix, $debug);
  }
}

createIndexes($dbh);

die if getErrorFlag();

################################################################################

sub loadDataSources {

    my ($dbh, $infile, $project, $version, $suffix, $debug) = @_;

    # some instances don't have corresponding data files; a null in apidb.InstanceMetaInfo.version is the tipoff.
    return if !$version;

    ApiCommonData::Load::TuningConfig::Log::addLog("loading $infile");

    my $props = CBIL::Util::PropertySet->new("$ENV{PROJECT_HOME}/workflows/$project/$version/config/stepsShared.prop",[], 1);
    $props->addProperty("dataDir", "/tmp");
    my $dataSources = ReFlow::DataSource::DataSources->new($infile, $props, getLoadedDatasets($dbh));
  ApiCommonData::Load::TuningConfig::Log::addLog(Dumper($dataSources)) if $debug;

    my $insertDs = $dbh->prepare(<<SQL);
      insert into apidb.DataSource$suffix
                  (data_source_id, name, display_name, version, categories,
                   project_id, description, contact, institution, external_database_release_id)
                  values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
SQL

    my %loadedDatasets = getLoadedDatasets($dbh);
    foreach my $dsName ($dataSources->getDataSourceNames()) {
      my $ds = $dataSources->getDataSource($dsName);
      ApiCommonData::Load::TuningConfig::Log::addLog("data source: \"$dsName\"") if $debug;
      my $rlsId = $loadedDatasets{$dsName};
      if (!$rlsId) {
	ApiCommonData::Load::TuningConfig::Log::addLog("   . . . including \"$dsName\", though it does not exist in sres.ExternalDatabase") if $debug;
# 	next;
      }
      print "data source \"$dsName\" has external database release ID $rlsId\n";
      my $dataSourceId = getNextDataSourceId($dbh, $suffix);
      $insertDs->execute($dataSourceId, $dsName, $ds->getDisplayName(),
                       $ds->getVersion(), $ds->getCategory(),
                       $project, # not $ds->getProject()
                       $ds->getDescription(), $ds->getContact(),
                       $ds->getInstitution(), $rlsId)
	or die "inserting a DataSource record";
    }
}

sub getLoadedDatasets {
  my ($dbh) = @_;

  my $query = $dbh->prepare(<<SQL);
    select ed.name, max(edr.external_database_release_id) as external_database_release_id
    from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
    where ed.external_database_id = edr.external_database_id
    group by ed.name
    having count(*) = 1
SQL

  $query->execute()
    or die "getting names from sres.ExternalDatabase";

  my %datasetHash;
  while (my ($extDbName, $extDbRlsId) = $query->fetchrow_array()) {
    $datasetHash{$extDbName} = $extDbRlsId;
  }

  return %datasetHash;
}

sub getNextDataSourceId {
  my ($dbh, $suffix) = @_;

  my $query = $dbh->prepare(<<SQL);
    select apidb.DataSource_sq$suffix.nextval from dual
SQL

  $query->execute()
    or die "getting a primary key for DataSource from its sequence";
  my ($id) = $query->fetchrow_array();

  return $id;
}

sub createTables {
    my ($dbh, $suffix) = @_;

    $dbh->do(<<SQL) or die "creating DataSource table";
      create table apidb.DataSource$suffix (
        data_source_id               number(12),
        project_id                   varchar2(30),
        name                         varchar2(120),
        version                      varchar2(60),
        external_database_release_id number(12),
        display_name                 varchar2(200),
        public_url                   varchar2(80),
        categories                   varchar2(80),
        description                  varchar2(4000),
        contact                      varchar2(80),
        institution                  varchar2(120),
        modification_date            DATE,
        user_read                    NUMBER(1),
        user_write                   NUMBER(1),
        group_read                   NUMBER(1),
        group_write                  NUMBER(1),
        other_read                   NUMBER(1),
        other_write                  NUMBER(1),
        row_user_id                  NUMBER(12),
        row_group_id                 NUMBER(3),
        row_project_id               NUMBER(4),
        row_alg_invocation_id        NUMBER(12),
        constraint DataSource_pk$suffix primary key (data_source_id),
        constraint DataSource_extdb_fk$suffix foreign key (external_database_release_id) references sres.ExternalDatabaseRelease
      )
SQL

    $dbh->do(<<SQL) or die "creating primary-key sequence for DataSource table";
      create sequence apidb.DataSource_sq$suffix
SQL

}

sub createIndexes {

}

