#!/usr/bin/perl

use strict;
use DBI;
use lib "$ENV{GUS_HOME}/lib/perl";
use Bio::SeqFeature::Gene::Exon;
use CBIL::Util::PropertySet;
use Getopt::Long;

#----------------Get UID and PWD/ database handle---------------

my ($verbose,$gusConfigFile,$outputFile,$taxonId,$coordinates,$GeneQuery,$ExonQuery);

&GetOptions("verbose!" => \$verbose,
            "outputFile=s" => \$outputFile,
            "gusConfigFile=s" => \$gusConfigFile,
            "taxonId=s" => \$taxonId,
            "coordinates=s" => \$coordinates,
	    );


$gusConfigFile = $ENV{GUS_HOME} . "/config/gus.config" unless($gusConfigFile);

unless(-e $gusConfigFile) {
  print STDERR "gus.config file not found! \n";
  exit;
}


my @properties = ();
my $gusconfig = CBIL::Util::PropertySet->new($gusConfigFile, \@properties, 1);

my $u = $gusconfig->{props}->{databaseLogin};
my $pw = $gusconfig->{props}->{databasePassword};
my $dsn = $gusconfig->{props}->{dbiDsn};

my $dbh = DBI->connect($dsn, $u, $pw) ||  die "Couldn't connect to database: " . DBI->errstr;
$dbh->{RaiseError} = 1;
$dbh->{AutoCommit} = 0;


my ($species,$indexFile,$geneFastaFile,$seqFastaFile);


#------------------------------


open(OUTINDX,">$outputFile");

print("Preparing to export genes model for Ssa...\n");

if(uc $coordinates eq "CDS"){
    $GeneQuery = &GetGeneQueryOnCDS;
}else{
    $GeneQuery = &GetGeneQuery;
}

my $sth = $dbh->prepare($GeneQuery) || die "Couldn't prepare the SQL statement: " . $dbh->errstr;
$sth->execute($taxonId) ||  die "Couldn't execute statement: " . $sth->errstr;
if(uc $coordinates eq "CDS"){
    $ExonQuery = &GetExonQueryOnCDS;
}else{
    $ExonQuery = &GetExonQuery;
}

my $sth2 = $dbh->prepare($ExonQuery) || die "Couldn't prepare the SQL statement: " . $dbh->errstr;  

while (my ($source_id, $na_feature_id,$start_min,$end_max, $strand, $sequence_id, $na_sequence_id, $exon_count ) = $sth->fetchrow_array()) {
  next unless ($exon_count);

  print OUTINDX $sequence_id."\t".$strand."\t".$start_min."\t".$end_max."\t".$exon_count."\t";

  $sth2->execute($na_feature_id,$na_sequence_id) ||  die "couldn't execute statement: " . $sth2->errstr;

  my ($exonStarts,$exonEnds);
  while (my  ($start_min,$end_max) = $sth2->fetchrow_array()) {
    $exonStarts .= $start_min.",";
    $exonEnds .= $end_max.",";
  }
  
  print OUTINDX "$exonStarts\t$exonEnds\t".$source_id."\n";
  
}

close(OUTINDX);

 
$dbh->disconnect;


#----------SUBROUTINES------------------#


#--------QUERIES-----------------#


sub GetGeneQuery {


return ("SELECT ga.source_id, ga.na_feature_id,
                  ga.start_min -1 as start_min ,
                  ga.end_max,
                  decode(ga.is_reversed, 1, '-', '+') as strand,
                  ga.sequence_id AS sequence_id,ga.na_sequence_id,
                  ga.exon_count
             FROM apidb.geneattributes ga
            WHERE ga.source_id is not null
              and ga.taxon_id = ?
            ORDER BY sequence_id,start_min,end_max,source_id");
}

sub GetExonQuery {


  return ("SELECT least(fl.start_min, fl.end_max)-1 as start_min,
                  greatest(fl.start_min, fl.end_max) as end_max
             FROM apidb.featurelocation fl
            WHERE fl.feature_type = 'ExonFeature'
              AND fl.parent_id = ?
              AND fl.na_sequence_id = ?
         ORDER BY start_min,end_max");
}

sub GetGeneQueryOnCDS {


return ("SELECT ga.source_id, ga.na_feature_id,
                  least(ga.coding_start,ga.coding_end)-1 as start_min ,
                  greatest(ga.coding_start,ga.coding_end) as end_max,
                  decode(ga.is_reversed, 1, '-', '+') as strand,
                  ga.sequence_id AS sequence_id,ga.na_sequence_id,
                  (select count(*) from dots.exonfeature ef where ef.coding_start is not null and ef.parent_id = ga.na_feature_id) as exon_count

             FROM apidb.geneattributes ga
            WHERE ga.source_id is not null
              and ga.taxon_id = ?
            ORDER BY sequence_id,start_min,end_max,source_id");
}

sub GetExonQueryOnCDS {


  return ("SELECT least(fl.coding_start,fl.coding_end)-1 as start_min,
                  greatest(fl.coding_start,fl.coding_end) as end_max
             FROM apidb.featurelocation fl
            WHERE fl.feature_type = 'ExonFeature'
              AND fl.parent_id = ?
              AND fl.na_sequence_id = ?
              AND fl.coding_start is not NULL
         ORDER BY start_min,end_max");
}


