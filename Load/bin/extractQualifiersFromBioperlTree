#!/usr/bin/perl

## extract qualifiers value from bioperlTree file that made by ISF

use strict;
use lib "$ENV{GUS_HOME}/lib/perl";
use Bio::SeqIO;
use Bio::SeqFeature::Tools::Unflattener;
use Bio::Tools::GFF;
use Bio::Seq::RichSeq;
use GUS::Supported::SequenceIterator;
use Bio::DB::GFF::Aggregator;
use Getopt::Long;

use Data::Dumper;
use FileHandle;
use HTTP::Date;

use DBI;
use DBD::Oracle;
use CBIL::Util::PropertySet;

my ($date, ) = split(" ", HTTP::Date::time2iso());
$date = join("",split(/-/,$date));


my ($help, $bioperlTreeFile, $qualifierList, $outputDir);

&GetOptions(
            'help|h' => \$help,
            'bioperlTreeFile=s' => \$bioperlTreeFile,
	    'qualifierList=s' => \$qualifierList,
	    'outputDir=s' => \$outputDir,
           );

&usage() if($help);
&usage("Missing a Required Argument") unless (defined $bioperlTreeFile && $qualifierList);

my $makeOutputDir = "mkdir $outputDir";
system ($makeOutputDir) unless ($outputDir && -e $outputDir);

my @lists = split (/\;/, $qualifierList);
my (%outputFiles, %outputFhs, $outputFile, %dbxrefFiles, %dbxrefFhs);

foreach my $list (@lists) {
  next if ($list =~ /dbxref/i || $list =~ /db_xref/i );

  $list =~ s/^\s+//;
  $list =~ s/\s+$//;

  if ($list =~ /\w+/) {
    $outputFile = $list.".txt";

    $outputFiles{$list} = ($outputDir) ? "$outputDir\/$outputFile" : "$outputFile";

    $outputFhs{$list} = FileHandle->new();
    $outputFhs{$list}->open(">$outputFiles{$list}") || die "can not open $outputFiles{$list} to write\n";
  }
}

my ($key, %gene);
open (IN, $bioperlTreeFile) || die "can not open bioperlFile to read\n";
while (<IN>) {
  chomp;
  if ($_ =~ /^\</) {
    $key = "";
  } elsif ($_ =~ /gus source_id: (\S+)/) {
    $key = $1;
    $key =~ s/\'//g;
    $key =~ s/^\s+//;
    $key =~ s/\s+$//;
  } elsif ($_ =~ /\s*(\S+?)\: (.+)/ && $key) {
    my $qual = $1;
    my $value = $2;
    my (@values, @dbxrefValues);
    if ($qual =~ /product/i) {  ## multiple products separated by ",term="
      #@values = split (/\,term=/, $value);
      @values = split (/\,[term=|rank=1;]/, $value);
      foreach my $i (0..$#values) {
	my $isPreferred=1 if ($values[$i] =~ /is_preferred=true/);
	if ($values[$i] =~ /.*term=(.+?);.*/) {
	  $values[$i]= $1;
	} elsif ($values[$i] =~ /term=(.+)/i ) {
	  $values[$i] = $1;
	} elsif ($values[$i] =~ /(.*?);.*/) {
	  $values[$i] = $1;
	}
	$values[$i] =~ s/^term=//;
	$values[$i] =~ s/^erm=//;
	$values[$i] =~ s/,rank=1$//;
	$values[$i] .= "\ttrue" if ($isPreferred == 1);
      }
      #push @values, $value;  ## push everything in one line to test
    } elsif ($qual =~ /comment/i || $qual =~ /note/i) {  ## comment or note do not separate
      push @values, $value;
    #} elsif ($qual =~ /literature/i) { ## pmid separated by '.'
    #  @values = split (/\./, $value);
    } elsif ($qual =~ /Dbxref/i || $qual =~ /db_xref/i ) { ## special need for dbxref
      #my $cValue = $value;
      #($qual, $value) = split (/\:/, $cValue);
      ($qual, $value) = split (/\:/, $value);
      $qual = "dbxref_".$qual;
      push @values, $value;
      $dbxrefFiles{$qual} = $qual.".txt";
      #print STDERR "$qual\t$value\n";
    } elsif ($qual =~ /literature/i) { ## for literature
      $value =~ s/\,/ /g;
      @values = split (/\s+/, $value);
      foreach my $i (0..$#values) {
	$values[$i] =~ s/^PMID://;
      }
    } else {
      @values = split (/\,/, $value);
    }

    foreach my $v (@values) {
      $v =~ s/;current=false$//; ## for synonym, previous_systematic_id
      #$v =~ s/^term=//; ## for product
      $v =~ s/^PMID://; ## for pmid in literature
      push @{$gene{$key}{$qual}}, $v;
    }
  }
}
close IN;

foreach my $k (sort keys %dbxrefFiles) {
  $dbxrefFiles{$k} = ($outputDir) ? "$outputDir\/$dbxrefFiles{$k}" : "$dbxrefFiles{$k}";
  $outputFhs{$k} = FileHandle->new();
  $outputFhs{$k}->open(">$dbxrefFiles{$k}") || die "can not open $dbxrefFiles{$k} to write\n";
}

foreach my $k (sort keys %gene) {
  foreach my $kk (sort keys %{$gene{$k}}) {
    #print STDERR "\$k = $k; \$kk = $kk\n";
    #print STDERR "$k; $kk; $gene{$k}{$kk}\n" if ($outputFiles{$kk});
    if ($outputFiles{$kk} || $dbxrefFiles{$kk} ) {
      foreach my $i (0..$#{$gene{$k}{$kk}}) {
	$outputFhs{$kk}->print("$k\t$gene{$k}{$kk}[$i]\n");
      }
    }
    #$outputFhs{$kk}->print("$k\t$gene{$k}{$kk}\n") if ($outputFiles{$kk});
  }
}

foreach my $k (sort keys %outputFhs) {
  $outputFhs{$k}->close();
}

############
sub usage {
  die
"
Extract function data from bioperlTree output file
Function data includes product, go, ec_number, gene name, and synonym

Usage:  extractQualifiersFromBioperlTree --bioperlTreeFile --qualifierList [--outputDir]

where
  --bioperlTreeFile:	bioperlTree file name that generated by ISF
  --qualifierList:	a semi-colon seperated list of qualifiers that want to extract
  --outputDir:          an existing file dir that the output files will write. The default is the current dir

";
}



