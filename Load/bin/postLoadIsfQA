#!/usr/bin/perl
#vvvvvvvvvvvvvvvvvvvvvvvvv GUS4_STATUS vvvvvvvvvvvvvvvvvvvvvvvvv
  # GUS4_STATUS | SRes.OntologyTerm              | auto   | absent
  # GUS4_STATUS | SRes.SequenceOntology          | auto   | absent
  # GUS4_STATUS | Study.OntologyEntry            | auto   | absent
  # GUS4_STATUS | SRes.GOTerm                    | auto   | absent
  # GUS4_STATUS | Dots.RNAFeatureExon            | auto   | broken
  # GUS4_STATUS | RAD.SageTag                    | auto   | absent
  # GUS4_STATUS | RAD.Analysis                   | auto   | absent
  # GUS4_STATUS | ApiDB.Profile                  | auto   | absent
  # GUS4_STATUS | Study.Study                    | auto   | absent
  # GUS4_STATUS | Dots.Isolate                   | auto   | absent
  # GUS4_STATUS | DeprecatedTables               | auto   | absent
  # GUS4_STATUS | Pathway                        | auto   | absent
  # GUS4_STATUS | DoTS.SequenceVariation         | auto   | absent
  # GUS4_STATUS | RNASeq Junctions               | auto   | absent
  # GUS4_STATUS | Simple Rename                  | auto   | absent
  # GUS4_STATUS | ApiDB Tuning Gene              | auto   | absent
  # GUS4_STATUS | Rethink                        | auto   | absent
  # GUS4_STATUS | dots.gene                      | manual | fixed
#die 'This file has broken or unreviewed GUS4_STATUS rules.  Please remove this line when all are fixed or absent';
#^^^^^^^^^^^^^^^^^^^^^^^^^ End GUS4_STATUS ^^^^^^^^^^^^^^^^^^^^

use strict;
use lib "$ENV{GUS_HOME}/lib/perl";
use Bio::SeqIO;
#use Bio::SeqFeature::Tools::Unflattener;
#use Bio::Tools::GFF;
#use Bio::Seq::RichSeq;
#use GUS::Supported::SequenceIterator;
#use Bio::DB::GFF::Aggregator;
use Getopt::Long;

use Data::Dumper;
use FileHandle;
use HTTP::Date;

use DBI;
use DBD::Oracle;
use CBIL::Util::PropertySet;

my ($date, ) = split(" ", HTTP::Date::time2iso());
$date = join("",split(/-/,$date));

my ($verbose, $help, $organismAbbrev, $genomeVersion, $extDbName, $extDbRlsVer, 
	$extDbRlsId, $reportFile);

&GetOptions('verbose' => \$verbose,
            'help|h' => \$help,
	    'reportFile=s' => \$reportFile,
	    'organismAbbrev=s' => \$organismAbbrev,
            'extDbName=s' => \$extDbName,
	    'extDbRlsVer=s' => \$extDbRlsVer,
	    'extDbRlsId=s' => \$extDbRlsId,
           );

&usage() if($help);

&usage("Missing a Required Argument --organismAbbrev") unless (defined $organismAbbrev);
&usage("Missing Required Argument") unless (defined ($extDbName && $extDbRlsVer) );

my $gusConfigFile = "$ENV{GUS_HOME}/config/gus.config";
my @properties = ();
my $gusconfig = CBIL::Util::PropertySet->new($gusConfigFile, \@properties, 1);
my $u = $gusconfig->{props}->{databaseLogin}; 
my $pw = $gusconfig->{props}->{databasePassword}; 
my $dsn = $gusconfig->{props}->{dbiDsn}; 
my $dbh = DBI->connect($dsn, $u, $pw) or die DBI::errstr;
$dbh->{RaiseError} = 1;
$dbh->{LongTruncOk} = 1;

## get the extDbRlsId
#if (!extDbRlsId) {
my $sql = <<SQL;
             select edr.external_database_release_id from sres.externaldatabase ed, sres.externaldatabaserelease edr 
where ed.external_database_id=edr.external_database_id and ed.name like '$extDbName' and edr.version='$extDbRlsVer'
SQL

my $stmt = $dbh->prepare($sql);
$stmt->execute();
($extDbRlsId) = $stmt->fetchrow_array();
print STDERR "For $organismAbbrev, get extDbRlsId=$extDbRlsId\n";
$stmt->finish();
#}


## A. check for if source_id is null
my @tables = ("DOTS.genefeature", "DOTS.externalnasequence",
	      "DOTS.translatedaafeature", "DOTS.translatedaasequence",
	      "DOTS.transcript",
	     "DOTS.exonfeature");

my %priKeys =(
	      'DOTS.genefeature' => 'na_feature_id',
	      'DOTS.externalnasequence' => 'na_sequence_id',
	      'DOTS.transcript' => 'na_feature_id',
	      'DOTS.exonfeature' => 'na_feature_id',
	      'DOTS.translatedaafeature' => 'aa_feature_id',
	      'DOTS.translatedaasequence' => 'aa_sequence_id',
	      );

foreach my $table (@tables) {
  my $sql = <<SQL;
              select $priKeys{$table} from $table 
              where external_database_release_id=$extDbRlsId and source_id is null
SQL

  my $stmt = $dbh->prepare($sql);
  $stmt->execute();
  my ($vldtr) = $stmt->fetchrow_array();
  if ($vldtr) {
    die "ERROR... die in the table $table, primaryKey = '$vldtr', source_id is NULL in extDbRlsId=$extDbRlsId found.\nDouble check the annotation file\n";
  }
  #print STDERR "checked table $table for source_id is not null\n";
  $stmt->finish();
}

## B. check if source_id is duplicated
my @tables = ("DOTS.genefeature", "DOTS.externalnasequence",
	      "DOTS.translatedaafeature", "DOTS.translatedaasequence",
	      "DOTS.transcript",
	     "DOTS.exonfeature");

foreach my $table (@tables) {
  my $sql = <<SQL;
              select source_id, count(source_id) from $table 
              where external_database_release_id=$extDbRlsId group by source_id having (count(source_id)>1)
SQL

  my $stmt = $dbh->prepare($sql);
  $stmt->execute();
  my ($vldtr, $cnt) = $stmt->fetchrow_array();
  if ($vldtr) {
    die "ERROR... die in table: $table, source_id: $vldtr is duplicated found.\nDouble check the annotation file\n";
  }
  #print STDERR "checked table $table for source_id is not duplicated\n";
  $stmt->finish();
}

## C. check the total number of sequence
## select * from dots.externalnasequence where external_database_release_id=358
my $sql = <<SQL;
  select count(*) from dots.externalnasequence where external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
my ($totalSeq) = $stmt->fetchrow_array();
print STDERR "The number of sequences that have been loaded = $totalSeq\n";
$stmt->finish();

## D. check the total sequence length
my $sql = <<SQL;
  select sum(length) from dots.externalnasequence where external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
my ($totalSeqLength) = $stmt->fetchrow_array();
print STDERR "The length of sequences that have been loaded = $totalSeqLength\n";
$stmt->finish();

## E. check the gene number that has been loaded
my $sql = <<SQL;
  select count(*) from DOTS.genefeature where external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
my ($geneCount) = $stmt->fetchrow_array();
print STDERR "The number of genes that have been loaded = $geneCount\n";
$stmt->finish();

## F. check the gene number that has been loaded in different categories 
my $sql = <<SQL;
  select distinct name, count(*) from dots.genefeature where external_database_release_id=$extDbRlsId group by name order by name
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
while (my ($geneType, $geneTypeCount) = $stmt->fetchrow_array()) {
  print STDERR "  $geneType = $geneTypeCount\n";
}
$stmt->finish();

## E-2. check the transcript number that has been loaded
my $sql = <<SQL;
  select count(*) from DOTS.genefeature where name like 'coding_gene' and external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
my ($codingGeneCount) = $stmt->fetchrow_array();
$stmt->finish();

my $sql = <<SQL;
  select count(*) from dots.transcript where parent_id in (select na_feature_id from dots.genefeature where name like 'coding_gene' and external_database_release_id=$extDbRlsId)
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
my ($codingTransCount) = $stmt->fetchrow_array();
$stmt->finish();

my $sqlp = <<SQL;
  select count(taf.SOURCE_ID) from dots.genefeature gf, dots.transcript t, DOTS.TRANSLATEDAAFEATURE taf where gf.NA_FEATURE_ID=t.PARENT_ID and t.NA_FEATURE_ID=taf.NA_FEATURE_ID and gf.name like 'coding_gene' and gf.EXTERNAL_DATABASE_RELEASE_ID=$extDbRlsId
SQL
my $stmtp = $dbh->prepare($sqlp);
$stmtp->execute();
my ($codingProtCount) = $stmtp->fetchrow_array();
$stmtp->finish();

print STDERR "The number of coding_gene loaded = $codingGeneCount\nFor these coding_genes, transcript loaded = $codingTransCount, translatedAAFeature loaded = $codingProtCount\n" if ($codingGeneCount && $codingTransCount);

## G. check the pseudogene
my $sql = <<SQL;
  select distinct t.is_pseudo, count(*) from dots.genefeature gf, dots.transcript t 
where t.parent_id=gf.na_feature_id and gf.external_database_release_id=$extDbRlsId and gf.name like 'coding_gene' group by t.is_pseudo
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
print STDERR "  check if pseudo...\n";
while (my ($if, $psdCount) = $stmt->fetchrow_array()) {
  ($if == 1 )? print STDERR "    is pseudogene = $psdCount\n" : print STDERR "    is not pseudogene = $psdCount\n";
}
$stmt->finish();

## H. check if is_partial
my $sql = <<SQL;
  select distinct t.is_partial, count(*) from dots.genefeature gf, dots.transcript t where t.parent_id=gf.na_feature_id and gf.external_database_release_id=$extDbRlsId and gf.name like 'coding_gene' group by t.is_partial
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
print STDERR "  check if partial...\n";
while (my ($if, $ptlCount) = $stmt->fetchrow_array()) {
  ($if == 1 )? print STDERR "    is partial = $ptlCount\n" : print STDERR "    is not partial = $ptlCount\n";
}
$stmt->finish();

## I. check if the translatedaasequence does not have null sequence 
##    and also check if the length of aa sequence < 10
my $sql = <<SQL;
  select source_id, sequence from dots.translatedaasequence where external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
while (my ($aaSourceId, $aaSeq) = $stmt->fetchrow_array() ) {
  print STDERR "ERROR... the translatedaasequence for $aaSourceId is null. Check the mapping file if it includes the validateCodingSequenceLength validator\n" unless ($aaSeq);
  if (length($aaSeq) < 10) {
    $aaSourceId =~ s/\-\d$//g;
    print STDERR "WARNING... the length of protein sequence is less than 10 aa.\n    $aaSourceId: $aaSeq\n";
  }
}
$stmt->finish();

## J. check the seq # in translatedaaSequence table and translatedaaFeature table
my $sql = <<SQL;
  select count(*) from dots.translatedaasequence where external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
my ($tranAaSeq) = $stmt->fetchrow_array();
$stmt->finish();
print STDERR "ERROR: the number of translatedAASequence, $tranAaSeq, which is not equal to the number of coding_gene in transcript table, $codingTransCount\nThis will be OK when one transcript has more than one translation in gus4. Keep here to catch this case.\n" unless ($tranAaSeq == $codingTransCount);

my $sql = <<SQL;
  select count(*) from dots.translatedaafeature where external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
my ($tranAaFeat) = $stmt->fetchrow_array();
$stmt->finish();
print STDERR "ERROR... the number of translatedAAFeature, $tranAaFeat, which is not equal to the number of coding_gene in transcript table, $codingTransCount\nThis will be OK when one transcript has more than one translation in gus4. Keep here to catch this case.\n" unless ($tranAaFeat == $codingTransCount);


## K. check the translatedAaFeature table, translation_start or translation_stop can not be null or < 0
foreach my $column ("translation_start", "translation_stop") {
  foreach my $exp ("is null", "< 0") {
my $sql = <<SQL;
  select source_id from dots.translatedaafeature where external_database_release_id=$extDbRlsId and $column $exp
SQL
    my $stmt = $dbh->prepare($sql);
    $stmt->execute();
    while (my ($sourceId) = $stmt->fetchrow_array() ) {
      print STDERR "ERROR: in the table dots.translatedaafeature, $sourceId, $column $exp . \n" if ($sourceId);
    }
    $stmt->finish();
  }
}

## L. for all genes other than coding_gene and pseudo_gene, the coding_start and coding_end in dots.exonfeature should be always null
## this is not necessary in gus4 because the coding_start and coding_end in dots.exonfeature are always null
my $sql = <<SQL;
  select gf.name, gf.na_feature_id, gf.source_id, ef.coding_start, ef.coding_end from dots.exonfeature ef, dots.genefeature gf where ef.parent_id=gf.na_feature_id and gf.name not like 'coding_gene' and gf.name not like 'pseudo_gene' and ef.coding_end is not null and gf.external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
while (my ($gfName, $gfNaId, $gfSourceId, $efCodingStart, $efCodingEnd) = $stmt->fetchrow_array()) {
  print STDERR "ERROR: found $gfName with na_feature_id = $gfNaId and source_id = $gfSourceId has coding_start and coding_end at $efCodingStart $efCodingEnd, which should be NULL\n" if ($gfName);
}
$stmt->finish();

## M. check if gene location is located outside the naSequence length
my $sql = <<SQL;
  select gf.source_id, nl.start_min, nl.end_max, ens.source_id, ens.length from dots.externalnasequence ens, dots.genefeature gf, dots.nalocation nl where gf.na_feature_id=nl.na_feature_id and gf.na_sequence_id=ens.na_sequence_id and nl.end_max > ens.length and ens.external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
while (my ($gfSourceId, $nlStartMin, $nlEndMax, $seqSourceId, $seqLength) = $stmt->fetchrow_array()) {
  print STDERR "ERROR: gene $gfSourceId with $nlStartMin .. $nlEndMax, which is outside the sequence $seqSourceId 's length: $seqLength. Need to check the annotation file\n";
}
$stmt->finish();

## N. check if there is any duplicated exons since it happens in TriTryp, This also can be a check for alternative splicing coding of distinct exons.
my $sql = <<SQL;
  select t.source_id, nl.start_min, nl.end_max, count(*) from dots.transcript t, dots.rnafeatureexon rfe, dots.exonfeature ef, DOTS.nalocation nl where t.na_feature_id=rfe.rna_feature_id and ef.NA_FEATURE_ID=rfe.EXON_FEATURE_ID and nl.NA_FEATURE_ID=ef.NA_FEATURE_ID and t.external_database_release_id=$extDbRlsId group by t.source_id, nl.start_min, nl.end_max having count(*)>1
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
while (my ($tSourceId, $nlStartMin, $nlEndMax, $nlCount) = $stmt->fetchrow_array()) {
  print STDERR "ERROR: duplicated exons found on $tSourceId with start_min $nlStartMin and end_max $nlEndMax with count $nlCount .\n" if ($tSourceId);
}
$stmt->finish();

## O. check if there is any overlap exon, check by each transcript in case of alternative splicing
my $sql = <<SQL;
  select source_id from DOTS.transcript where external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();

my $c = 0;
while (my ($sourceId) = $stmt->fetchrow_array()) {

  my %exonLocations;

my $sqll = <<SQL;
  select t.source_id, ef.source_id, nl.start_min, nl.end_max, t.IS_PSEUDO 
from Dots.transcript t, DOTS.rnafeatureexon rfe, DOTS.exonfeature ef, DOTS.nalocation nl 
where t.na_feature_id=rfe.rna_feature_id and rfe.exon_feature_id=ef.na_feature_id 
and nl.na_feature_id=ef.na_feature_id and t.external_database_release_id=$extDbRlsId and t.source_id like '$sourceId' 
order by t.source_id, nl.start_min
SQL

  my $stmtt = $dbh->prepare($sqll);
  $stmtt->execute();

  my $tIsPseudo;
  while (my ($tSourceId, $efSourceId, $nlStartMin, $nlEndMax, $isPseudo) = $stmtt->fetchrow_array() ) {
    $exonLocations{$tSourceId}{$efSourceId} = "$nlStartMin,$nlEndMax" if ($nlStartMin && $nlEndMax && $efSourceId && $tSourceId);
    $tIsPseudo = $isPseudo;
  }
  $stmtt->finish();
  $c++;

  foreach my $k (sort keys %exonLocations) {
    my ($preExonId, $preStartMin, $preEndMax);
    foreach my $kk (sort keys %{$exonLocations{$k}}) {
      my ($start, $end) = split (/\,/, $exonLocations{$k}{$kk});
      if ($preStartMin ) {
	if ( ( ($start > $preEndMax) && ($end > $preEndMax) ) || ( ($start < $preStartMin) && ($end < $preStartMin ) )){
	  $preExonId = $k;
	  $preStartMin = $start;
	  $preEndMax = $end;
	} else {
	  my $ems = "ERROR need to correct at gus4... overlapped exons found on ";
	  $ems .= "Pseudo " if ($tIsPseudo == 1);
	  $ems .= "transcript $k, exon $kk ($start..$end) and $preExonId ($preStartMin..$preEndMax)\n";
	  print STDERR $ems;
	}
      }
# else {
	$preExonId = $kk;
	$preStartMin = $start;
	$preEndMax = $end;
#      }
    }
  }
}
$stmt->finish();

## OO. check if duplicated genes happen in the same sequence at the same position, Bug #14787
## the overlapped genes are possible biologically, particularly if they are on the reversed strand, so do not need to catch these errores

my $sqloo = "select na_sequence_id, source_id from DOTS.externalnasequence where external_database_release_id=$extDbRlsId";
my $stmt = $dbh->prepare($sqloo);
$stmt->execute();

while (my ($naSeqId, $naSourceId) = $stmt->fetchrow_array()) {

  my $sqloo2 = "select gf.source_id, nl.start_min, nl.end_max, nl.is_reversed from dots.genefeature gf, DOTS.nalocation nl 
where gf.na_feature_id=nl.na_feature_id and gf.na_sequence_id=$naSeqId order by nl.start_min";

  my $stmtt = $dbh->prepare($sqloo2);
  $stmtt->execute();

  my ($preSourceId, $preStart, $preEnd);
  while (my ($gfSourceId, $nlStartMin, $nlEndMax, $strand) = $stmtt->fetchrow_array() ) {
    print STDERR "In sequence $naSourceId, gene $gfSourceId and $preSourceId are duplicated at position $nlStartMin \.\. $nlEndMax\n" if ($preStart == $nlStartMin && $preEnd == $nlEndMax);

    ## print STDERR "In $naSourceId, $strand strand, $gfSourceId and $preSourceId are overlapped. $gfSourceId: $nlStartMin \.\. $nlEndMax; $preSourceId: $preStart \.\. $preEnd\n" if ($nlStartMin < $preEnd);

    $preSourceId = $gfSourceId;
    $preStart = $nlStartMin;
    $preEnd = $nlEndMax;
  }
  $stmtt->finish();
}
$stmt->finish();

## MM. check the length of transcript is not shorter than the sum of the exons's length, Bug #14407 
my (%tSourceIds, %tLengths);
my $sql = "select t.na_feature_id, t.source_id, nl.start_min, nl.end_max, nl.is_reversed 
from dots.transcript t, dots.nalocation nl
where nl.na_feature_id=t.na_feature_id and t.external_database_release_id=$extDbRlsId";
my $stmt = $dbh->prepare($sql);
$stmt->execute();
while (my ($tNaFeatureId, $tSourceId, $tStart, $tEnd, $ifTrasReversed) = $stmt->fetchrow_array() ) {
  $tSourceIds{$tNaFeatureId} = $tSourceId;
  $tLengths{$tNaFeatureId} = abs($tStart-$tEnd) + 1;
}
$stmt->finish();

foreach my $kk (sort keys %tSourceIds) {
  my $sql = "select nl.start_min, nl.end_max, nl.is_reversed from DOTS.rnafeatureexon rfe, dots.exonfeature ef, DOTS.nalocation nl where rfe.exon_feature_id=ef.na_feature_id and ef.na_feature_id=nl.na_feature_id and rfe.rna_feature_id=?";
  my $stmt = $dbh->prepare($sql);
  $stmt->execute($kk);
  my $exonLength = 0;
  while (my ($eStart, $eEnd, $eIfRev) = $stmt->fetchrow_array() ) {
    $exonLength += abs($eStart-$eEnd)+1;
  }
  $stmt->finish();
  print STDERR "ERROR... the transcript $tSourceIds{$kk} found with the transcript length $tLengths{$kk} < sum of exons length $exonLength , need to contact the data provider to make sure the gene coordinates are correct\n" if ($tLengths{$kk} < $exonLength);
}


## P. check the dots.Miscellaneous table for example centromere
my $sql = <<SQL;
  select distinct name, count(*) from dots.Miscellaneous where external_database_release_id=$extDbRlsId group by name
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
while (my ($name, $count) = $stmt->fetchrow_array()) {
  print STDERR "$name = $count\n" if ($name && $count);
}
$stmt->finish();

## Q. check the table dots.ScaffoldGapFeature for gap
my $sql = <<SQL;
  select count(*) from dots.ScaffoldGapFeature where external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
my ($gapCount) = $stmt->fetchrow_array();
print STDERR "the number of gap = $gapCount\n" if ($gapCount);
$stmt->finish();

## R. check the table dots.source
my $sql = <<SQL;
  select count(*) from DOTS.source where external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
my ($sourceCount) = $stmt->fetchrow_array();
print STDERR "the number of source = $sourceCount\n" if ($sourceCount);
$stmt->finish();

## S. check the table dots.Repeats
my $sql = <<SQL;
  select count(*) from dots.Repeats where external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
my ($repeatsCount) = $stmt->fetchrow_array();
print STDERR "the number of repeats = $repeatsCount\n" if ($repeatsCount);
$stmt->finish();

## T. check the table dots.TransposableElement
my $sql = <<SQL;
  select count(*) from dots.transposableelement where external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
my ($transposableCount) = $stmt->fetchrow_array();
print STDERR "the number of transposableElement = $transposableCount\n" if ($repeatsCount);
$stmt->finish();


sub usage {
  die
"
A script to do QA for ISF post loading, this should be done right after ISF testing
Usage: postLoadIsfQA --organismAbbrev pvivSal1 --extDbName pvivSaI1_primary_genome_RSRC --extDbRlsVer 2013-05-01

NOTE: the GUS_HOME should point to the instance that the annotation has been loaded

where
  --organismAbbrev: the organism Abbrev in the table apidb.organism
  --extDbName: the external database name for loading genome and annoation
  --extDbRlsVer: the external database release version for loading genome and annotation

";
}

q{
##### the list to check #########

DONE -- 1. select * from dots.genefeature where external_database_release_id=374 and source_id IS NULL;
DONE -- 2. select source_id, count(source_id) from dots.genefeature where external_database_release_id=374 group by source_id having (count(source_id)>1);
DONE -- 3. select distinct name, count(*) from dots.genefeature where external_database_release_id=358 group by name;
DONE -- 4. select count(*) from DOTS.genefeature where external_database_release_id=358;
DONE -- 5. select distinct is_pseudo, count(*) from dots.genefeature where external_database_release_id=358 and name like 'coding_gene' group by is_pseudo;
DONE -- 6. select distinct is_partial, count(*) from dots.genefeature where external_database_release_id=358 and name like 'coding_gene' group by is_partial;

DONE -- 7. select * from dots.externalnasequence where external_database_release_id=358;
DONE -- 8. select sum(length) from dots.externalnasequence where external_database_release_id=358;

DONE -- 9. select * from dots.translatedaasequence where external_database_release_id=358;
DONE -- 10. select count(*) from dots.translatedaafeature where external_database_release_id=358;
DONE -- 12. select * from dots.translatedaafeature where external_database_release_id=358 and translation_stop is null;
DONE -- 13. select * from dots.translatedaafeature where external_database_release_id=358 and translation_start < 0;

DONE -- 14. select gf.name, gf.na_feature_id, gf.source_id, ef.coding_start, ef.coding_end from dots.exonfeature ef, dots.genefeature gf 
where ef.parent_id=gf.na_feature_id and gf.name not like 'coding_gene' and ef.coding_end is not null and gf.name not like 'pseudo_gene';

DONE in 1 -- 15. select * from dots.translatedaafeature where external_database_release_id=358 and source_id is null;
DONE in 1 -- 16. select * from dots.translatedaasequence where external_database_release_id=358 and source_id is null;

DONE -- 17. select ens.na_sequence_id, nl.na_feature_id, ens.source_id, ens.length, nl.end_max 
from dots.externalnasequence ens, dots.genefeature gf, dots.nalocation nl 
where gf.na_feature_id=nl.na_feature_id and gf.na_sequence_id=ens.na_sequence_id 
and nl.end_max > ens.length and ens.external_database_release_id=358;

DONE in 1 -- 18. select * from dots.exonfeature where external_database_release_id=358 and source_id IS NULL;
DONE in 2 -- 19. select source_id, count(source_id) from dots.exonfeature where external_database_release_id=348 group by source_id having (count(source_id)>1);

DONE -- 20. select t.source_id, nl.start_min, nl.end_max, count(*) from dots.transcript t, dots.rnafeatureexon rfe, DOTS.nalocation nl
where t.na_feature_id=rfe.rna_feature_id
and nl.na_feature_id=rfe.exon_feature_id
group by t.source_id, nl.start_min, nl.end_max having count(*)>1;

## to check if there is duplicated exons, it happens in TriTrypDB
DONE -- 21. select gf.source_id, ef.coding_start, ef.coding_end, ef.name, ef.source_id, nl.start_min, nl.end_max 
from dots.genefeature gf, DOTS.exonfeature ef, DOTS.nalocation nl
where gf.na_feature_id=ef.parent_id and ef.na_feature_id=nl.na_feature_id
and gf.source_id like 'PYYM_0902200%' and gf.external_database_release_id=358;

DONE -- 22. select count(*) from dots.Repeats where external_database_release_id=358;
DONOTNEED -- 23. select distinct na_sequence_id, count(na_sequence_id) from dots.Repeats where external_database_release_id=358 group by na_sequence_id;

DONE -- 24. select count(*) from dots.ScaffoldGapFeature where external_database_release_id=358;

DONE -- 25. select count(*) from DOTS.source where external_database_release_id=358;

DONE -- 26. select * from dots.Miscellaneous where external_database_release_id=358;

TODO -- 27. check if the UTRs is inside the CDS or there is any overlapping exons for Bug #13296

## to check if there is overlap exons
DONE -- 28. select gf.source_id, ef.source_id, nl.start_min, nl.end_max
from DOTS.genefeature gf, DOTS.exonfeature ef, DOTS.nalocation nl 
where gf.na_feature_id=ef.parent_id and nl.na_feature_id=ef.na_feature_id
and gf.external_database_release_id=$extDbRlsId and gf.source_id like '$sourceId'

};


