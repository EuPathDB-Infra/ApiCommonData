#!/usr/bin/perl

use strict;
use lib "$ENV{GUS_HOME}/lib/perl";
use Bio::SeqIO;
#use Bio::SeqFeature::Tools::Unflattener;
#use Bio::Tools::GFF;
#use Bio::Seq::RichSeq;
#use GUS::Supported::SequenceIterator;
#use Bio::DB::GFF::Aggregator;
use Getopt::Long;

use Data::Dumper;
use FileHandle;
use HTTP::Date;

use DBI;
use DBD::Oracle;
use CBIL::Util::PropertySet;

my ($date, ) = split(" ", HTTP::Date::time2iso());
$date = join("",split(/-/,$date));

my ($verbose, $help, $organismAbbrev, $genomeVersion, $extDbName, $extDbRlsVer, 
	$extDbRlsId, $reportFile);

&GetOptions('verbose' => \$verbose,
            'help|h' => \$help,
	    'reportFile=s' => \$reportFile,
	    'organismAbbrev=s' => \$organismAbbrev,
            'extDbName=s' => \$extDbName,
	    'extDbRlsVer=s' => \$extDbRlsVer,
	    'extDbRlsId=s' => \$extDbRlsId,
           );

&usage() if($help);

&usage("Missing a Required Argument --organismAbbrev") unless (defined $organismAbbrev);
&usage("Missing Required Argument") unless (defined ($extDbName && $extDbRlsVer) );

my $gusConfigFile = "$ENV{GUS_HOME}/config/gus.config";
my @properties = ();
my $gusconfig = CBIL::Util::PropertySet->new($gusConfigFile, \@properties, 1);
my $u = $gusconfig->{props}->{databaseLogin}; 
my $pw = $gusconfig->{props}->{databasePassword}; 
my $dsn = $gusconfig->{props}->{dbiDsn}; 
my $dbh = DBI->connect($dsn, $u, $pw) or die DBI::errstr;
$dbh->{RaiseError} = 1;
$dbh->{LongTruncOk} = 1;

## get the extDbRlsId
#if (!extDbRlsId) {
my $sql = <<SQL;
             select edr.external_database_release_id from sres.externaldatabase ed, sres.externaldatabaserelease edr 
where ed.external_database_id=edr.external_database_id and ed.name like '$extDbName' and edr.version='$extDbRlsVer'
SQL

my $stmt = $dbh->prepare($sql);
$stmt->execute();
($extDbRlsId) = $stmt->fetchrow_array();
print STDERR "For $organismAbbrev, get extDbRlsId=$extDbRlsId\n";
$stmt->finish();
#}


## A. check for if source_id is null
my @tables = ("DOTS.genefeature", "DOTS.externalnasequence",
	      "DOTS.translatedaafeature", "DOTS.translatedaasequence",
	      "DOTS.transcript",
	     "DOTS.exonfeature");

my %priKeys =(
	      'DOTS.genefeature' => 'na_feature_id',
	      'DOTS.externalnasequence' => 'na_sequence_id',
	      'DOTS.transcript' => 'na_feature_id',
	      'DOTS.exonfeature' => 'na_feature_id',
	      'DOTS.translatedaafeature' => 'aa_feature_id',
	      'DOTS.translatedaasequence' => 'aa_sequence_id',
	      );

foreach my $table (@tables) {
  my $sql = <<SQL;
              select $priKeys{$table} from $table 
              where external_database_release_id=$extDbRlsId and source_id is null
SQL

  my $stmt = $dbh->prepare($sql);
  $stmt->execute();
  my ($vldtr) = $stmt->fetchrow_array();
  if ($vldtr) {
    die "ERROR... die in the table $table, primaryKey = '$vldtr', source_id is NULL in extDbRlsId=$extDbRlsId found.\nDouble check the annotation file\n";
  }
  #print STDERR "checked table $table for source_id is not null\n";
  $stmt->finish();
}

## B. check if source_id is duplicated
my @tables = ("DOTS.genefeature", "DOTS.externalnasequence",
	      "DOTS.translatedaafeature", "DOTS.translatedaasequence",
	      "DOTS.transcript",
	     "DOTS.exonfeature");

foreach my $table (@tables) {
  my $sql = <<SQL;
              select source_id, count(source_id) from $table 
              where external_database_release_id=$extDbRlsId group by source_id having (count(source_id)>1)
SQL

  my $stmt = $dbh->prepare($sql);
  $stmt->execute();
  my ($vldtr, $cnt) = $stmt->fetchrow_array();
  if ($vldtr) {
    die "ERROR... die in table: $table, source_id: $vldtr is duplicated found.\nDouble check the annotation file\n";
  }
  #print STDERR "checked table $table for source_id is not duplicated\n";
  $stmt->finish();
}

## C. check the total number of sequence
## select * from dots.externalnasequence where external_database_release_id=358
my $sql = <<SQL;
  select count(*) from dots.externalnasequence where external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
my ($totalSeq) = $stmt->fetchrow_array();
print STDERR "The total number of sequence that have been loaded = $totalSeq\n";
$stmt->finish();

## D. check the total sequence length
my $sql = <<SQL;
  select sum(length) from dots.externalnasequence where external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
my ($totalSeqLength) = $stmt->fetchrow_array();
print STDERR "The total sequence length = $totalSeqLength\n";
$stmt->finish();

## E. check the gene number that has been loaded
my $sql = <<SQL;
  select count(*) from DOTS.genefeature where external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
my ($geneCount) = $stmt->fetchrow_array();
print STDERR "The total gene number that have been loaded = $geneCount\n";
$stmt->finish();

## F. check the gene number that has been loaded in different categories 
my $sql = <<SQL;
  select distinct name, count(*) from dots.genefeature where external_database_release_id=$extDbRlsId group by name
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
while (my ($geneType, $geneTypeCount) = $stmt->fetchrow_array()) {
  print STDERR "  $geneType = $geneTypeCount\n";
}
$stmt->finish();

## G. check the pseudogene
my $sql = <<SQL;
  select distinct is_pseudo, count(*) from dots.genefeature where external_database_release_id=$extDbRlsId and name like 'coding_gene' group by is_pseudo
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
print STDERR "For coding_gene, check if it is pseudogene...\n";
while (my ($if, $psdCount) = $stmt->fetchrow_array()) {
  ($if == 1 )? print STDERR "  is pseudogene = $psdCount\n" : print STDERR "  not pseudogene = $psdCount\n";
}
$stmt->finish();

## H. check if is_partial
my $sql = <<SQL;
  select distinct is_partial, count(*) from dots.genefeature where external_database_release_id=$extDbRlsId and name like 'coding_gene' group by is_partial
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
print STDERR "For coding_gene, check if it is partial gene...\n";
while (my ($if, $ptlCount) = $stmt->fetchrow_array()) {
  ($if == 1 )? print STDERR "  is partial gene = $ptlCount\n" : print STDERR "  not partial gene = $ptlCount\n";
}
$stmt->finish();

## I. check if the translatedaasequence does not have null sequence 
##    and also check if the length of aa sequence < 10
my $sql = <<SQL;
  select source_id, sequence from dots.translatedaasequence where external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
while (my ($aaSourceId, $aaSeq) = $stmt->fetchrow_array() ) {
  print STDERR "ERROR... the translatedaasequence for $aaSourceId is null. Check the mapping file if it includes the validateCodingSequenceLength validator\n" unless ($aaSeq);
  if (length($aaSeq) < 10) {
    $aaSourceId =~ s/\-\d$//g;
    print STDERR "WARNING... the length of protein sequence is less than 10 aa.\n    $aaSourceId: $aaSeq\n";
  }
}
$stmt->finish();

## J. check the seq # in translatedaaSequence table and translatedaaFeature table
my $sql = <<SQL;
  select count(*) from DOTS.genefeature where external_database_release_id=$extDbRlsId and name like 'coding_gene'
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
my ($codingGene) = $stmt->fetchrow_array();
$stmt->finish();

my $sql = <<SQL;
  select count(*) from dots.translatedaasequence where external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
my ($tranAaSeq) = $stmt->fetchrow_array();
$stmt->finish();
print STDERR "ERROR: the translated aa sequence = $tranAaSeq, which is not equal to coding_gene = $codingGene\n" unless ($tranAaSeq == $codingGene);

my $sql = <<SQL;
  select count(*) from dots.translatedaafeature where external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
my ($tranAaFeat) = $stmt->fetchrow_array();
$stmt->finish();
print STDERR "ERROR... the translated aa feature = $tranAaFeat, which is not equal to coding_gene = $codingGene\n" unless ($tranAaFeat == $codingGene);


## K. check the translatedAaFeature table, translation_start or translation_stop can not be null or < 0
foreach my $column ("translation_start", "translation_stop") {
  foreach my $exp ("is null", "< 0") {
my $sql = <<SQL;
  select source_id from dots.translatedaafeature where external_database_release_id=$extDbRlsId and $column $exp
SQL
    my $stmt = $dbh->prepare($sql);
    $stmt->execute();
    while (my ($sourceId) = $stmt->fetchrow_array() ) {
      print STDERR "ERROR: in the table dots.translatedaafeature, $sourceId, $column $exp . \n" if ($sourceId);
    }
    $stmt->finish();
  }
}

## L. for all genes other than coding_gene and pseudo_gene, the coding_start and coding_end in dots.exonfeature should be always null
my $sql = <<SQL;
  select gf.name, gf.na_feature_id, gf.source_id, ef.coding_start, ef.coding_end from dots.exonfeature ef, dots.genefeature gf where ef.parent_id=gf.na_feature_id and gf.name not like 'coding_gene' and gf.name not like 'pseudo_gene' and gf.name not like 'kinetoplast_gene' and ef.coding_end is not null
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
while (my ($gfName, $gfNaId, $gfSourceId, $efCodingStart, $efCodingEnd) = $stmt->fetchrow_array()) {
  print STDERR "ERROR: found $gfName with na_feature_id = $gfNaId and source_id = $gfSourceId has coding_start and coding_end at $efCodingStart $efCodingEnd, which should be NULL\n" if ($gfName);
}
$stmt->finish();

## M. check if gene location is located outside the naSequence length
my $sql = <<SQL;
  select gf.source_id, nl.start_min, nl.end_max, ens.source_id, ens.length from dots.externalnasequence ens, dots.genefeature gf, dots.nalocation nl where gf.na_feature_id=nl.na_feature_id and gf.na_sequence_id=ens.na_sequence_id and nl.end_max > ens.length and ens.external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
while (my ($gfSourceId, $nlStartMin, $nlEndMax, $seqSourceId, $seqLength) = $stmt->fetchrow_array()) {
  print STDERR "ERROR: gene $gfSourceId with $nlStartMin .. $nlEndMax, which is outside the sequence $seqSourceId 's length: $seqLength. Need to check the annotation file\n";
}
$stmt->finish();

## N. check if there is any duplicated exons since it happens in TriTryp
my $sql = <<SQL;
  select t.source_id, nl.start_min, nl.end_max, count(*) from dots.transcript t, dots.rnafeatureexon rfe, DOTS.nalocation nl where t.na_feature_id=rfe.rna_feature_id and nl.na_feature_id=rfe.exon_feature_id and t.external_database_release_id=$extDbRlsId group by t.source_id, nl.start_min, nl.end_max having count(*)>1
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
while (my ($tSourceId, $nlStartMin, $nlEndMax, $nlCount) = $stmt->fetchrow_array()) {
  print STDERR "ERROR: duplicated exons found.\n  $tSourceId with start_min $nlStartMin and end_max $nlEndMax with count $nlCount .\n" if ($tSourceId);
}
$stmt->finish();

## O. check if overlap exons which happen in TriTrypDB
my $sql = <<SQL;
  select source_id from DOTS.genefeature where external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();

my $c = 0;
while (my ($sourceId) = $stmt->fetchrow_array()) {

  my %exonLocations;

my $sqll = <<SQL;
  select gf.source_id, ef.source_id, nl.start_min, nl.end_max
from DOTS.genefeature gf, DOTS.exonfeature ef, DOTS.nalocation nl 
where gf.na_feature_id=ef.parent_id and nl.na_feature_id=ef.na_feature_id
and gf.external_database_release_id=$extDbRlsId and gf.source_id like '$sourceId' 
order by nl.start_min
SQL

  my $stmtt = $dbh->prepare($sqll);
  $stmtt->execute();

  while (my ($gfSourceId, $efSourceId, $nlStartMin, $nlEndMax) = $stmtt->fetchrow_array() ) {
    $exonLocations{$efSourceId} = "$nlStartMin,$nlEndMax,$gfSourceId" if ($efSourceId && $nlStartMin && $nlEndMax && $gfSourceId);
  }
  $stmtt->finish();
  $c++;

  my ($preExonId, $preStartMin, $preEndMax);
  foreach my $k (sort keys %exonLocations) {
    my ($start, $end, $gid) = split (/\,/, $exonLocations{$k});
    if ($preStartMin ) {
      if ( ( ($start > $preEndMax) && ($end > $preEndMax) ) || ( ($start < $preStartMin) && ($end < $preStartMin ) )){
	$preExonId = $k;
        $preStartMin = $start;
        $preEndMax = $end;
      } else {
        print STDERR "ERROR... overlapped exons found.\ndouble check the gene $gid, exon $k ($start..$end) and $preExonId ($preStartMin..$preEndMax) are overlapped\n";
      }
    } else {
      $preExonId = $k;
      $preStartMin = $start;
      $preEndMax = $end;
    }
  }
}
$stmt->finish();

## OO. check if duplicated genes happen in the same sequence at the same position, Bug #14787
my $sqloo = "select na_sequence_id, source_id from DOTS.externalnasequence where external_database_release_id=$extDbRlsId";
my $stmt = $dbh->prepare($sqloo);
$stmt->execute();

while (my ($naSeqId, $naSourceId) = $stmt->fetchrow_array()) {

  my $sqloo2 = "select gf.source_id, nl.start_min, nl.end_max from dots.genefeature gf, DOTS.nalocation nl 
where gf.na_feature_id=nl.na_feature_id and gf.na_sequence_id=$naSeqId order by nl.start_min";

  my $stmtt = $dbh->prepare($sqloo2);
  $stmtt->execute();

  my ($preSourceId, $preStart, $preEnd);
  while (my ($gfSourceId, $nlStartMin, $nlEndMax) = $stmtt->fetchrow_array() ) {
    print STDERR "In sequence $naSourceId, gene $gfSourceId and $preSourceId are duplicated at position $nlStartMin \.\. $nlEndMax\n" if ($preStart == $nlStartMin && $preEnd == $nlEndMax);
    $preSourceId = $gfSourceId;
    $preStart = $nlStartMin;
    $preEnd = $nlEndMax;
  }
  $stmtt->finish();
}
$stmt->finish();

## MM. check if the length of the gene is shorter than the sum of the exons' length, Bug #14407 
my (%gSourceIds, %gLengths);
my $sql = "select gf.na_feature_id, gf.source_id, nl.start_min, nl.end_max, nl.is_reversed 
from dots.genefeature gf, dots.nalocation nl
where nl.na_feature_id=gf.na_feature_id and gf.external_database_release_id=$extDbRlsId";
my $stmt = $dbh->prepare($sql);
$stmt->execute();
while (my ($gNaFeatureId, $gSourceId, $gStart, $gEnd, $ifReversed) = $stmt->fetchrow_array() ) {
    $gSourceIds{$gNaFeatureId} = $gSourceId;
    $gLengths{$gNaFeatureId} = abs($gStart-$gEnd) + 1;
}
$stmt->finish();

foreach my $kk (sort keys %gSourceIds) {
 
my $sql = "select start_min, end_max, is_reversed from dots.nalocation where na_feature_id in (
select na_feature_id from dots.exonfeature where parent_id=?)"; 

    my $stmt = $dbh->prepare($sql);
    $stmt->execute($kk);
    my $exonLength = 0;
    while (my ($eStart, $eEnd, $eIfRev) = $stmt->fetchrow_array() ) {
        $exonLength += abs($eStart-$eEnd)+1;
    }
    $stmt->finish();
    print STDERR "ERROR... the gene $gSourceIds{$kk} found with the gene length $gLengths{$kk} < sum of exons length $exonLength, need to contact the data provider to make sure the gene coordinates are correct\n" if ($gLengths{$kk} < $exonLength);
    #print ".";
}

## P. check the dots.Miscellaneous table for example centromere
my $sql = <<SQL;
  select distinct name, count(*) from dots.Miscellaneous where external_database_release_id=$extDbRlsId group by name
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
while (my ($name, $count) = $stmt->fetchrow_array()) {
  print STDERR "$name = $count\n" if ($name && $count);
}
$stmt->finish();

## Q. check the table dots.ScaffoldGapFeature for gap
my $sql = <<SQL;
  select count(*) from dots.ScaffoldGapFeature where external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
my ($gapCount) = $stmt->fetchrow_array();
print STDERR "the number of gap = $gapCount\n" if ($gapCount);
$stmt->finish();

## R. check the table dots.source
my $sql = <<SQL;
  select count(*) from DOTS.source where external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
my ($sourceCount) = $stmt->fetchrow_array();
print STDERR "the number of source = $sourceCount\n" if ($sourceCount);
$stmt->finish();

## S. check the table dots.Repeats
my $sql = <<SQL;
  select count(*) from dots.Repeats where external_database_release_id=$extDbRlsId
SQL
my $stmt = $dbh->prepare($sql);
$stmt->execute();
my ($repeatsCount) = $stmt->fetchrow_array();
print STDERR "the number of repeats = $repeatsCount\n" if ($repeatsCount);
$stmt->finish();


sub usage {
  die
"
A script to do QA for ISF post loading, this should be done right after ISF testing
Usage: postLoadIsfQA --organismAbbrev pvivSal1 --extDbName pvivSaI1_primary_genome_RSRC --extDbRlsVer 2013-05-01

NOTE: the GUS_HOME should point to the instance that the annotation has been loaded

where
  --organismAbbrev: the organism Abbrev in the table apidb.organism
  --extDbName: the external database name for loading genome and annoation
  --extDbRlsVer: the external database release version for loading genome and annotation

";
}

q{
##### the list to check #########

DONE -- 1. select * from dots.genefeature where external_database_release_id=374 and source_id IS NULL;
DONE -- 2. select source_id, count(source_id) from dots.genefeature where external_database_release_id=374 group by source_id having (count(source_id)>1);
DONE -- 3. select distinct name, count(*) from dots.genefeature where external_database_release_id=358 group by name;
DONE -- 4. select count(*) from DOTS.genefeature where external_database_release_id=358;
DONE -- 5. select distinct is_pseudo, count(*) from dots.genefeature where external_database_release_id=358 and name like 'coding_gene' group by is_pseudo;
DONE -- 6. select distinct is_partial, count(*) from dots.genefeature where external_database_release_id=358 and name like 'coding_gene' group by is_partial;

DONE -- 7. select * from dots.externalnasequence where external_database_release_id=358;
DONE -- 8. select sum(length) from dots.externalnasequence where external_database_release_id=358;

DONE -- 9. select * from dots.translatedaasequence where external_database_release_id=358;
DONE -- 10. select count(*) from dots.translatedaafeature where external_database_release_id=358;
DONE -- 12. select * from dots.translatedaafeature where external_database_release_id=358 and translation_stop is null;
DONE -- 13. select * from dots.translatedaafeature where external_database_release_id=358 and translation_start < 0;

DONE -- 14. select gf.name, gf.na_feature_id, gf.source_id, ef.coding_start, ef.coding_end from dots.exonfeature ef, dots.genefeature gf 
where ef.parent_id=gf.na_feature_id and gf.name not like 'coding_gene' and ef.coding_end is not null and gf.name not like 'pseudo_gene';

DONE in 1 -- 15. select * from dots.translatedaafeature where external_database_release_id=358 and source_id is null;
DONE in 1 -- 16. select * from dots.translatedaasequence where external_database_release_id=358 and source_id is null;

DONE -- 17. select ens.na_sequence_id, nl.na_feature_id, ens.source_id, ens.length, nl.end_max 
from dots.externalnasequence ens, dots.genefeature gf, dots.nalocation nl 
where gf.na_feature_id=nl.na_feature_id and gf.na_sequence_id=ens.na_sequence_id 
and nl.end_max > ens.length and ens.external_database_release_id=358;

DONE in 1 -- 18. select * from dots.exonfeature where external_database_release_id=358 and source_id IS NULL;
DONE in 2 -- 19. select source_id, count(source_id) from dots.exonfeature where external_database_release_id=348 group by source_id having (count(source_id)>1);

DONE -- 20. select t.source_id, nl.start_min, nl.end_max, count(*) from dots.transcript t, dots.rnafeatureexon rfe, DOTS.nalocation nl
where t.na_feature_id=rfe.rna_feature_id
and nl.na_feature_id=rfe.exon_feature_id
group by t.source_id, nl.start_min, nl.end_max having count(*)>1;

## to check if there is duplicated exons, it happens in TriTrypDB
DONE -- 21. select gf.source_id, ef.coding_start, ef.coding_end, ef.name, ef.source_id, nl.start_min, nl.end_max 
from dots.genefeature gf, DOTS.exonfeature ef, DOTS.nalocation nl
where gf.na_feature_id=ef.parent_id and ef.na_feature_id=nl.na_feature_id
and gf.source_id like 'PYYM_0902200%' and gf.external_database_release_id=358;

DONE -- 22. select count(*) from dots.Repeats where external_database_release_id=358;
DONOTNEED -- 23. select distinct na_sequence_id, count(na_sequence_id) from dots.Repeats where external_database_release_id=358 group by na_sequence_id;

DONE -- 24. select count(*) from dots.ScaffoldGapFeature where external_database_release_id=358;

DONE -- 25. select count(*) from DOTS.source where external_database_release_id=358;

DONE -- 26. select * from dots.Miscellaneous where external_database_release_id=358;

TODO -- 27. check if the UTRs is inside the CDS or there is any overlapping exons for Bug #13296

## to check if there is overlap exons
DONE -- 28. select gf.source_id, ef.source_id, nl.start_min, nl.end_max
from DOTS.genefeature gf, DOTS.exonfeature ef, DOTS.nalocation nl 
where gf.na_feature_id=ef.parent_id and nl.na_feature_id=ef.na_feature_id
and gf.external_database_release_id=$extDbRlsId and gf.source_id like '$sourceId'

};


