#!/usr/bin/perl

use lib "$ENV{GUS_HOME}/lib/perl";
use strict;
use Getopt::Long;
use Bio::SeqIO;
use File::Basename;
use FileHandle;
use Data::Dumper;
use HTTP::Date;
use DBI;

my ($date, ) = split(" ", HTTP::Date::time2iso());

$date = join("",split(/-/,$date)); 


my ($verbose, $help, $inFileDir, $outFile, $taxonId, $evidenceCode, $annotBasis, $db, $format,$seqFileExtension, $dbInstance, $username, $passwd, $extDb, $dbh, $dsn);

&GetOptions('verbose' => \$verbose,
            'help|h' => \$help,
            'fileOrDir=s' => \$inFileDir,
            'fileExt=s'  => \$seqFileExtension,
            'output_file=s' => \$outFile,
	    'db=s' => \$db,
	    'taxon_id=i' => \$taxonId,
            'evidence_code=s' => \$evidenceCode,
	    'annotation_basis=s' => \$annotBasis,
             'format=s'         => \$format,
	    'dbInstance=s'      => \$dbInstance,
	    'username=s'        =>  \$username,
	    'passwd=s'          =>  \$passwd,
	    'ext_db=s'         =>   \$extDb
            
           );


&usage() if($help);
&usage("Missing Argument") unless(defined $inFileDir && $outFile && $taxonId && $db && $format);

################################################################

if($dbInstance){
    $dsn = "dbi:Oracle:$dbInstance";
    $dbh = DBI->connect($dsn, $username, $passwd) or die DBI->errstr;
    $dbh->{RaiseError} = 1;
    $dbh->{AutoCommit} = 0;
}

################################################################

if(!($evidenceCode)){
  $evidenceCode = "IEA";
}

my $goAssocFh = FileHandle->new();
$goAssocFh->open(">$outFile");

my @inputFiles = &getInputFiles($inFileDir,$seqFileExtension);

foreach my $inFile (@inputFiles){

my $in  = Bio::SeqIO->new(-file => $inFile , '-format' => $format) or die("Could not open $inFile for reading\n");;



while ( my $seq = $in->next_seq() ) {
  if(!($seq->molecule =~ /rna/i)){
	foreach my $feature ($seq->get_SeqFeatures){
	  if($feature->primary_tag eq "CDS"){
	    my $sourceId = '';
	    my $product = '';
	    my $goId;
	    if ($feature->has_tag('locus_tag')){
	      foreach my $value ($feature->get_tag_values('locus_tag')){
		$sourceId = $value;
	      }
	    }
	    if ($feature->has_tag('systematic_id')){
	      foreach my $value ($feature->get_tag_values('systematic_id')){
		$sourceId = $value;
	      }
	    }
	    if ($feature->has_tag('temporary_systematic_id')){
	      foreach my $value ($feature->get_tag_values('temporary_systematic_id')){
		$sourceId = $value;
	      }
	    }

	    if($feature->has_tag('product')){
		($product) = $feature->get_tag_values('product');
		$product = &trim($product);
	    }

	    foreach my $qualifier ($feature->get_all_tags){
		
		
		if ($qualifier eq 'GO'){
		    
		    foreach my $fields ($feature->get_tag_values($qualifier)){
		    
			my @fields = split(/;/,$fields);

			my($levidenceCode,$aspect,$ldate,$ldbxref,$with);
			
			foreach my $field (@fields){
			    my($column,$value) = split(/=/,$field);
			    $column = &trim($column);
			    if(lc($column) eq 'aspect'){
				if(lc($value) eq 'component'){
				    $aspect = 'C';
				}elsif(lc($value) eq 'process'){
				    $aspect = 'P';
				}elsif(lc($value) eq 'function'){
				    $aspect = 'F';
				}else{
				    $aspect = '';
				}
			    }
			    if(lc($column) eq 'evidence'){
				$levidenceCode = uc(&trim($value));
			    }
			    if(lc($column) eq 'goid'){
				$goId = &trim($value);
			    }
			    if(lc($column) eq 'date'){
				$ldate = &trim($value);
			    }
			
			    if(lc($column) eq 'db_xref'){

				$ldbxref = &trim($value);
			    }
			
			    if(lc($column) eq 'with'){
				$with = &trim($value);
			    }
		    
			}
			if(!($levidenceCode)){
			    $levidenceCode = $evidenceCode;
			}
			if(!($ldate)){
			    $ldate = $date;
			}
			if($with){
			    if($ldbxref){
				$ldbxref .= "|$with";
			    }else{
				$ldbxref = $with;
			    }
			}
				

			$goAssocFh->print("$db\t$sourceId\t$sourceId\t\t$goId\t$ldbxref\t$levidenceCode\t$annotBasis\t$aspect\t$product\t$sourceId\tgene\ttaxon:$taxonId\t$ldate\t$annotBasis\n");

		      
		    }
		    
		}
		if ($qualifier eq 'GO_process'){
		    foreach my $value ($feature->get_tag_values($qualifier)){
			$value =~ /^(.+)\[\D+(\d+)\]/;

			$goId = "GO:".$2;
			$goAssocFh->print("$db\t$sourceId\t$sourceId\t\t$goId\t\t$evidenceCode\t$annotBasis\tP\t$product\t$sourceId\tgene\ttaxon:$taxonId\t$date\t$annotBasis\n");
		    }
		}
		if ($qualifier eq 'GO_function'){
		foreach my $value ($feature->get_tag_values($qualifier)){
		  $value =~ /^(.+)\[\D+(\d+)\]/;

		  $goId = "GO:".$2;
		  $goAssocFh->print("$db\t$sourceId\t$sourceId\t\t$goId\t\t$evidenceCode\t$annotBasis\tF\t$product\t$sourceId\tgene\ttaxon:$taxonId\t$date\t$annotBasis\n");
		}
	      }

	      if ($qualifier eq 'GO_component'){
		foreach my $value ($feature->get_tag_values($qualifier)){
		  $value =~ /^(.+)\[\D+(\d+)\]/;

		  $goId = "GO:".$2;
		  $goAssocFh->print("$db\t$sourceId\t$sourceId\t\t$goId\t\t$evidenceCode\t$annotBasis\tC\t$product\t$sourceId\tgene\ttaxon:$taxonId\t$date\t$annotBasis\n");
		}
	      }
	    }
	    if(!($goId)){
		if($feature->has_tag('note')){
		    foreach my $value($feature->get_tag_values('note')){
			if($value =~ /GO/){
			    my @notes = split(/;/,$value);
			    foreach my $note (@notes){
				$note = &trim($note);
				
				if($note =~ /^GO/){
				    my($goType,@values) = split(/:/,$note);
				    my $value = join(":",@values);
				    $value = &trim($value);
				    my $aspect = 'C';
				    
				    if($goType eq 'GO_component'){
					$aspect = 'C';
				    }elsif($goType eq 'GO_function'){
					$aspect = 'F';
				    }elsif($goType eq 'GO_process'){
					$aspect = 'P';
				    }

				    $value =~ s/\'/\'\'/g;
				    if($value ne 'cellular component unknown' && $value ne 'molecular function unknown' && $value ne 'biological process unknown'){

					$goId = &getGoId($value,$dbh,$extDb);
					if(!($goId)){
					    print STDERR "$sourceId:$value:$aspect\n";
					}else{
					    $goAssocFh->print("$db\t$sourceId\t$sourceId\t\t$goId\t\t$evidenceCode\t$annotBasis\t$aspect\t$product\t$sourceId\tgene\ttaxon:$taxonId\t$date\t$annotBasis\n");
					}
				    }
				}
			    }
			}
		    }
		}
	    }
	}
      }
    }
}
}

$goAssocFh->close();

if($dbInstance){
    $dbh->disconnect();
}

#-------------------------------------------------------------------------------

sub trim($){
	my $string = shift;
	$string =~ s/^\s+//;
	$string =~ s/\s+$//;
	return $string;
}


#-------------------------------------------------------------------------------

sub usage {
  my ($m) = @_;

  print STDERR "$m\n" if($m);
  my $usage = "usage:  perl makeGoAssocFile \\
--format      <format of the annotation file (genbank, embl)>
--fileOrDir <file or directory to be parsed> \\
[--fileExt  <extension of file in directory>] \\
--output_file <output go associations file> \\
--db <Database name> \\
--taxon_id <Taxon ID> \\
[--evidence_code <evidence code for the GO associations, if same for all. default (IEA)] \\
[--annotation_basis <basis for annotation>] \\
[--dbInstance <database instance to get GO IDs>] \\
[--username   <username for database instance>] \\
[--passwd <password for database instance>] \\
[--ext_db <extDbName|extDbVer for Gene Ontology>] \\
[--verbose <boolean-a little extra STDERR out>] \\
--help|h
";
  print STDERR $usage;
  exit(0);
}

#-------------------------------------------------------------------------------

sub getInputFiles {
  my ($fileOrDir,$seqFileExtension) = @_;


  my @inputFiles;
  if (-d $fileOrDir) {
    opendir(DIR, $fileOrDir) || die "Can't open directory '$fileOrDir'";
    my @noDotFiles = grep { $_ ne '.' && $_ ne '..' } readdir(DIR);
    @inputFiles = map { "$fileOrDir/$_" } @noDotFiles;
    @inputFiles = grep(/.*\.$seqFileExtension$/, @inputFiles) if $seqFileExtension;
  } else {
    $inputFiles[0] = $fileOrDir;
  }
  return @inputFiles;
}

#-------------------------------------------------------------------------------

sub getGoId {
    my($goName, $dbh, $extDb) = @_;

    my %translateName = { 'N-linked glycosylation' => 'protein amino acid N-linked glycosylation',
			  'katanin' => 'katanin complex',
			  'acetyl-CoA biosynthesis from pyruvate' => 'acetyl-CoA biosynthetic process from pyruvate',
			  'aldehyde dehydrogenase activity' => 'aldehyde dehydrogenase (NAD) activity',
			  'alpha DNA polymerase' => 'alpha DNA polymerase:primase complex',
			  'cation transporter activity' => 'cation transmembrane transporter activity',
			  'copper ion transporter activity' => 'copper ion transmembrane transporter activity',
			  'double-strand break repair via nonhomologous end-joining' => 'double-strand break repair via nonhomologous end joining',
			  'eukaryotic elongation factor-2 kinase activity' => 'eukaryotic elongation factor 2 kinase activity',
			  'glucose transporter activity' =>  'glucose transmembrane transporter activity ',
			  'glycine betaine biosynthetis from choline' => 'glycine betaine biosynthetic process from choline',
			  'hexose transporter activity' => 'hexose transmembrane transporter activity',
			  'hydrogen-transporting ATP synthase activity, rotational mechanism' => 'hydrogen ion transporting ATP synthase activity, rotational mechanism',
			  'hydrogen-transporting ATPase activity, rotational mechanism' => 'hydrogen ion transporting ATPase activity, rotational mechanism',
			  

		      };
    
    my($edName,$edVersion) = split(/\|/,$extDb);
    my $sql = "SELECT go.go_id FROM sres.goterm go,sres.externaldatabase ed, sres.externaldatabaserelease edr where go.name = '$goName' and ed.external_database_id = edr.external_database_id and ed.name = '$edName' and edr.version = '$edVersion' and edr.external_database_release_id = go.external_database_release_id
UNION
SELECT go.go_id FROM sres.goterm go, sres.gosynonym gs, sres.externaldatabase ed, sres.externaldatabaserelease edr where gs.text = '$goName' and gs.go_term_id = go.go_term_id and ed.external_database_id = edr.external_database_id and ed.name = '$edName' and edr.version = '$edVersion' and edr.external_database_release_id = go.external_database_release_id";
    my $sth = $dbh->prepare($sql);
    $sth->execute() or die("Could not execute $sql\n");
    
    my ($goId) = $sth->fetchrow_array();

    return $goId;
    
    
}

1;
