#!/usr/bin/perl

# extractSnpQueryFiles -- extract HTS SNPs to flat files for high-speed SNP queries
#
# write strain files, grouped by organism into subdirectories of the current pwd

use strict;
use DBI;
use Getopt::Long;

use lib "$ENV{GUS_HOME}/lib/perl";
use CBIL::Util::PropertySet;

my %ALLELE_HASH = ('a'=>1, 'c'=>2, 'g'=>3, 't'=>4,
                   'A'=>1, 'C'=>2, 'G'=>3, 'T'=>4);

use Getopt::Long;
my ($gusConfigFile, $frequencyCutoffs);
&GetOptions("gusConfigFile=s" => \$gusConfigFile,
            "frequencyCutoffs=s" => \$frequencyCutoffs,
            );
$gusConfigFile = $ENV{GUS_HOME} . "/config/gus.config" unless($gusConfigFile);

unless (-e $gusConfigFile) {
  print STDERR "gus.config file not found! \n";
  &usage;
}

unless (defined($frequencyCutoffs)) {
  print STDERR "ERROR: no read-frequency cutoffs supplied\n";
  &usage;
}

my @properties = ();
my $gusconfig = CBIL::Util::PropertySet->new($gusConfigFile, \@properties, 1);

my $dbh = DBI->connect($gusconfig->{props}->{dbiDsn},
		       $gusconfig->{props}->{databaseLogin},
		       $gusconfig->{props}->{databasePassword})
  ||  die "Couldn't connect to database: " . DBI->errstr;
  $dbh->{RaiseError} = 1;

logMessage("starting SNP file unload");
makeVariantTable($dbh);
unloadSnpData($dbh, $frequencyCutoffs);
# dropVariantTable($dbh);

logMessage("SNP file unload finished");

sub makeVariantTable {
  my ($dbh) = @_;

  # this part is for leaving the big table around, for testing queries.
  # (It's only needed when the call above to dropVariantTable() is commented out
  $dbh->{PrintError} = 0;
  $dbh->{RaiseError} = 0;
  logMessage ("dropping old table (if any)");
  $dbh->do(<<SQL);
    drop table oldCHV
SQL

  logMessage ("renaming old table (if any)");
  $dbh->do(<<SQL);
    alter table CustomHtsVariant rename to oldCHV
SQL
  $dbh->{PrintError} = 1;
  $dbh->{RaiseError} = 1;

  logMessage ("creating CustomHtvVariant");
  $dbh->do(<<SQL) or die "creating CustomHtsVariant";

    create table CustomHtsVariant nologging as
    select min(seq.taxon_id) as species_taxon_id,
           substr(var.strain, 1, 30) as strain,
           substr(min(snp.source_id), 1, 40) as snp_source_id,
           substr(var.allele, 1, 1) as allele,
           substr(max(var.product), 1, 3) as product,
           max(nvl(var.matches_reference, 0)) as matches_reference,
           max(nvl(var.allele_percent, 100)) as max_cutoff,
           max(nvl(var.allele_percent, 100)) as allele_percent,
           cast (0 as number(1)) as cutoff_corrected
    from dots.SeqVariation var, dots.Snpfeature snp, dots.NaSequence seq,
         sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
    where var.parent_id = snp.na_feature_id
      and snp.na_sequence_id = seq.na_sequence_id
      and snp.external_database_release_id = edr.external_database_release_id
      and edr.external_database_id = ed.external_database_id
      and ed.name = 'InsertSnps.pm NGS SNPs INTERNAL'  -- snp.type = 'HTS'
      and var.name = 'SNP'
      and var.allele != 'undefined'
    group by snp.na_feature_id, var.allele, var.strain

SQL

  logMessage("creating index 1");
  $dbh->do(<<SQL) or die "creating index";
    -- for update statement immediately following
    create index chv_polymorph$$ on CustomHtsVariant (snp_source_id, max_cutoff desc, allele)
SQL

  # logMessage("updating max_cutoff");
  $dbh->do(<<SQL) if undef; # don't  # or die "creating stored procedure";
create or replace procedure updateMaxCutoff
is
  max_differer number;
  changeCount number;

  cursor c1 is
      select snp_source_id, allele, max_cutoff
      from CustomHtsVariant
      for update of max_cutoff;

begin
    for variant in c1
    loop
       select max(max_cutoff)
       into max_differer
       from CustomHtsVariant
       where snp_source_id = variant.snp_source_id
         and allele != variant.allele;

      if max_differer is null
      then
        delete from CustomHtsVariant where current of c1;
        changeCount := changeCount + 1;
      else
        if max_differer < variant.max_cutoff
        then
          update CustomHtsVariant
          set max_cutoff = max_differer
          where current of c1;
          changeCount := changeCount + 1;
        end if;
      end if;

      if mod(changeCount, 1000) = 0 then
          commit;
      end if;

    end loop;
    commit;

end;
/
SQL

  logMessage("updating max_cutoff");
  $dbh->do(" begin updateMaxCutoff; end; ") or die "updating CustomHtsVariant";

  logMessage("creating index 2");
  $dbh->do(<<SQL) or die "creating index 2";
    -- for reference-genome query
    create index chv_ref$$ on CustomHtsVariant (species_taxon_id, matches_reference, max_cutoff, allele, product)
SQL

  logMessage("creating index 3");
  $dbh->do(<<SQL) or die "creating index 3";
    -- for strain query and SNP-row query
    create index chv_rows$$ on CustomHtsVariant (species_taxon_id, strain, matches_reference, max_cutoff, snp_source_id, allele, product)
SQL

  logMessage("finished creating table");
}

sub dropVariantTable {
  my ($dbh) = @_;

  logMessage ("dropping CustomHtvVariant");
  $dbh->do(<<SQL) or die "dropping CustomHtsVariant";
    drop table CustomHtsVariant
SQL
}

sub unloadSnpData {
  my ($dbh, $frequencyCutoffs) = @_;

  foreach my $cutoff (split /,/, $frequencyCutoffs) {
    logMessage("unloading SNPs at frequency cutoff $cutoff");
    my $organismQ = $dbh->prepare(<<SQL) || die "preparing organism query: " . DBI->errstr;
      select name, taxon_id
      from sres.TaxonName 
      where name_class = 'scientific name'
        and taxon_id in (select species_taxon_id from CustomHtsVariant where max_cutoff >= $cutoff)
      order by name
SQL

    $organismQ->execute()
      || die "executing organism query: " . DBI->errstr;
    while (my ($organism, $taxon_id) = $organismQ->fetchrow_array()) {
      logMessage("unloading organism \"$organism\"");
      unloadOrganism($dbh, $organism, $taxon_id, $cutoff);
    }
  }
}

sub unloadOrganism {
  my ($dbh, $organism, $taxonId, $cutoff) = @_;

  my %contigId;
  my $contigNum = 0;
  my $strainNum = 1; # can't have a strain 0. That means something special.

  my $dataDir = $organism;
  $dataDir =~ s/\s//g;
  $dataDir .= "/readFreq$cutoff";
  `mkdir -p $dataDir`;
  open (my $contigIdFile, ">", "$dataDir/contigIdToSourceId.dat") or die "opening contigIdToSourceId.dat";

  # write referenceGenome.dat
  my $referenceFile = $dataDir . '/referenceGenome.dat';
  open(my $ref, '>:raw', $referenceFile) || die "can't open reference file \"$referenceFile\": $!\n";
  my $referenceQ = $dbh->prepare(<<SQL) || die "preparing reference query: " . DBI->errstr;

      select *
      from (select snp_source_id, allele, product,
                   regexp_replace(snp_source_id, '^NGS_SNP\\.(.*)\\.[0-9]*\$', '\\1') as contig,
                   to_number(regexp_replace(snp_source_id, '^.*\\.([0-9]*)\$', '\\1')) as location
            from (select distinct snp_source_id, allele, product
                  from CustomHtsVariant
                  where species_taxon_id = '$taxonId'
                    and max_cutoff >= $cutoff
                    and matches_reference = 1
                  )
           )
      order by contig, location

SQL

  $referenceQ->execute()
    || die "executing reference query: " . DBI->errstr;
  my $testRunCounter;
  while (my ($snpId, $allele, $product, $contig, $location) = $referenceQ->fetchrow_array()) {

    if (!defined($contigId{$contig})) {
      $contigId{$contig} = $contigNum;
      print $contigIdFile "$contigNum\t$contig\n";
      $contigNum++;
    }

    writeStrainRow($ref, $contigId{$contig}, $location, $allele, $product);
  }
  close($ref);

  close($contigIdFile);

  # unload per-strain SNP data
  open (my $strainIdFile, ">", "$dataDir/strainIdToName.dat") or die "opening strainIdToName.dat";
  my $strainQ = $dbh->prepare(<<SQL) || die "preparing organism query: " . DBI->errstr;
    select distinct strain
    from CustomHtsVariant
    where species_taxon_id = '$taxonId'
      and max_cutoff >= $cutoff
    order by strain
SQL

  $strainQ->execute()
    || die "executing strain query: " . DBI->errstr;
  my $strainCount;
  while (my ($strain) = $strainQ->fetchrow_array()) {
    logMessage("unloading strain \"$strain\"");

    print $strainIdFile "$strainNum\t$strain\n";

    my $strainFile = $dataDir . '/' . $strainNum;
    open(my $fh, '>:raw', $strainFile) || die "can't open strain file \"$strainFile\": $!\n";

    my $snpQ = $dbh->prepare(<<SQL) || die "preparing SNP query: " . DBI->errstr;

      select *
      from (select snp_source_id, allele, product,
                   regexp_replace(snp_source_id, '^NGS_SNP\\.(.*)\\.[0-9]*\$', '\\1') as contig,
                   to_number(regexp_replace(snp_source_id, '^.*\\.([0-9]*)\$', '\\1')) as location
            from (
                  -- there is a variation, and !matches_reference
                  select snp_source_id, allele, product
                  from CustomHtsVariant
                  where strain = '$strain'
                    and species_taxon_id = '$taxonId'
                    and matches_reference != 1
                    and max_cutoff >= $cutoff
                 union all
                  -- no data for this location
                  select snp_source_id, null as allele, null as product
                  from (  select distinct snp_source_id
                          from CustomHtsVariant
                          where species_taxon_id = '$taxonId'
                            and max_cutoff >= $cutoff
                        minus
                          select snp_source_id
                          from CustomHtsVariant
                          where species_taxon_id = '$taxonId'
                            and strain = '$strain'
                            and max_cutoff >= $cutoff)
                 )
              )
      order by contig, location

SQL

    $snpQ->execute()
      || die "executing SNP query: " . DBI->errstr;
    my $testRunCounter;
    while (my ($snpId, $allele, $product, $contig, $location) = $snpQ->fetchrow_array()) {
      if (!defined($contigId{$contig})) {
	die "ERROR: contig \"$contig\" found in strain \"$strain\", but not in reference genome. SNP ID = \"$snpId\" ";
      }

      writeStrainRow($fh, $contigId{$contig}, $location, $allele, $product);
    }
    close($fh);

    $strainNum++;
  }
  close($strainIdFile);

}

sub writeStrainRow {
  my ($fh, $contigId, $location, $allele, $product) = @_;

  my $alleleCode = 0;
  $alleleCode = $ALLELE_HASH{$allele} if $allele;

  my $prodCode = ord($product);

  print $fh pack("slcc", $contigId, $location, $alleleCode, $prodCode);
}

sub logMessage {
  my ($message) = @_;
  $| = 1;

  my $dateString = `date '+%Y/%m/%d %H:%M:%S'`;
  chomp ($dateString);
  print "$dateString| $message\n";
}

sub usage {

print <<USAGE;

  extractSnpQueryFiles: extract HTS SNPs to flat files for high-speed SNP queries

  extractSnpQueryFiles -frequencyCutoffs <cutoffs> [ -gusConfigFile <filename> ]

  example:
   extractSnpQueryFiles -frequencyCutoffs '60,80,90'

USAGE

  die;
}
