#!@perl@
use strict;

use lib "$ENV{GUS_HOME}/lib/perl";
use GUS::Pipeline::Manager;
use GUS::Pipeline::MakeTaskDirs;
use GUS::Pipeline::NfsCluster;
use GUS::Pipeline::SshCluster;
use CBIL::Util::PropertySet;
use CBIL::Util::GenomeDir;
use File::Basename;

# the "Steps" module contains all the pipeline-step routines
# that are called below.

use ApiComplexa::DataLoad::Steps;

$| = 1;
umask 002;


my $propertiesFile = $ARGV[0];

&usage unless -e $propertiesFile;

# [name, default (or null if reqd), comment]
my @properties = 
(
 # properties required by Pipeline API  - incomplete, waiting for steps
 ["blastmatrix.taskSize", "",  "number of seqs to process per blastmatrix subtask"],
 ["blastsimilarity.params", "", "paramters for blastsimilarity"],
 ["blastsimilarity.taskSize", "",  "number of seqs to process per blastsimilarity subtask"],
 ["buildDir",   "",  "root of the build's directory tree"],
 ["cap4Dir", "", "directory containing executable cap4"],
 ["clusterServer", "",  "full name of cluster server"],
 ["contig_db_rls_id", "", "external_database_release_id for current contig release"],
 ["externalDbDir", "", "directory for downloading data from external databases"],
 ["fileOfRepeats", "", "repeat file for use by repeatmasker"],
 ["gb_db_rel_id", "", "genbank external_database_release_id"],
 ["gusConfigFile",           "",  ""],
 ["intermedCluster.length",  "",  "min length cut-off for clustering algorithm"],
 ["intermedCluster.percent",  "",  "min percent identity cutoff for clustering algorithm"],
 ["intermedCluster.logbase",  "",  ""],
 ["intermedCluster.consistentEnds",  "",  "requirement for consistent ends, yes or no"],
 ["intermedCluster.cliqueSzArray",  "",  ""],
 ["intermedCluster.logbaseArray",  "",  ""],
 ["gusConfigFile",  "",  "gus configuration file"],
 ["loadcontigs-nrdbRestart",  "",  "algorithm_invocation_id(s) of previous starts, for restart of BLAST similarity loading plugin"],
 ["nrdb_db_rls_id" , "","the external_database_release_id for nrdb"],
 ["nodePath",             "",  "full path of scratch dir on cluster node"],
 ["phrapDir",             "",  "full path of directory containing phrap software"],
 ["projectId",             "",  "project_id from core.projectInfo"],
 ["release",   "",  "build release number"],
 ["repeatmask.dangleMax", "","option for trimDangling in repeatMasker"],
 ["repeatmask.options",   "",  "number of seqs to process per blastmatrix subtask"],
 ["repeatmask.path",      "",  "path on node of repeatmask executable"],
 ["repeatmask.taskSize",  "",  "number of seqs to process per repeatmask subtask"],
 ["serverPath", "",  "full path of update dir on cluster server"],
 ["speciesNickname", "",  "eg Pvivax,mus,or hum"],
 ["speciesFullname", "", "eg Mus musculus"],
 ["stopBefore",   "none",  "the step to stop before.  uses the signal name"],
 ["taskSize",  "",  "number of seqs to process per subtask"],
 ["taxonId", "", "taxon_id from GUS sres.taxon table"],
 ["testNextPlugin", "false", "'true' to run in no-commit mode the first plugin not yet done and then exit"],
 ["wuBlastBinPathCluster",         "",  "path of wu blast bin dir on Liniac"],

 ); 

my $propertySet  = CBIL::Util::PropertySet->new($propertiesFile, \@properties, 1);

my $buildDir = $propertySet->getProp('buildDir');
my $buildName = &makeBuildName($propertySet->getProp('speciesNickname'),$propertySet->getProp('release'));
my $pipelineDir = "$buildDir/$buildName";

##########################  The Pipeline  ##########################

my $cluster;
if ($propertySet->getProp('clusterServer') ne "none") {
  $cluster = GUS::Pipeline::SshCluster->new($propertySet->getProp('clusterServer'),
					  $propertySet->getProp('clusterUser') );
} else {
  $cluster = GUS::Pipeline::NfsCluster->new();
}

my $mgr = GUS::Pipeline::Manager->new($pipelineDir, $propertySet, 
				      $propertiesFile, $cluster, 
				      $propertySet->getProp('testNextPlugin'));


$mgr->{buildName} = $buildName;
$mgr->{pipelineDir} = $pipelineDir;
$mgr->{propertiesFile} = $propertiesFile;
$mgr->{propertySet} = $propertySet;

&createPipelineDir($mgr); # signal createDir
&createGenomeDir($mgr);   # signal createGenomeDir
&copyPipelineDirToComputeCluster($mgr); # signal dir2cluster

&extractContigs($mgr);    # signal extractContigs
&copyFilesToComputeCluster($mgr,"contigs"); # signal contigsExtract

&extractNRDB($mgr);   # signal ${name}Extract
&copyFilesToComputeCluster($mgr,"nrdb");  # signal nrdbToCluster
&startProteinBlastOnComputeCluster($mgr,"nrdb");  # signal blastnrdb
&copyFilesFromComputeCluster($mgr,"contigs-nrdb","similarity"); # signal copycontigs-nrdbResultsFromCluster
&loadProteinBlast($mgr, "contigs-nrdb","DoTS::ExternalAASequence"); # signal loadSims_contigs-nrdb

&makeTranscriptSeqs($mgr);
&extractTranscriptSeqs($mgr,"newTranscripts");

&copyFilesToComputeCluster($mgr,"newTranscripts"); # signal newTranscriptsToCluster; initial assembly - assuming updates - using genomic alignments
&startTranscriptAlignToContigs($mgr,"newTranscripts"); # signal newTranscriptsAlignToContigs

&copyFilesFromComputeCluster($mgr,"newTranscripts","repeatmask"); # signal copynewTranscriptsResultsFromCluster
&copyFilesFromComputeCluster($mgr,"newTranscripts-contigs","genome"); # signal copynewTranscripts-contigsResultsFromCluster
&loadContigAlignments($mgr, "newTranscripts", "contigs");

&clusterByContigAlign($mgr, "initial");
&splitCluster("initial", $mgr);  # signal initialSplitCluster
&assemble("", $propertySet->getProp('reassemble'), "initial", $mgr); # signal reassembleAssemble
&reassemble("initial", $mgr); # signal initialReassemble
&deleteAssembliesWithNoTranscripts($mgr, "initial");

&extractAssemblies($mgr,"intermedTranscriptCons");          # signal intermedTranscriptConsExtract; final assembly 
&copyFilesToComputeCluster($mgr,"intermedTranscriptCons"); # signal intermedTranscriptConsToCluster
&extractTranscriptSeqs($mgr,"unalignededTranscripts");
&copyFilesToComputeCluster($mgr,"unalignedtranscripts"); # signal unalignedtranscriptsToCluster
&startTranscriptMatrixOnComputeCluster($mgr,"intermed");
&copyFilesFromComputeCluster($mgr,"intermedTranscriptCons"); # signal copy${name}ResultsFromCluster
&clusterByBlastSim($mgr,"intermed","intermed-intermed","unaligned-unaligned","intermed-unaligned");
&splitCluster($mgr,"intermed"); # signal intermedSplitCluster
&assemble("--assemble_old", "no", "intermed", $mgr);
&reassemble("intermed", $mgr); # signal intermedReassemble
&deleteAssembliesWithNoTranscripts($mgr, "intermed");

&extractAssemblies($mgr,"finalTranscriptCons"); # signal finalTranscriptConsExtract; extract final assemblies, map to contigs, load results into db
&copyFilesToComputeCluster($mgr,"finalTranscriptCons"); # signal finalTranscriptConsToCluster
&startTranscriptAlignToContigs($mgr,"finalTranscriptCons"); # signal finalTranscriptConsAlignToContigs
&copyFilesFromComputeCluster($mgr,"finalTranscriptCons-contigs", "alignments"); # signal copyfinalTranscriptCons-contigsResultsFromCluster
&loadContigAlignments($mgr, "final", "contigs"); 


=cut
&getTranslatedAASeqs($mgr, "SignalP", "60");
&copyFilesToComputeCluster($mgr,"SignalP","DIR"); # signal unalignedtranscriptsToCluster
&runAAFeaturePredictor($mgr, "SignalP","signalp -t euk","/usr/local/jk/signalp-3.0/")
&copyFilesFromComputeCluster($mgr,"SignalP","DIR"); # signal copy${name}ResultsFromCluster
&loadData($mgr, "SignalP")

&getTranslatedAASeqs($mgr, "TMHmm");
&copyFilesToComputeCluster($mgr,"TMHmm","DIR"); # signal unalignedtranscriptsToCluster
&runAAFeaturePredictor($mgr, "TMHmm")
&copyFilesFromComputeCluster($mgr,"TMHmm","DIR"); # signal copy${name}ResultsFromCluster
&loadData($mgr, "TMHmm")

=cut

$mgr->goodbye("Pipeline complete!\n");





