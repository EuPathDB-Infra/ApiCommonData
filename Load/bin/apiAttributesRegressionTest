#!/usr/bin/perl

use strict;
use lib "$ENV{GUS_HOME}/lib/perl";
use Getopt::Long;
use GUS::Supported::GusConfig;
use DBI;

my $outputDir = $ARGV[0];
my $dblinkName = $ARGV[1];

$| = 1;

usage() unless $dblinkName;

die "Error: output dir '$outputDir' not found\n" unless -d $outputDir;

my $gusconfig = GUS::Supported::GusConfig->new("$ENV{GUS_HOME}/config/gus.config");

my $login = $gusconfig->getDatabaseLogin();
my $password = $gusconfig->getDatabasePassword();
my $dsn = $gusconfig->getDbiDsn();

my $dbh = DBI->connect($dsn,
		       $login,
		       $password,
		       { PrintError => 1, RaiseError => 0}
		      )
  or die "Can't connect to the tracking database: $DBI::errstr\n";

my @tables = getAttributeTables();

for my $table (@tables) {
  print STDERR "processing table $table\n";
  my @organisms = getTableOrganisms($table);
  for my $org (@organisms) {
    print STDERR "  $org\n";
    my $org_dir_name = $org;
    $org_dir_name =~ s/ /_/g;
    if (! -d "$outputDir/$org_dir_name") {
      mkdir("$outputDir/$org_dir_name")
	|| die "Can't make output dir '$outputDir/$org_dir_name'\n";
    }
    my $outfile = "$outputDir/$org_dir_name/$table.out";
    open(OUT, ">$outfile")
      || die "Can't make open output file '$outfile'\n";

    runTest($table, $org, \*OUT);
  }
}

##################################################################

sub getAttributeTables {

  my $tableExceptions = {'ARRAYELEMENTATTRIBUTES' => 1};

  my $sql = 
"select synonym_name from all_synonyms
where table_owner = 'APIDB'
and synonym_name like '\%ATTRIBUTES'
";

  my @tables;
  my $stmt = $dbh->prepare($sql);
  $stmt->execute();
  while (my ($tableName) = $stmt->fetchrow_array()) {
    push(@tables, $tableName) unless $tableExceptions->{$tableName};
  }
  return @tables;
}

sub getTableOrganisms {
  my ($tableName) = @_;

  my $sql = 
"select distinct organism from apidb.$tableName
";

  my @organisms;
  my $stmt = $dbh->prepare($sql);
  $stmt->execute();
  while (my ($organism) = $stmt->fetchrow_array()) {
    push(@organisms, $organism);
  }
  return @organisms;
}

sub runTest {
  my ($tableName, $organism, $out) = @_;

  print $out "Checking counts\n";
  my $oldCount = getIdCount($tableName, '', $organism);
  my $newCount = getIdCount($tableName, $dblinkName, $organism);
  if ($oldCount == $newCount) {
    print $out "ID Counts OK ($oldCount)\n\n";
  } else {
    print $out "DIFFS: ID count. (old: $oldCount new: $newCount)\n\n";
  }
  my $idCount = compareSourceIds($oldCount, $newCount, $tableName, $organism, $out);

  return unless $idCount;

  my @attrCols = getAttrCols($tableName);
  foreach my $column (@attrCols) {
    my $sql = "
select old.source_id, old.$column as old$column, new.$column as new$column
from apidb.$tableName old, apidb.${tableName}\@$dblinkName new
where old.source_id = new.source_id
and old.$column != new.$column
and old.organism = '$organism'";

    my $stmt = $dbh->prepare($sql);
    $stmt->execute();
    print $out "Checking $column\n";
    my $diffCount = 0;
    while (my @row = $stmt->fetchrow_array()) {
      print $out "\t" . join("\t",@row) . "\n";
      $diffCount++;
    }
    print $out "DIFFS: Column $column has $diffCount differences\n\n" if $diffCount;
    print $out "Column $column OK\n\n" unless $diffCount;
  }
}

sub getIdCount {
  my ($tableName, $dblinkName, $organism) = @_;

  my $dbl = $dblinkName? "\@$dblinkName" : "";
  my $sql = "select count(*) from apidb.$tableName$dbl where organism = '$organism'";
  my $stmt = $dbh->prepare($sql);
  $stmt->execute();
  my ($idCnt) = $stmt->fetchrow_array();

  die "Invalid organism name '$organism' (no IDs found in apidb.$tableName$dbl)\n" unless $idCnt;
  return $idCnt;
}

sub compareSourceIds {
  my ($oldIdCount, $newIdCount, $tableName, $organism, $out) = @_;

  print $out "Checking for identical source ids\n";

  my $sql = 
"select count(*)
 from apidb.$tableName old, apidb.$tableName\@$dblinkName new
 where old.organism= '$organism'
 and new.source_id = old.source_id";
  my $stmt = $dbh->prepare($sql);
  $stmt->execute();
  my ($idCnt) = $stmt->fetchrow_array();

  my $minIds = $oldIdCount < $newIdCount? $oldIdCount : $newIdCount;

  if (!$idCnt) {
    print $out "DIFFS: No rows found with identical source_ids\n\n";
  } elsif ($idCnt == $minIds) {
    print $out "Source_id identity ($idCnt) OK\n\n";
  } else {
    print $out "DIFFS: non-identical source_ids: " . ($minIds - $idCnt) . "\n\n";
  }
  return $idCnt;
}

sub getAttrCols {
  my ($tableName) = @_;

  my $sql = 
"SELECT column_name FROM all_tab_cols tc, all_synonyms s
where s.synonym_name = '$tableName'
and tc.table_name = s.table_name
";

  my @columns;
  my $stmt = $dbh->prepare($sql);
  $stmt->execute();
  my $columnExceptions = getColumnExceptions($tableName);
  while (my ($columnName) = $stmt->fetchrow_array()) {
    push(@columns, $columnName) unless $columnExceptions->{$columnName};
  }
  return @columns;
}

sub getColumnExceptions {
  my ($tableName) = @_;

  my $columnExceptions =
    {
     'GENEATTRIBUTES'=> {
			 'PROJECT_ID' => 1,
			 'SOURCE_ID' => 1,
			 'NA_FEATURE_ID' => 1,
			 'SO_VERSION' => 1,
			 'EXTERNAL_DB_NAME' => 1,
			 'EXTERNAL_DB_VERSION' => 1,
			 'NA_SEQUENCE_ID' => 1,
			 'TAXON_ID' => 1,
			}
    };

  return $columnExceptions->{$tableName} if ($columnExceptions->{$tableName});
  return {};
}

sub detailCols {
  return (
	  'ExpressionGraphsData',
	  'GoTerms',
	  'Y2hInteractions',
	  'Product',
	  'Alias',
	  'Epitopes',
	  'UserComments',
	  'EcNumber',
	  'ArrayElements',
	  'PdbSimilarities',
	  'ProteinDatabase',
	  'GeneModelDump',
	  'LowComplexity',
	  'PlasmoVer5Genes',
	  'BlastP',
	  'GeneLinkouts',
	  'InterPro',
	  'SNPs',
	  'SageTags',
	  'TwoChannelDiffExpr',
	  'MassSpecDownload',
	  'SignalP',
	  'Notes',
	  'Aliases',
	  'GeneId',
	  'MassSpec',
	  'TMHMM',
	  'ProteinExpression'
	 );

}

sub usage {

  print STDERR "
Usage:  apiGeneRegressionTest dblinkName

Example:  apiGeneRegressionTest 'Plasmodium vivax' plasrbld

Compares the apidb.GeneAttributes table in an old and new database for the specified species.

The 'old' database is specified by connect info in \$GUS_HOME/config/gus.config.

The 'new' database is accessed from the old via the dblink whose name is provided in dblinkName.  This dblink must exist in the old database (ask a DBA).

";

  exit(1);
}
