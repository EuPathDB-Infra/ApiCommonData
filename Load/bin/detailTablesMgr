#! /usr/bin/perl
use lib "$ENV{GUS_HOME}/lib/perl";
use Getopt::Long;
use strict;

my ($config,$sqlDir,$downloadFileDir,$restartOrg);
&GetOptions("configFile=s"=> \$config,
            "sqlDir=s"=> \$sqlDir,
            "downloadFileDir=s"=> \$downloadFileDir,
	    "restartOrg=s"=> \$restartOrg);

$| = 1;



&usage unless (-s $config && -d $sqlDir && -d $downloadFileDir);

#config Ex:
#project=CryptoDB release=6.6 loadDetailTable=yes createFiles=yes
#org=Chominis|Cryptosporidium hominis
#type=Gene detailTable=apidb.GeneDetail fields=InterPro
#type=Sequence detailTable=apidb.SequenceDetail fields=all
#org=Cmuris|Cryptosporidium muris
#type=Gene detailTable=apidb.GeneDetail fields=InterPro
#type=Sequence detailTable=apidb.SequenceDetail fields=all
#org=Cparvum|Cryptosporidium parvum Iowa II
#type=Gene detailTable=apidb.GeneDetail fields=InterPro
#type=Sequence detailTable=apidb.SequenceDetail fields=all
#org=CparvumChr6|Cryptosporidium parvum
#type=Gene detailTable=apidb.GeneDetail fields=InterPro
#type=Sequence detailTable=apidb.SequenceDetail fields=all
#//


&parseConfig;

sub parseConfig {

  open (CONFIG,$config);

  my $project;

  my %config;

  my @confArr;

  my %orgHsh;

  my $organism;

  my $restartFlag = 0;

  while(<CONFIG>) {
    chomp;
    s/#.*//;
    next if ($_ =~ /^\s*$/);

    s/\s*=\s*/=/g;

    if ($_ =~ /project=(\S+)/){

      $project = $1;

      if ($_ =~ /release=(\S+)/){$config{$project}{'release'}=$1;}

      if ($_ =~ /loadDetailTable=(\S+)/){$config{$project}{'loadDetailTable'}=$1;}

      if ($_ =~ /createFiles=(\S+)/){$config{$project}{'createFile'}=$1;}

    }
    elsif ($_ =~ /org=(.*)/) {

      $_ =~ s/^\s*//g;

      $_ =~ s/\s*$//g;

      $organism = "";

      $organism = $1;

      if ($restartOrg && $organism !~ /$restartOrg/ && !$restartFlag) {

	$organism = "";
	next;
      }
      if ($restartOrg && $organism =~ /$restartOrg/) {

	$restartFlag = 1;
      }

      push (@{$config{$project}{'organisms'}}, $organism);

    }
    elsif (my $type =~ /type=(\S+)/) {

      if ($organism) {

	if($_ =~ /detailTable=(\S+)/){$orgHsh{$organism}{$type}{'table'} = $1;}

	if($_ =~ /fields=(\S+)/){$orgHsh{$organism}{$type}{'fields'} = $1;}

      }
      else {
	die "each organism line should be followed by type lines Ex:org=Cmuris|Cryptosporidium muris\ntype=Gene detailTable=apidb.GeneDetail fields=InterPro\ntype=Sequence detailTable=apidb.SequenceDetail fields=all\n";
      }
    }
    elsif ($_ =~ /\/\//){

      my %copy = %config;

      push (@confArr,%copy);

      %config = ();

      $organism = "";
    }
    else {
      die "There is an unacceptable line in the config file:\n $_\n";
    }
  }

  &validate(\@confArr, \%orgHsh);

  &processConfig(\@confArr, \%orgHsh);

}


sub validate {
  my ($confArr, $orgHsh ) = @_;

  my @errors;

  foreach my $projectHsh ( @{$confArr}) {
    foreach my $project (keys %$projectHsh) {
      push (@errors, "$project : project name") if ($project !~ /\w+DB/);
      push (@errors, "$project : release") if ($confArr->{$project}->{'release'} !~ /[\d\.]+/);
      push (@errors, "$project : loadDetailTable") if ($confArr->{$project}->{'loadDetailTable'} !~ /yes|no/);
      push (@errors, "$project : createFile") if ($confArr->{$project}->{'createfile'} !~ /yes|no/);

      foreach my $org ($confArr->{$project}->{'organisms'}) {
	push(@errors,"$project : orgs : $org") if ($org != /\w+\s*\|\s*[\w\s]+/);

	foreach my $type (keys %{$orgHsh->{$org}}) {
	  push (@errors,"$project : $org : $type : type name") if ($type != /\w+/);
	  push (@errors, "$project : $org : $type : detailTable") if ( $orgHsh->{$org}->{$type}->{'table'} !~ /\w+\.*/);
	  push (@errors, "$project : $org : $type : fields") if ( $orgHsh->{$org}->{$type}->{'fields'} !~ /\w+\,*/);
	}
      }
    }
  }

  if (scalar @errors >= 1) {

    foreach my $error (@errors) {
      print STDERR "ERROR - $error\n";
    }

    die "Please fix the config file error(s) before running\n";
  }
}


sub processConfig {

  my ($confArr,$orgHsh) = @_;

  foreach my $projectHsh (@{$confArr}) {
    foreach my $project (keys %$projectHsh) {
      foreach my $org ($projectHsh->{$project}->{'organisms'}) {

	&runLoadDetailTable($project,$org, $orgHsh) if $config->{$project}->{'loadDetailTable'} eq 'yes';

	&runFullRecordFile($project, $org, $orgHsh, $projectHsh->{$project}->{'release'} ) if ($config->{$project}->{'createFile'} eq 'yes');
      }
    }
  }
}


sub runFullRecordFile{

  my ($project,$org, $orgHsh,$release) = @_;

  foreach my $type (keys %{$orgHsh->{$org}}) {

    my $table = $orgHsh->{$org}->{$type}->{'table'};

    my $fields = $orgHsh->{$org}->{$type}->{'fields'};

    my ($organism,$taxonName) = split(/\|/,$org);

    my $sqlFile = &writeTmpSql($type, $taxonName);

    my $lcType = lc($type);

    my $ucType = ucfirst($lcType);

    my $cmd = "createFullRecordFile -record ${ucType}RecordClasses.${ucType}RecordClass -sqlFile $sqlDir/tmp_org_${type}.sql -cacheTable apidb.${ucType}Detail -model $project  --dumpFile $downloadFileDir/$project/release-${release}/${organism}/${organism}${ucType}_${project}-${release}.txt 2>> ${organism}${ucType}File.err";

    `$cmd`;

    my $retCode = $?>>8;

    die("Failed with status $retCode running") if ($retCode);

    unlink("$sqlFile");
  }
}


sub runLoadDetailTable {

  my ($project,$org, $orgHsh,$release) = @_;

  foreach my $type (keys %{$orgHsh->{$org}}) {

    my $table = $orgHsh->{$org}->{$type}->{'table'};

    my $fields = $orgHsh->{$org}->{$type}->{'fields'};

    my ($organism,$taxonName) = split(/\|/,$org);

    my $sqlFile = &writeTmpSql($type, $taxonName);

    my $ucType = ucfirst($type);

    my $cmd = "loadDetailTable -record ${ucType}RecordClasses.${ucType}RecordClass -sqlFile $sqlDir/tmp_org_${type}.sql -cacheTable $table -model $project 2>> ${ucType}Cache.err";

    $cmd .= " -field $config->{$project}->{'fieldList'}" if ($config->{$project}->{'fieldList'} &&  $config->{$project}->{'fieldList'} ne 'all');

    `$cmd`;

    my $retCode = $?>>8;

    die("Failed with status $retCode running") if ($retCode);

    unlink("$sqlFile");
  }
}

sub writeTmpSql {
  my ($type,$taxonName) = @_;

  open(SQL, "$sqlDir/org_${type}.sql") or die "$sqlDir/org_${type}.sql  can not be opened for reading\n";

  undef $/;

  my $sql = <SQL>;

  close (SQL);
  #substitute for the macro $ORGANISM$ in the sql
  $sql =~ s/\$ORGANISM\$/$taxonName/g;

  open (TMP, ">$sqlDir/tmp_org_${type}.sql") or die ("Can not open $sqlDir/tmp_org_${type}.sql for writing\n");

  print TMP "$sql";

  close TMP;

  return "$sqlDir/tmp_org_${type}.sql";

}


sub usage {

  print "runFullRecordDump.pl --configFile  --sqlDir --downloadFileDir --restart\n
         config file = file with the following key/value pairs in the following arrangement of lines:\n
                       project=XXXXDB release=xxxx(integers and decimal only)  loadDetailTable=yes/no createFiles=yes/no
                       org=(pipe separated name as used in download files and appropriate taxon name)
                       type=(such as Gene or Sequence) detailTable=(detail table) fields=(comma delimted list of specific fields to be recached or all)
                       type=Sequence detailTable=apidb.SequenceDetail fields=all
                       Ex:config Ex:
                                 project=CryptoDB release=6.6 loadDetailTable=yes createFiles=yes
                                 org=Chominis|Cryptosporidium hominis
                                 type=Gene detailTable=apidb.GeneDetail fields=InterPro
                                 type=Sequence detailTable=apidb.SequenceDetail fields=all
                                 org=Cmuris|Cryptosporidium muris
                                 type=Gene detailTable=apidb.GeneDetail fields=InterPro
                                 type=Sequence detailTable=apidb.SequenceDetail fields=all
                                 org=Cparvum|Cryptosporidium parvum Iowa II
                                 type=Gene detailTable=apidb.GeneDetail fields=InterPro
                                 type=Sequence detailTable=apidb.SequenceDetail fields=all
                                 org=CparvumChr6|Cryptosporidium parvum
                                 type=Gene detailTable=apidb.GeneDetail fields=InterPro
                                 type=Sequence detailTable=apidb.SequenceDetail fields=all
                                 //



>CryptoDB 4.3 s|g|i detailTable InterPro wdkCache\n
                          Chominis Cryptosporidium hominis
                          Cparvum Cryptosporidium parvum Iowa II
                          CparvumChr6 Cryptosporidium parvum
                          Cmuris Cryptosporidium muris
         sqlDir = directory for the gene, sequence, and isolate sql files used by fulRecordCache and fulRecordFile\n
         fileDir = download file dir path, Ex: /files/cbil/data/cbil/apiSiteFiles/downloadSite\n";
}



 
#config Ex:
#project=CryptoDB release=6.6 loadDetailTable=yes createFiles=yes
#org=Chominis|Cryptosporidium hominis
#type=Gene detailTable=apidb.GeneDetail fields=InterPro
#type=Sequence detailTable=apidb.SequenceDetail fields=all
#org=Cmuris|Cryptosporidium muris
#type=Gene detailTable=apidb.GeneDetail fields=InterPro
#type=Sequence detailTable=apidb.SequenceDetail fields=all
#org=Cparvum|Cryptosporidium parvum Iowa II
#type=Gene detailTable=apidb.GeneDetail fields=InterPro
#type=Sequence detailTable=apidb.SequenceDetail fields=all
#org=CparvumChr6|Cryptosporidium parvum
#type=Gene detailTable=apidb.GeneDetail fields=InterPro
#type=Sequence detailTable=apidb.SequenceDetail fields=all
#//
