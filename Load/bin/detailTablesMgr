#! /usr/bin/perl
use lib "$ENV{GUS_HOME}/lib/perl";
use Getopt::Long;
use strict;

my ($config,$sqlDir,$downloadFileDir,$restartOrg,$verbose);
&GetOptions("configFile=s" => \$config,
            "sqlDir=s" => \$sqlDir,
            "downloadFileDir=s" => \$downloadFileDir,
	    "restartOrg=s" => \$restartOrg,
	    "verbose!" => \$verbose);

$| = 1;



&usage unless (-s $config && -d $sqlDir && -d $downloadFileDir);

#config Ex:
#project=CryptoDB release=6.6 loadDetailTable=yes createFiles=yes
#org=Chominis|Cryptosporidium hominis
#type=Gene detailTable=apidb.GeneDetail fields=InterPro
#type=Sequence detailTable=apidb.SequenceDetail fields=all
#org=Cmuris|Cryptosporidium muris
#type=Gene detailTable=apidb.GeneDetail fields=InterPro
#type=Sequence detailTable=apidb.SequenceDetail fields=all
#org=Cparvum|Cryptosporidium parvum Iowa II
#type=Gene detailTable=apidb.GeneDetail fields=InterPro
#type=Sequence detailTable=apidb.SequenceDetail fields=all
#org=CparvumChr6|Cryptosporidium parvum
#type=Gene detailTable=apidb.GeneDetail fields=InterPro
#type=Sequence detailTable=apidb.SequenceDetail fields=all
#//


&parseConfig;

sub parseConfig {

  open (CONFIG,$config) || die "Can't open $config for reading\n";

  my $date = `date`; chomp($date);

  print STDERR "Parsing config file, ,$config. $date\n";

  my $project;

  my %config;

  my @confArr;

  my %orgHsh;

  my $organism;

  my $restartFlag = 0;

  while(<CONFIG>) {
    chomp;
    s/#.*//;
    next if ($_ =~ /^\s*$/);

    s/\s*=\s*/=/g;

    s/\s*$//g;

    if ($_ =~ /project=(\S+)/){

      $project = $1;

      if ($_ =~ /release=(\S+)/){$config{$project}{'release'}=$1;}

      if ($_ =~ /loadDetailTable=(\S+)/){$config{$project}{'loadDetailTable'}=$1;}

      if ($_ =~ /createFile=(\S+)/){$config{$project}{'createFile'}=$1;}

    }
    elsif ($_ =~ /org=(.+)/) {

      $organism = $1;

      if ($restartOrg && $organism !~ /$restartOrg/ && !$restartFlag) {

	$organism = "";
	next;
      }
      if ($restartOrg && $organism =~ /$restartOrg/) {

	$restartFlag = 1;
      }

      push (@{$config{$project}{'organisms'}}, $organism);

    }
    elsif ($_  =~ /type=(\S+)/) {

      my $type = $1;

      if ($organism) {

	if($_ =~ /detailTable=(\S+)/){$orgHsh{$organism}{$type}{'table'} = $1;}

	if($_ =~ /fields=(\S+)/){$orgHsh{$organism}{$type}{'fields'} = $1;}

      }
      else {
	die "each organism line should be followed by type lines Ex:org=Cmuris|Cryptosporidium muris\ntype=Gene detailTable=apidb.GeneDetail fields=InterPro\ntype=Sequence detailTable=apidb.SequenceDetail fields=all\n";
      }
    }
    elsif ($_ =~ /\/\//){

      my %copy = %config;

      push (@confArr,\%copy);

      %config = ();

      $organism = "";
    }
    else {
      die "There is an unacceptable line in the config file:\n $_\n";
    }
  }
  my $date = `date`; chomp($date);
  print STDERR "Finished parsing config file, $config\n Will validate the contents of the config file. $date\n";

  &validate(\@confArr, \%orgHsh);

  my $date = `date`; chomp($date);
  print STDERR "Finished validating the config file key/value pairs\n Processing. $date\n";

  &processConfig(\@confArr, \%orgHsh);

  my $date = `date`; chomp($date);
  print STDERR "Finished processing the projects and orgs\n DONE. $date\n"; 

}


sub validate {
  my ($confArr, $orgHsh ) = @_;

  my @errors;

  foreach my $projectHsh ( @{$confArr}) {

    foreach my $project (keys %{$projectHsh}) {

      push (@errors, "$project : project name") if ($project !~ /\w+DB/);
      push (@errors, "$project : release") if ($projectHsh->{$project}->{'release'} !~ /[\d\.]+/);

      push (@errors, "$project : loadDetailTable") if ($projectHsh->{$project}->{'loadDetailTable'} !~ /yes|no/);

      push (@errors, "$project : createFile") if ($projectHsh->{$project}->{'createFile'} !~ /yes|no/);

      foreach my $org (@{$projectHsh->{$project}->{'organisms'}}) {
	push(@errors,"$project : orgs : $org") if ($org != /\w+\s*\|\s*[\w\s]+/);

	foreach my $type (keys %{$orgHsh->{$org}}) {
	  push (@errors,"$project : $org : $type : type name") if ($type != /\w+/);

	  push (@errors, "$project : $org : $type : detailTable") if ( $orgHsh->{$org}->{$type}->{'table'} !~ /\w+\.*/);
	  push (@errors, "$project : $org : $type : fields") if ( $orgHsh->{$org}->{$type}->{'fields'} !~ /\w+\,*/);
	}
      }
    }
  }

  if (scalar @errors >= 1) {

    foreach my $error (@errors) {
      print STDERR "ERROR - $error\n";
    }

    die "Please fix the config file error(s) before running\n";
  }
}


sub processConfig {

  my ($confArr,$orgHsh) = @_;

  foreach my $projectHsh (@{$confArr}) {
    foreach my $project (keys %{$projectHsh}) {
      foreach my $org (@{$projectHsh->{$project}->{'organisms'}}) {

	&runLoadDetailTable($project,$org, $orgHsh,$projectHsh) if $projectHsh->{$project}->{'loadDetailTable'} eq 'yes';

	&runFullRecordFile($project, $org, $orgHsh, $projectHsh->{$project}->{'release'} ) if ($projectHsh->{$project}->{'createFile'} eq 'yes');
      }
    }
  }
}


sub runFullRecordFile{

  my $date = `date`; chomp($date);

  print "Writing text files. $date\n";

  my ($project,$org, $orgHsh,$release) = @_;

  foreach my $type (keys %{$orgHsh->{$org}}) {

    my $table = $orgHsh->{$org}->{$type}->{'table'};

    my $fields = $orgHsh->{$org}->{$type}->{'fields'};

    my ($organism,$taxonName) = split(/\|/,$org);

    my $sqlFile = &writeTmpSql($type, $taxonName);

    my $lcType = lc($type);

    my $ucType = ucfirst($lcType);

    `mkdir -p $downloadFileDir/$project/release-${release}/${organism}`;

    my $cmd = "createFullRecordFile -record ${ucType}RecordClasses.${ucType}RecordClass -sqlFile $sqlDir/tmp_org_${type}.sql -cacheTable $table -model $project  --dumpFile $downloadFileDir/$project/release-${release}/${organism}/${organism}${ucType}_${project}-${release}.txt 2>> ${organism}${ucType}File.err";

    `$cmd`;

    print STDERR "CMD: $cmd\n" if $verbose;

    my $retCode = $?>>8;

    die("Failed with status $retCode running") if ($retCode);

    unlink("$sqlFile");
  }

  my $date = `date`; chomp($date);

  print "Writing text files. $date\n";
}


sub runLoadDetailTable {


  my $date = `date`; chomp($date);

  print "Loading detail tables. $date\n";

  my ($project,$org, $orgHsh,$release, $config) = @_;

  foreach my $type (keys %{$orgHsh->{$org}}) {

    my $table = $orgHsh->{$org}->{$type}->{'table'};

    my $fields = $orgHsh->{$org}->{$type}->{'fields'};

    my ($organism,$taxonName) = split(/\|/,$org);

    my $sqlFile = &writeTmpSql($type, $taxonName);

    my $lcType = lc($type);

    my $ucType = ucfirst($lcType);

    my $cmd = "loadDetailTable -record ${ucType}RecordClasses.${ucType}RecordClass -sqlFile $sqlDir/tmp_org_${type}.sql -detailTable $table -model $project ";

    $cmd .= " -field $config->{$project}->{'fieldList'}" if ($config->{$project}->{'fieldList'} &&  $config->{$project}->{'fieldList'} ne 'all');

    $cmd .= "2>> ${organism}${ucType}Details.err";

    `$cmd`;

    print STDERR "CMD: $cmd\n" if $verbose;

    my $retCode = $?>>8;

    die("Failed with status $retCode running") if ($retCode);

    unlink("$sqlFile");
  }

  my $date = `date`; chomp($date);

  print "Finished loading detail tables. $date\n";
}

sub writeTmpSql {
  my ($type,$taxonName) = @_;

  open(SQL, "$sqlDir/org_${type}.sql") or die "$sqlDir/org_${type}.sql  can not be opened for reading\n";

  undef $/;

  my $sql = <SQL>;

  close (SQL);
  #substitute for the macro $ORGANISM$ in the sql
  $sql =~ s/\$ORGANISM\$/$taxonName/g;

  print STDERR "SQL after substitution of org:\n    $sql\n" if $verbose;

  open (TMP, ">$sqlDir/tmp_org_${type}.sql") or die ("Can not open $sqlDir/tmp_org_${type}.sql for writing\n");

  print TMP "$sql" if $verbose;

  close TMP;

  return "$sqlDir/tmp_org_${type}.sql";

}


sub usage {

  print "detailTablesMgr --configFile  --sqlDir --downloadFileDir --restart --verbose\n
         config file = file with the following key/value pairs in the following arrangement of lines:\n
                       project=XXXXDB release=xxxx(integers and decimal only)  loadDetailTable=yes/no createFiles=yes/no
                       org=(pipe separated name as used in download files and appropriate taxon name)
                       type=(such as Gene or Sequence) detailTable=(detail table) fields=(comma delimted list of specific fields to be recached or all)
                       type=Sequence detailTable=apidb.SequenceDetail fields=all
                       Ex:config Ex:
                                 project=CryptoDB release=6.6 loadDetailTable=yes createFiles=yes
                                 org=Chominis|Cryptosporidium hominis
                                 type=Gene detailTable=apidb.GeneDetail fields=InterPro
                                 type=Sequence detailTable=apidb.SequenceDetail fields=all
                                 org=Cmuris|Cryptosporidium muris
                                 type=Gene detailTable=apidb.GeneDetail fields=InterPro
                                 type=Sequence detailTable=apidb.SequenceDetail fields=all
                                 org=Cparvum|Cryptosporidium parvum Iowa II
                                 type=Gene detailTable=apidb.GeneDetail fields=InterPro
                                 type=Sequence detailTable=apidb.SequenceDetail fields=all
                                 org=CparvumChr6|Cryptosporidium parvum
                                 type=Gene detailTable=apidb.GeneDetail fields=InterPro
                                 type=Sequence detailTable=apidb.SequenceDetail fields=all
                                 //";
}

