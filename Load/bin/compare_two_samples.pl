                                                             
# Author: Elisabetta Manduchi
# Copyright University of Pennsylvania 2011

# Modified on 03/02/2011, by Ganesh Srinivasamoorthy to estimate only 
# the p values (and ignore the gene expression/fold change calculations)

# Uses fisher.R (same author/copyright)

# Returns 2 files: one for up-regulation in condition 1 vs condition 2,
# the other for down-regulation. In each file, genes are ranked in order
# of increasing p-values from the one-sided Fisher Exact Test and, for ties,
# decreasing fold change.
# Output files have the following columns: gene_id, RPKM condition 1,
# RPKM condition 2, adjusted ratio/inverse ratio, p-value. 
# Only genes with count>= minimum depth specified by user, are output.

# Assumes input files are generated by RUM 1.01.

use strict;
use IO::File;

if (scalar(@ARGV)==0) {
  die "Usage:\ncompare_counts_between_two_samples.pl <mapping_stats_file_1> <mapping_stats_file_2> <counts_file_1> <counts_file_2> <min_depth> <output_prefix> <Rscript_path> <min or max> <paired_end yes/no>\n";
}

my $Rcmd = `which R`;
chomp($Rcmd);
if ($Rcmd =~ /Not Found/) {
  die "R is needed to run this plug-in.\n";
}

my ($numMappers1, $numMappers2);
my $fh = IO::File->new("<$ARGV[0]") || die "Cannot open file $ARGV[0]\n";
my $startRead = 0;
my $value = 0;

while (my $line=<$fh>) {
  if (($line =~ /^TOTAL/) && $ARGV[8] eq 'yes'){ 
      $startRead = 1;
  } elsif (($line =~ /^TOTAL:\s+(\S+)\s+\(/) && ($ARGV[8] eq 'no')){
      $value = $1;
    last;
  }
  if (($line =~ /one of forward or reverse mapped:\s+(\S+)\s+\(/) && ($startRead == 1)){
      $value = $1;
    last;
  }
}

$fh->close();

$value =~ s/,//g;
$numMappers1 = $value;
STDOUT->print("n1=$numMappers1\n");


$fh = IO::File->new("<$ARGV[1]") || die "Cannot open file $ARGV[1]\n";

$startRead = 0;
while (my $line=<$fh>) {
  if (($line =~ /^TOTAL/) && $ARGV[8] eq 'yes'){ 
      $startRead = 1;
  } elsif (($line =~ /^TOTAL:\s+(\S+)\s+\(/) && ($ARGV[8] eq 'no')){
      $value = $1;
    last;
  }
  if (($line =~ /one of forward or reverse mapped:\s+(\S+)\s+\(/) && ($startRead == 1)){
      $value = $1;
    last;
  }
}  

$fh->close();

$value =~ s/,//g;
$numMappers2 = $value;
STDOUT->print("n2=$numMappers2\n");


my $data1;
$fh = IO::File->new("<$ARGV[2]") || die "Cannot open file $ARGV[2]\n";
while (my $line=<$fh>) {
  if ($line !~ /^transcript/) {
    next;
  }
  chomp($line);
  my @arr = split(/\t/, $line);
  if ($ARGV[7] eq 'min') {
    $data1->{$arr[6]}->{'count'} = $arr[2];
  }
  if ($ARGV[7] eq 'max') {
    $data1->{$arr[6]}->{'count'} = $arr[2] + $arr[3];
  }
}
$fh->close();

my $data2;
$fh = IO::File->new("<$ARGV[3]") || die "Cannot open file $ARGV[3]\n";
while (my $line=<$fh>) {
  if ($line !~ /^transcript/) {
    next;
  }
  chomp($line);
  my @arr = split(/\t/, $line);
  if ($ARGV[7] eq 'min') {
    $data2->{$arr[6]}->{'count'} = $arr[2];
  }
  if ($ARGV[7] eq 'max') {
    $data2->{$arr[6]}->{'count'} = $arr[2] + $arr[3];
  }
}
$fh->close();

$fh = IO::File->new(">counts.tmp");
foreach my $id (sort keys(%{$data1})) {
  $fh->print("$data1->{$id}->{'count'}\t$data2->{$id}->{'count'}\n");
}

STDOUT->print('Calling R ...');
my $Rscript = $ARGV[6] . "/fisher.R";
my $tmpOutFile = $ARGV[5] . ".tmp";
my $cmd = "echo 'inputFile=\"counts.tmp\";outputFile=\"$tmpOutFile\";n1=$numMappers1;n2=$numMappers2' | cat - $Rscript | $Rcmd --slave --no-save";  
system("$cmd");
if (!-e "$tmpOutFile" || `grep "Error" $tmpOutFile`) {
  die "R script failed.\n";
}
unlink('counts.tmp');

my %p;
$fh = IO::File->new("<$tmpOutFile");
my $i = 0;
my @ids = sort keys(%{$data1});
while (my $line=<$fh>) {
  chomp($line);
  $p{$ids[$i]} = $line;
  $i++;
}
$fh->close();
unlink("$tmpOutFile");

#my $avg1 = 0;
#my $geneCounter = 0;
#$fh = IO::File->new("<$ARGV[4]") || die "Cannot open file $ARGV[4]\n";
#while (my $line=<$fh>) {
#  chomp($line);
#  my ($id, $value) = split(/\t/, $line);
#  $data1->{$id}->{'expr'} = $value;
#  $avg1 += $value;
#  $geneCounter++;
#}
#$fh->close();
#$avg1 = $avg1/$geneCounter;
#STDOUT->print("AVG1=$avg1\n");

#my $avg2 = 0;
#$fh = IO::File->new("<$ARGV[5]") || die "Cannot open file $ARGV[5]\n";
#while (my $line=<$fh>) {
#  chomp($line);
#  my ($id, $value) = split(/\t/, $line);
#  $data2->{$id}->{'expr'} = $value;
#  $avg2 += $value;
#}
#$fh->close();
#$avg2 = $avg2/$geneCounter;
#STDOUT->print("AVG2=$avg2\n");

#my $adjustment = ($avg1+$avg2)/20;
#if($adjustment == 0) {
#    $adjustment = .0000001;
#}
#STDOUT->print("adjustment=$adjustment\n");

#my %ratio;
#foreach my $id (keys %{$data1}) {
#  $ratio{$id} = ($data1->{$id}->{'expr'}+$adjustment)/($data2->{$id}->{'expr'}+$adjustment);
#}

my $wfh1 = IO::File->new(">$ARGV[5]_pvalues.txt");
#my $wfh2 = IO::File->new(">$ARGV[7]_down.txt");
#$wfh1->print("GENE ID\tEXPRESSION 1\tEXPRESSION 2\tADJUSTED RATIO\tP-VALUE\n");
$wfh1->print("GENE ID\tP-VALUE\n");
#$wfh2->print("GENE ID\tEXPRESSION 1\tEXPRESSION 2\tADJUSTED INVERSE RATIO\tP-VALUE\n");
#$wfh2->print("GENE ID\tP-VALUE\n");
foreach my $id (sort sortByFisherRatio keys %{$data1}) {
  if ($data1->{$id}->{'count'}>=$ARGV[4] || $data2->{$id}->{'count'}>=$ARGV[4]) {
#    my $r = $ratio{$id}>=1 ? $ratio{$id} : 1/$ratio{$id};
#    my $string = "$id\t$data1->{$id}->{'expr'}\t$data2->{$id}->{'expr'}\t". sprintf("%.4f", $r) . "\t$p{$id}\n";
    my $string = "$id\t$p{$id}\n";
#    if ($ratio{$id}>=1) {
      $wfh1->print($string);
#    }
#    else {
#      $wfh2->print($string);
#    }
  }
}
$wfh1->close();
#$wfh2->close();

sub sortByFisherRatio {
  my $p1 = $p{$a};
  my $p2 = $p{$b};
#  my $r1 = $ratio{$a};
#  my $r2 = $ratio{$b};

#  ($p1 <=> $p2 or $r2 <=> $r1);
   ($p1 <=> $p2);
}


