#!/usr/bin/perl

use strict;

my ($inputVariantsFile, $varscanDir, $targetDir, $readFreqCutoff, $refStrainName) = @ARGV;

usage() unless scalar(@ARGV) == 5;

die "Variants file '$inputVariantsFile' does not exist\n" unless -e $inputVariantsFile;
die "Varscan dir '$varscanDir' does not exist\n" unless -d $varscanDir;
die "Target dir '$targetDir' does not exist\n" unless -d $targetDir;
die "Read freq cutoff must be a multiple of five less than 100\n" unless $readFreqCutoff =~ /\d0/ || $readFreqCutoff =~ /\d5/;

# make readFreqXX dir
my $readFreqDir = "$targetDir/readFreq$readFreqCutoff";
die "Read freq dir '$readFreqDir' already exists.  Please remove before running.\n" if -e "$readFreqDir";
mkdir($readFreqDir) || die "Could not make read freq dir '$readFreqDir'\n";

# zip through varscan dir, reading each strain name.  make a file mapping them to integer indexes.  also open an output file for each one
open(STRAINMAP, ">$readFreqDir\strainIdToName.dat") || die "Can't open file '$readFreqDir\strainIdToName.dat' for writing\n";
opendir(my $dirhandle, $varscanDir) || die "Can't open varscan dir '$varscanDir'\n";
my $strainCount = 0;
while(readdir($dirhandle)) {
  next if /^\./;
  $strainCount++;
  print STRAINMAP "$strainCount\t$varscanFileName\n";   # map strain index (count) to strain name;
  open( my "fh$strainCount", ">$readFreqDir\$strainCount");    # open variants file for this strain, named after its index (count)
}
close($dirhandle);
close(STRAINMAP);

# open the input file and two of the output files
open(V, $inputVariantsFile) || die "Can't open variants file '$inputVariantsFile'\n";
open(SEQID, ">$readFreqDir/contigIdToSourceId.dat") || die "Can't open seq IDs file '$readFreqDir/contigIdToSourceId.dat' for writing\n";
open(REFGENOME, ">$readFreqDir/referenceGenome.dat") || die "Can't open ref genome file '$readFreqDir/referenceGenome.dat' for writing\n";

my $prevSourceId;                 # the seq source id of the previous SNP 
my $prevLocation;                 # the location of the previous SNP
my @variantsInOneSnp;             # array of array refs. holds all the variants in one snp, as parsed from input file.  cleared out after processing that snp
my @strainArray;                  # a pre-allocated array of length = number of strains.  tracks if a strain was seen in current snp
my $foundVariantOverThreshold;    # a flag indicating that in current snp we found at least one variant that passes read freq threshold
my $foundVariantThatDoesNotMatchRef;  # a flag indicating that in current snp we found at least one above-threshold variant that does not match ref
my @refGenomeVariant;             # an array holding the info about the most recently seen reference genome array
my $sequenceIndex = 1;            # incremented for each sequence we see.  used to compress seq id in variant files

# scan variants input file.  gather all variants for a snp, and process that snp when we hit the next snp
while (<V>) {
  chomp;

  # parse variant from input file NEEDS FIXING TO REFLECT REAL INPUT FORMAT.
  my ($strain, $sourceId, $location, $allele, $product, $readFreq, $matchesRef) = split(/\t/);

  # process previous snp if we got to the next one; ignore it if no variants were above threshold.
  # if not being ignored, write the ref genome info for this snp to the ref genome file, and write to variants files
  if ($prevLocation && $location != $prevLocation) {
    if ($foundVariantOverThreshold) {
      print REFGENOME "$sequenceIndex\t$location\t$refGenomeVariant[3]\t$refGenomeVariant[4]\n";
      writeToVariantsFiles(\@variantsInOneSnp, \%strainName2Index, \@strainArray, $strainCount, $sequenceIndex, $prevLocation);
    }
    @variantsInOneSnp = ();
    $foundVariantOverThreshold = 0;
  }

  # if new seq source id, write it to the seq id mapping flie
  if ($sourceId ne $prevSourceId) {
    print SEQID "$sequenceIndex\t$sourceId\n";
    $sequenceIndex++;
  }

  my @variant = ($strain, $sourceId, $location, $allele, $product, $readFreq, $matchesRef);  # just the fields we need

  # if this variant is from ref genome, save it to write to ref genome file when we hit next snp
  if ($strain eq $refStrainName) {
    @refGenomeVariant = @variant;
  }
  # else, if above threshold, save to write to variants file
  elsif ($readFreq >= $readFreqCutoff) {
    $foundVariantOverThreshold = 1;
    push(@variantsInOneSnp, \@variant);
  }
}

# final mop up of last SNP
print REFGENOME "$sequenceIndex\t$location\t$refGenomeVariant->[3]\t$refGenomeVariant->[4]\n" if ($foundVariantOverThreshold) ;
writeToVariantsFiles(\@variantsInOneSnp, \%strainName2Index, \@strainArray, $strainCount, $sequenceIndex, $prevLocation);
print SEQID "$sequenceIndex\t$sourceId\n" if ($sourceId ne $prevSourceId);


#############################    SUBROUTINES   ###################################################################################


sub writeToVariantsFiles {
  my ($variantsInOneSnp, $strainName2Index, $strainArray, $strainCount, $seqIndex, $location, $refGenomeVariant) = @_;

  # initialize array that tracks strains we have seen
  for (my $i=0; $i<=$strainCount; $i++) { $strainArray[$i] = 0; }

  my $prevMatchesRefVariant;
  my $prevMatchesRefStrainIndex;
  my $prevStrainIndex;
  foreach my $variant (@$variantsInOneSnp) {
    my $strainName = $variant->[0];
    my $strainIndex = $strainName2Index->{$strainName};
    die "Can't find index for strain '$strainName'\n" unless $strainIndex;

    # remember that we've seen this strain in this SNP
    $strainArray[$strainIndex] = 1;

    # logic is a little tricky here because on diploids we have to write out matchesRef strains
    my $matchesRef = $variant->[0];
    my $writeFlag;
    my $writePrevMatchesRefFlag;
    if ($matchesRef) {
      if ($strainIndex eq $prevStrainIndex) {
	$writeFlag = 1;      # write matches ref if diploid
	$prevMatchesRefStrainIndex = -1;
      } else {
	$prevMatchesRefVariant = $variant;
	$prevMatchesRefStrainIndex = $strainIndex;
      }
    } else {
      $writeFlag = 1;
      if ($strainIndex eq $prevMatchesRefStrainIndex) {
	$writePrevMatchesRefFlag = 1;
	$prevMatchesRefStrainIndex = -1;
      }
    }

    if ($writeFlag) {
      my $strainFileHandle = "STR" . $strainIndex + 1;
      if (!$strainFilesAlreadyOpen{$strainIndex}) {
	my $strainFile = "$readFreqDir/" . $strainIndex + 1;
	open($strainFileHandle, ">$strainFile") || die "Can't open strain file '$strainFile' for writing\n";
	$strainFilesAlreadyOpen{$strainIndex} = 1;
      }
      my $allele = $variant->[3];
      my $product = $variant->[4];
      print $strainFileHandle "$seqIndex\t$location\t$allele\t$product\n";
    }

    if ($writePrevMatchesRefFlag) {
      my $strainFileHandle = "STR" . $strainIndex + 1;
      if (!$strainFilesAlreadyOpen{$strainIndex}) {
	my $strainFile = "$readFreqDir/" . $strainIndex + 1;
	open($strainFileHandle, ">$strainFile") || die "Can't open strain file '$strainFile' for writing\n";
	$strainFilesAlreadyOpen{$strainIndex} = 1;
      }
      my $allele = $prevMatchesRefVariant->[3];
      my $product = $prevMatchesRefVariant->[4];
      print $strainFileHandle "$seqIndex\t$location\t$allele\t$product\n";
    }
  }

  # now write out the unknowns
  for (my $i=0; $i<=$strainCount; $i++) {
    if (!$strainArray[$i]) {
      my $inx = $i + 1;  # strain index is 1 based
      my $strainFileHandle = "STR$inx";
      if (!$strainFilesAlreadyOpen{$i}) {
	my $strainFile = "$readFreqDir/$inx";
	open($strainFileHandle, ">$strainFile") || die "Can't open strain file '$strainFile' for writing\n";
      }
      print $strainFileHandle "$inx\t$location\t0\0\n";
    }
  }
}

###############################################################

sub usage {
  die "
Create SNP variation files, one per strain, for use by the HighSpeedSnpSearch system (C based SNP searches).

Usage:  hsssCreateStrainFiles variants_file varscan_dir target_dir read_freq_cutoff ref_strain_name

Where:
  variants_file:     a file containing all variants for all strains.  Within each sequence, the variants are
                     grouped by SNP, and the SNPs are ordered by location.  Thus we get a series of variants
                     per SNP, for each SNP.  Each SNP includes a variant for the reference strain.  The variants
                     each have this info: strain, seq_id, location, allele, product, matches_reference

  varscan_dir:       a directory containing one varscan file for each strain we will make an output file for.
                     The files are named for with the strain name.

  target_dir:        the directory in which to place the new directory that will hold the strain files created

  read_freq_cutoff:  ignore variants that have a read frequency below this cutoff.

  ref_strain_name:   the name of the reference strain


Details:

Create a directory called readFreqXX where XX is the read_freq_cutoff supplied on the command line.  (Read frequency is
the percentage of reads at this location that support an allele.)  The output strain files are created in that directory.

Each output strain file is named for the strain's strain index, which is generated by this program.  The strain index for a strain is
its position in the alphabetical list of strain file names as found in the varscan directory.  The output strain files are compliant with the
HighSpeedSnpSearch system.  They contain an ordered set of SNPs.  Each SNP is represented in the file by a set of variants for that SNP.
SNPs are excluded from consideration if they have no variants at or above the read frequency threshold.  The SNPs are ordered by sequence
and location, as found in the input file.

Each variant has columns: seq_index, location, allele_code, product_code.  The files are binary, with each variant taking XX bytes: 
Y for seq_index, Z for location, 1 for allele and 1 for product.  Variants that match the reference strain are omitted from the file.
Strains which do not have an above-threshold variant at a SNP are included in the file as a fake variant with unknown allele and product.
If a strain is has heterozygous alleles (above threshold) at a SNP, then all its variants are included, including one that matches reference.

The encoding of the alleles is:  0=unknown, 1=a, 2=c, 3=g, 4=t.  The encoding of the proteins is the ascii code of the capitalized product (65=A).
Nonsense product is encoded as 42 (*).

This program also writes an additional three files into the readFreqXX directory:
  - contigIdToSourceId.dat:  a mapping from sequence index to source_id
  - referenceGenome.dat:     a strain file like all the others, but for the reference genome
  - strainIdToName.dat:      a mapping from the strain index to strain name

";
}
