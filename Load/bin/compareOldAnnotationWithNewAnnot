#!/usr/bin/perl

use strict;
use lib "$ENV{GUS_HOME}/lib/perl";
use Bio::SeqIO;
use Getopt::Long;

use Data::Dumper;
use FileHandle;
use HTTP::Date;

use DBI;
use DBD::Oracle;
use CBIL::Util::PropertySet;

my ($date, ) = split(" ", HTTP::Date::time2iso());
$date = join("",split(/-/,$date));

my ($verbose, $help, $organismAbbrev, $extDbName, $extDbRlsVer, $oldTranscriptFile, $newAliasesFile);

&GetOptions('help|h' => \$help,
            'organismAbbrev=s' => \$organismAbbrev,
            'extDbName=s' => \$extDbName,
            'extDbRlsVer=s' => \$extDbRlsVer,
	    'oldTranscriptFile=s' => \$oldTranscriptFile,
	    'newAliasesFile=s' => \$newAliasesFile,
           );

&usage() if($help);

&usage("Missing a Required Argument") unless (defined ($organismAbbrev && $oldTranscriptFile ));
&usage("Missing Required Argument") unless (defined ($extDbName && $extDbRlsVer) );

my $gusConfigFile = "$ENV{GUS_HOME}/config/gus.config";
my @properties = ();
my $gusconfig = CBIL::Util::PropertySet->new($gusConfigFile, \@properties, 1);
my $u = $gusconfig->{props}->{databaseLogin}; 
my $pw = $gusconfig->{props}->{databasePassword}; 
my $dsn = $gusconfig->{props}->{dbiDsn}; 
my $dbh = DBI->connect($dsn, $u, $pw) or die DBI::errstr;
$dbh->{RaiseError} = 1;
$dbh->{LongTruncOk} = 1;
$dbh->{LongReadLen} = 512 * 512 * 1024;

## get the extDbRlsId
my $extDbRlsId;
my $sql = "
select edr.external_database_release_id from sres.externaldatabase ed, sres.externaldatabaserelease edr 
where ed.external_database_id=edr.external_database_id and ed.name like '$extDbName' and edr.version='$extDbRlsVer'
";

my $stmt = $dbh->prepare($sql);
$stmt->execute();
($extDbRlsId) = $stmt->fetchrow_array();
print STDERR "For $organismAbbrev, get extDbRlsId=$extDbRlsId\n";
$stmt->finish();

## get the new transcript sequence
my (%newSourceIds, %newSeqs, %newLengths);
my $sql = "select source_id, length, sequence from DOTS.splicednasequence where na_sequence_id in 
( select na_sequence_id from DOTS.transcript where parent_id in 
( select na_feature_id from DOTS.genefeature where external_database_release_id=?) )";

my $stmt = $dbh->prepare($sql);
$stmt->execute($extDbRlsId);

while ( my ($tSourceId, $tLength, $tSeq) = $stmt->fetchrow_array()) {
  $tSourceId =~ s/\-\d$//g;
  $newSourceIds{$tSourceId} = $tSourceId;
  $newSeqs{$tSourceId} = $tSeq;
  $newLengths{$tSourceId} = $tLength;
}
$stmt->finish();

## get the old transcript info
my (%oldSeqs, %oldLengths, $sourceId);
open (OLD, "$oldTranscriptFile") || die " can not open old transcript file to read.\n";
while (<OLD>) {
  if ($_ =~ /^>(\S+).*length=(\d+)/) {
    $sourceId = $1;
    $oldLengths{$sourceId} = $2;
    print STDERR "duplicated sourceId $sourceId in the old transcipt file\n" if ($oldSeqs{$sourceId});
  } else {
    my $curr = $_;
    $curr =~ s/\s+//g;
    $curr =~ s/\n//g;
    $oldSeqs{$sourceId} .= uc($curr);
  }
}
close OLD;

## get the aliases info
my (%aliases, %newIdToOld);
if ($newAliasesFile) {
  open (ALI, "$newAliasesFile") || die " can not open the aliases file to read\n";
  while (<ALI>) {
    chomp;
    my @items = split (/\t/, $_);
    $aliases{$items[1]} = $items[0];
    $newIdToOld{$items[0]} = $items[1];
  }
  close ALI;
}

## compare if the old sourceId in the new transcript
my ($ct, $sameCt, $reuseCt, $newIdCt, $aliasCt, $notAliasCt);
foreach my $k (sort keys %oldSeqs) {
  if ($newSourceIds{$k}) {
    if ($newSeqs{$k} eq $oldSeqs{$k}) {
      $sameCt++;
      print "old source Id same as the new source Id -- $k\n";
    } else {
      ## possible sourceId reusing.
      print "WARNING: possible source Id reusing -- $k\n";
      $reuseCt++;
    }
  } else {
    ## check if in the aliases file
    if ($aliases{$k}) {
      $aliasCt++;
    } else {
      print "WARNING: old source Id not found in the new annotation -- $k\n";
      $notAliasCt++;
    }
    $newIdCt++;
  }
  $ct++;
}
print "Total old source Id = $ct\n" if ($ct);
print "    same as the new source Id = $sameCt\n" if ($sameCt);
print "    possible reuse source Id = $reuseCt\n" if ($reuseCt);
print "    but not in the new source Id = $newIdCt\n" if ($newIdCt);
print "For those that not in the new source Id\n";
print "    in the aliases file = $aliasCt\n" if ($aliasCt);
print "    not in the aliases file = $notAliasCt\n" if ($notAliasCt);
$sameCt=0;
$reuseCt=0;
$newIdCt=0;
$aliasCt=0;
$notAliasCt=0;


sub usage {
  die
"
A script to compare the gene ID in the previous annotation with the newer annotation 
based on the transcript sequence and length

Usage: perl compareOldAnnotationWithNewAnnot --organismAbbrev pyoeyoelii17XNL 
--extDbName pyoeyoelii17XNL_primary_genome_RSRC --extDbRlsVer 2013-10-01 
--oldTranscriptFile PlasmoDB-9.3_Pyoelii17XNL_AnnotatedTranscripts.fasta 
--newAliasesFile pyoeyoelii17XNL_aliases.txt > warning.log

NOTE: the GUS_HOME should point to the instance that has the new annotation has been loaded

where
  --organismAbbrev: the organism Abbrev in the table apidb.organism
  --extDbName: the external database name for loading the new genome and annoation
  --extDbRlsVer: the external database release version for loading the new genome and annotation
  --oldTranscriptFile: the old transcript file that can be gotten from /eupath/data/apiSiteFiles/downloadSite/ dir
  --newAliasesFile: the tab delimited aliases file that extracted from the new annotation file
                    it is optional.


";
}
