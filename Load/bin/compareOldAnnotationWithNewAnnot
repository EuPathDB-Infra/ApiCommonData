#!/usr/bin/perl

use strict;
use lib "$ENV{GUS_HOME}/lib/perl";
use Bio::SeqIO;
use Getopt::Long;

use Data::Dumper;
use FileHandle;
use HTTP::Date;

use DBI;
use DBD::Oracle;
use CBIL::Util::PropertySet;

my ($date, ) = split(" ", HTTP::Date::time2iso());
$date = join("",split(/-/,$date));

my ($verbose, $help, $organismAbbrev, $extDbName, $extDbRlsVer, $oldTranscriptFile, $oldProteinFile, $newAliasesFile);

&GetOptions('help|h' => \$help,
            'organismAbbrev=s' => \$organismAbbrev,
            'extDbName=s' => \$extDbName,
            'extDbRlsVer=s' => \$extDbRlsVer,
	    'oldTranscriptFile=s' => \$oldTranscriptFile,
	    'oldProteinFile=s' => \$oldProteinFile,
	    'newAliasesFile=s' => \$newAliasesFile,
           );

&usage() if($help);

&usage("Missing a Required Argument") unless (defined ($organismAbbrev && $oldTranscriptFile ));
&usage("Missing Required Argument") unless (defined ($extDbName && $extDbRlsVer) );

my $gusConfigFile = "$ENV{GUS_HOME}/config/gus.config";
my @properties = ();
my $gusconfig = CBIL::Util::PropertySet->new($gusConfigFile, \@properties, 1);
my $u = $gusconfig->{props}->{databaseLogin}; 
my $pw = $gusconfig->{props}->{databasePassword}; 
my $dsn = $gusconfig->{props}->{dbiDsn}; 
my $dbh = DBI->connect($dsn, $u, $pw) or die DBI::errstr;
$dbh->{RaiseError} = 1;
$dbh->{LongTruncOk} = 1;
$dbh->{LongReadLen} = 512 * 512 * 1024;

## get the extDbRlsId
my $extDbRlsId;
my $sql = "
select edr.external_database_release_id from sres.externaldatabase ed, sres.externaldatabaserelease edr 
where ed.external_database_id=edr.external_database_id and ed.name like '$extDbName' and edr.version='$extDbRlsVer'
";

($extDbRlsId) = readFromDatabase ($sql, $dbh);
print STDERR "For $organismAbbrev, get extDbRlsId=$extDbRlsId\n";

## get the gene ID and type
my $sqls = "select na_feature_id, source_id, name from dots.genefeature where external_database_release_id=$extDbRlsId";
my @items = readFromDatabase ($sqls, $dbh);

my (%newSourceIds, %newSeqs, %newLengths, %newProtSeqs, %newProtLengths);
foreach my $i (0..$#items) {
  my ($naFeatId, $sid, $gtype) = split (/\s/, $items[$i]);
  print STDERR "$naFeatId, $sid, $gtype\n" if ($i < 10);

  $newSourceIds{$sid} = $sid;
  ## if protein coding gene, get the new translatedAASequence
  if ($gtype =~ /coding_gene/) {
    my $sqlp = "select length, sequence from DOTS.translatedaasequence where aa_sequence_id in 
(select aa_sequence_id from DOTS.translatedaafeature where na_feature_id in 
(select na_feature_id from DOTS.transcript where parent_id= $naFeatId ) )";
    my @pItems = readFromDatabase($sqlp, $dbh);
    ($newProtLengths{$sid}, $newProtSeqs{$sid}) = split (/\s/, $pItems[0] );
    print STDERR "in translatedAASequence, $newProtLengths{$sid}, $newProtSeqs{$sid}\n" if ($i < 10);
  }

  ## get the new splicednasequence
  my $sqlt = "select length, sequence from DOTS.splicednasequence where na_sequence_id in 
(select na_sequence_id from DOTS.transcript where parent_id = $naFeatId )";
  my @tItems = readFromDatabase($sqlt, $dbh);
  ($newLengths{$sid}, $newSeqs{$sid}) = split (/\s/, $tItems[0] );
  print STDERR "in splicednasequence, $newLengths{$sid}, $newSeqs{$sid}\n" if ($i < 10);
}


## get the old transcript info
my (%oldSeqs, %oldLengths, %oldCodings) = getSeqsInfoFromFasta($oldTranscriptFile);

## get the old protein info
my (%oldProtSeqs, %oldProtLengths, %oldProtCodings) = getSeqsInfoFromFasta($oldProteinFile);

## get the aliases info
my (%aliases, %newIdToOld);
if ($newAliasesFile) {
  open (ALI, "$newAliasesFile") || die " can not open the aliases file to read\n";
  while (<ALI>) {
    chomp;
    my @items = split (/\t/, $_);
    $aliases{$items[1]} = $items[0];
    $newIdToOld{$items[0]} = $items[1];
  }
  close ALI;
}

## compare if the old sourceId in the new annotation
my ($ct, $sameCt, $reuseCt, $gmChangCt, $newIdCt, $aliasCt, $notAliasCt);
foreach my $k (sort keys %oldSeqs) {
  if ($newSourceIds{$k}) {
    if ($newSeqs{$k} eq $oldSeqs{$k}) {
      $sameCt++;
      print "old source Id same as the new source Id -- $k\n";
    } else {
      ## possible gene model change
      if ($newSeqs{$k} =~ /$oldSeqs{$k}/ || $oldSeqs{$k} =~ /$newSeqs{$k}/) {
	print "possible gene model change, start or end -- $k\n";
	$gmChangCt++;
      } else {
        if ($newProtSeqs{$k} && $oldProtSeqs{$k} && $newProtSeqs{$k} eq $oldProtSeqs{$k}) {
          $gmChangCt++;
          print "possible gene model change, UTR -- $k\n";
        } else {
	  ## possible sourceId reusing.
	  print "WARNING: possible source Id reusing -- $k\n";
	  $reuseCt++;
        }
      }
    }
  } else {
    ## check if in the aliases file
    if ($aliases{$k}) {
      $aliasCt++;
    } else {
      print "WARNING: old source Id not found in the new annotation -- $k\n";
      $notAliasCt++;
    }
    $newIdCt++;
  }
  $ct++;
}
print "Total old source Id = $ct\n" if ($ct);
print "    same as the new source Id = $sameCt\n" if ($sameCt);
print "    possible gene model change = $gmChangCt\n" if ($gmChangCt);
print "    possible reuse source Id = $reuseCt\n" if ($reuseCt);
print "    but not in the new source Id = $newIdCt\n" if ($newIdCt);
print "For those that not in the new source Id\n";
print "    in the aliases file = $aliasCt\n" if ($aliasCt);
print "    not in the aliases file = $notAliasCt\n" if ($notAliasCt);
$sameCt=0;
$reuseCt=0;
$newIdCt=0;
$aliasCt=0;
$notAliasCt=0;



sub getSeqsInfoFromFasta {
  my ($inputFile) = @_;
  my ($sId, %seqs, %lengths, %codings);

  open (IN, "$inputFile") || die "can not open $inputFile to read.\n";
  while (<IN>) {
    chomp;
    if ($_ =~ /^>(\S+) \|.*length=(\d+) \|.*\| SO=(\S+)/) {
      $sId = $1;
      $lengths{$sId} = $2;
      $codings{$sId} = $3;
      print STDERR "duplicated sourceId $sId in the file $inputFile\n" if ($seqs{$sId});
    } else {
      my $curr = $_;
      $curr =~ s/\s+//g;
      $curr =~ s/\n//g;
      $seqs{$sId} .= uc($curr);
    }
  }
  close IN;
  return (%seqs, %lengths, %codings);
}


sub readFromDatabase {
  my ($sql, $dbh) = @_;
  my $stmt = $dbh->prepare($sql);
  $stmt->execute;
  my (@arrays);
  while (my @fetchs = $stmt->fetchrow_array()) {
    my $oneline;
    foreach my $i (0..$#fetchs) {
      $oneline .= "$fetchs[$i] ";
    }
    push @arrays, $oneline;
  }
  $stmt->finish();
  return @arrays;
}


sub usage {
  die
"
A script to compare the gene ID in the previous annotation with the newer annotation 
based on the transcript sequence and length

Usage: perl compareOldAnnotationWithNewAnnot --organismAbbrev pyoeyoelii17XNL 
--extDbName pyoeyoelii17XNL_primary_genome_RSRC --extDbRlsVer 2013-10-01 
--oldTranscriptFile PlasmoDB-9.3_Pyoelii17XNL_AnnotatedTranscripts.fasta 
--newAliasesFile pyoeyoelii17XNL_aliases.txt > warning.log

NOTE: the GUS_HOME should point to the instance that has the new annotation has been loaded

where
  --organismAbbrev: the organism Abbrev in the table apidb.organism
  --extDbName: the external database name for loading the new genome and annoation
  --extDbRlsVer: the external database release version for loading the new genome and annotation
  --oldTranscriptFile: the old transcript file that can be gotten from /eupath/data/apiSiteFiles/downloadSite/ dir
  --newAliasesFile: the tab delimited aliases file that extracted from the new annotation file
                    it is optional.


";
}
