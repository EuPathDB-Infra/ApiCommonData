#!/usr/bin/perl

use lib "$ENV{GUS_HOME}/lib/perl";
use Getopt::Long;
use Switch;
use strict;

my ($inputDir, $queryDir, $outputDir, $blastDatabase, 
    $subjectFile, $idRegex, $verbose, $speciesKey, $ncbiBlastPath);

my $speciesRegex = 'IEDBExport([a-zA-Z][a-zA-Z])\w*';

&GetOptions("inputDir=s" => \$inputDir,
	    "queryDir=s"=> \$queryDir,
	    "outputDir=s" => \$outputDir,
        "ncbiBlastPath=s" => \$ncbiBlastPath,
	    "blastDatabase=s" => \$blastDatabase,
	    "subjectFile=s" => \$subjectFile,
	    "speciesRegex=s" => \$speciesRegex,
	    "speciesKey=s" => \$speciesKey, # lookup database name in runBlast()
	    "idRegex=s" => \$idRegex,
	    "verbose!" => \$verbose,
	   );

if (!$inputDir || !$queryDir || !$outputDir || !$blastDatabase) {
  die "usage: createEpitopeMappingFile.pl --inputDir <DIRPATH> --queryDir <DIRPATH> --outputDir <DIRPATH> --blastDatabase <PATH> --subjectFile <subjectFile> [--speciesRegex <STRING>] [--speciesKey <STRING>] [--idRegex <STRING>] [--verbose]\n";
}


&getGenPetSeqs($inputDir, $queryDir);
&runBlast($outputDir, $queryDir, $inputDir, $blastDatabase, $speciesRegex, $idRegex, $verbose, $ncbiBlastPath);
&exactMapEpitopes($outputDir, $inputDir, $subjectFile, $speciesRegex, $verbose);
print STDERR "Mapping Complete\n";

sub getGenPetSeqs{
  my ($inputDir, $queryDir) = @_;

  unless (-d $queryDir){
    my $cmd = "mkdir -p $queryDir";

    &exeCmd($cmd);

  }

  die "Cannot locate the directory '$inputDir':$!\n" unless (-d $inputDir);

  opendir(DIR, $inputDir) or die "can't opendir '$inputDir': $!";

  my $file;
  while (defined($file = readdir(DIR))) {
    my $inFile = "$inputDir/$file";

    next unless -f "$inFile";

    my $outFile = $file;
    $outFile =~ s/(\w+).\w+/$1/;
    $outFile = "$queryDir/$outFile.fsa";

    my $cmd = "retrieveSeqsFromGenPept --inFile $inFile --outFile $outFile";

    &exeCmd($cmd);

  }
  closedir(DIR);
}

sub runBlast{
  my ($outputDir, $queryDir, $inputDir, $blastDatabase, $speciesRegex, $idRegex,$verbose, $ncbiBlastPath) = @_;

  unless(-d $queryDir){ die "Could not find the query file directory '$queryDir':$!";}

  unless (-d $outputDir){
    my $cmd = "mkdir -p $outputDir";
    &exeCmd($cmd);
  }

  opendir(EDIR, $inputDir) or die "can't opendir '$inputDir': $!";

  my $file;
  while (defined($file = readdir(EDIR))) {
    next unless -f "$inputDir/$file";

    my $baseFileName = $file;
    $baseFileName =~ s/(\w+).\w+/$1/;

    #get the files and database that go together
    my $epitopeFile = "$inputDir/$file";

    my $queryFile = "$queryDir/$baseFileName.fsa";

    my $outFile = "$outputDir/$baseFileName.out";

    print STDERR "DATABASE: $blastDatabase\n" if $verbose;
    print STDERR "OUTDIR: $outputDir\n" if $verbose;

    my $cmd = "runAndParseBlast --ncbiBlastPath $ncbiBlastPath --queryFile $queryFile --database $blastDatabase --epitopeFile $epitopeFile --outputFile $outFile";

    if ($idRegex){
      $cmd .= " --regex '$idRegex'";
    }

    print STDERR "CMD: $cmd\n" if $verbose;

    &exeCmd($cmd);
  }

  closedir(EDIR);
}


sub exactMapEpitopes{
  my ($outputDir, $inputDir, $proteinsFile, $speciesRegex, $verbose) = @_;

#TODO: Make sure we don't get exact matches for epitope:sequence pairs that we have matches on BLAST hits for

  unless (-d $outputDir){
    my $cmd = "mkdir -p $outputDir";
    &exeCmd($cmd);
  }

  opendir(EDIR, $inputDir) or die "can't opendir '$inputDir': $!";

  my $file;
  while (defined($file = readdir(EDIR))) {
    next unless -f "$inputDir/$file";

    my $baseFileName = $file;
    $baseFileName =~ s/(\w+).\w+/$1/;

    #get the files and database that go together
    my $epitopeFile = "$inputDir/$file";

    my $outFile = "$outputDir/$baseFileName.out";

    print STDERR "DATABASE: $subjectFile\n" if $verbose;

    my $cmd = "exactMapEpitopes --subjectFile $subjectFile --epitopeFile $epitopeFile --outputFile $outFile --rejectDuplicates";

    &exeCmd($cmd);
  }

  closedir(EDIR);
}

sub exeCmd{
  my ($cmd) = @_;

  print STDERR "$cmd\n";
  system($cmd);
  my $status = $? >> 8;
  die "Failed with status '$status running cmd: $cmd'" if $status;
}
