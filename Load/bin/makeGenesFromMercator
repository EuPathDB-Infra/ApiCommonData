#!/usr/bin/perl

## identifies toxo genes for the three strains by walking through each gene for each 
## strain and determining any genes from the other strains that overlap with this gene.
## then is simple transitive closure on the resulting mapping.

## Brian Brunk 07/21/2008

use strict;
use Getopt::Long;
use lib "$ENV{GUS_HOME}/lib/perl";
use GUS::ObjRelP::DbiDatabase;
use GUS::Supported::GusConfig;
use ApiCommonData::Load::MultAlignMercatorMavid;

use ApiCommonData::Load::Util;
#use GUS::Model::DoTS::TranslatedAASequence;

use CBIL::Util::V;

my ($gusConfigFile,$mercatorOutputDir,@gffFiles,$gffVersion);
my $verbose;
my $cndSrcBin = "/usr/local/bin/cndsrc-2006-09-19/bin/";

&GetOptions("verbose|v!"=> \$verbose,
            "gusConfigFile|gc=s" => \$gusConfigFile,
            "mercatorOutputDir|mod=s" => \$mercatorOutputDir,
            "cndSrcBin|b=s" => \$cndSrcBin,
            "gff_file=s" => \@gffFiles,
            "gff_version=s" => \$gffVersion,
           );

die "you MUST provide --gusConfigFile|gc <gusconfigfile> --mercatorOutputDir|md <dir with mercator output> --cndSrcBin|b <bin directory for mercator execs> --verbose|v \n" unless ($mercatorOutputDir && $cndSrcBin && ($gusConfigFile)); 

die "ERROR: mercatorOutputDir '$mercatorOutputDir' not found\n" unless -d "$mercatorOutputDir/alignments";
die "ERROR: $cndSrcBin '$cndSrcBin' not found\n" unless -f "$cndSrcBin/sliceAlignment";

$gusConfigFile = $ENV{GUS_HOME} . "/config/gus.config" unless($gusConfigFile);

if(scalar @gffFiles > 1) {
  foreach(@gffFiles) {
    die "ERROR:  gffFile $_ does not exist\n" unless(-e $_);
  }
} else {
  die "ERROR:  This script requires at least 2 gff files be passed\n";
}


my $gusconfig = GUS::Supported::GusConfig->new($gusConfigFile);

my $db = GUS::ObjRelP::DbiDatabase->new($gusconfig->getDbiDsn(),
                                        $gusconfig->getDatabaseLogin(),
                                        $gusconfig->getDatabasePassword(),
                                        $verbose,1,1,
                                        $gusconfig->getCoreSchemaName());

my $dbh = $db->getQueryHandle();

my $align = ApiCommonData::Load::MultAlignMercatorMavid->new();
$align->initialize($dbh,$mercatorOutputDir,$cndSrcBin);

my %seqGenes;

my $gffLocations = {};
foreach my $gffFile (@gffFiles) {
  ApiCommonData::Load::Util::addGffFeatures($gffLocations, $gffFile, $gffVersion);
}


my $ct;
foreach my $seqId (keys %{$gffLocations}) {
  foreach my $gene (keys %{$gffLocations->{$seqId}}) {
    foreach my $strand (keys %{$gffLocations->{$seqId}->{$gene}}) {
      my $minLoc = CBIL::Util::V::min(@{$gffLocations->{$seqId}->{$gene}->{$strand}});
      my $maxLoc = CBIL::Util::V::max(@{$gffLocations->{$seqId}->{$gene}->{$strand}});

      $ct++;
      push(@{$seqGenes{$seqId}},[$gene,$minLoc,$maxLoc,$strand]);
    }
  }
}

print STDERR "Retrieved from GFF files a total of $ct gene instances to group into genes\n";

my %rel;  ##how genes overlap

## now loop through and identify all that are overlapping ...
$ct = 0;
foreach my $seq_id (keys%seqGenes){
#  last if $ct > 100;
  foreach my $loc (@{$seqGenes{$seq_id}}){
    $ct++;
    print STDERR "Processing $ct: $seq_id, $loc->[1]-$loc->[2]\n" if $ct % 100 == 0;
    my $l = $align->getAlignmentLocations($seq_id,$loc->[1],$loc->[2],$loc->[3]);
    my $selfStrand = &getSelfStrand($seq_id,$l);
    my $res;
    if($l){
      my @genes;
      foreach my $a (@$l){
        print "LOCATIONS: $loc->[0]: ".join("\t",@$a)."\n" if $verbose;
        push(@genes, &getOverlapping($selfStrand,$loc->[3],$a->[0],$a->[1],$a->[2],$a->[3]));
      }
      $res = @genes ? \@genes : [$loc->[0]];
    }else{
      $res = [$loc->[0]];
    }
    foreach my $i (@$res){
      $rel{$loc->[0]}->{$i} = 1;
    }
    print "GENES: $loc->[0]: (".join(", ",@$res).")\n" if $verbose;
  }
}

## now do the transitive closure ...
my %seen;
my $cluster = 1;
foreach my $g (keys%rel){
  next if $seen{$g};
  my $genes = {};
  $genes->{$g} = 1; ##always matches self
  $genes = &getGenes($g,$genes);
  print "cluster_$cluster: [".scalar(keys%$genes)."] (".join(", ",keys%$genes).")\n";
  $cluster++;
}

sub getSelfStrand {
  my($seq_id,$loc) = @_;
  foreach my $l (@$loc){
    return $l->[3] if $l->[0] eq $seq_id;
  }
}

sub getGenes {
  my($id,$genes) = @_;
  return $genes if $seen{$id};
  $seen{$id} = 1;
  foreach my $a (keys%{$rel{$id}}){
    if($rel{$a}->{$id}){
      $genes->{$a} = 1;
      $genes = &getGenes($a,$genes);
    }
  }
  return $genes;
}

sub getOverlapping {
  my($selfStrand,$geneStrand,$seqid,$start,$end,$strand) = @_;
  print STDERR "ERROR: $seqid not found\n" unless $seqGenes{$seqid};
  my @genes;
  foreach my $g (@{$seqGenes{$seqid}}){
    last if $g->[1] >= $end;
    push(@genes,$g->[0]) if $g->[2] >= $start && 
      (($selfStrand eq $strand && $geneStrand eq $g->[3]) ||
       ($selfStrand ne $strand && $geneStrand ne $g->[3]));
  }
  return @genes;
}

$db->logout();
$dbh->disconnect();

