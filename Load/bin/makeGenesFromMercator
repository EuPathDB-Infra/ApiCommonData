#!/usr/bin/perl

## identifies toxo genes for the three strains by walking through each gene for each 
## strain and determining any genes from the other strains that overlap with this gene.
## then is simple transitive closure on the resulting mapping.

## Brian Brunk 07/21/2008

use strict;
use Getopt::Long;
use lib "$ENV{GUS_HOME}/lib/perl";
use GUS::ObjRelP::DbiDatabase;
use GUS::Supported::GusConfig;
use ApiCommonData::Load::MultAlignMercatorMavid;
#use GUS::Model::DoTS::TranslatedAASequence;

my ($gusConfigFile,$mercatorOutputDir,$extDbRelIds,$gene_type,$useGeneAttributes);
my $verbose;
my $cndSrcBin = "/usr/local/bin/cndsrc-2006-09-19/bin/";

&GetOptions("verbose|v!"=> \$verbose,
            "gusConfigFile|gc=s" => \$gusConfigFile,
            "mercatorOutputDir|mod=s" => \$mercatorOutputDir,
            "cndSrcBin|b=s" => \$cndSrcBin,
            "extDbRelIds|rel=s" => \$extDbRelIds,
            "geneType|t=s" => \$gene_type,
            "useGeneAttributes|uga!" => \$useGeneAttributes,
           );

die "you MUST provide --gusConfigFile|gc <gusconfigfile> --mercatorOutputDir|md <dir with mercator output> --cndSrcBin|b <bin directory for mercator execs> --extDbRelIds|rel <comma delimited list of ids> --useGeneAttributes|uga --verbose|v \n" unless ($gusConfigFile && $mercatorOutputDir && $cndSrcBin && ($extDbRelIds || $useGeneAttributes)); 

my $type = $gene_type eq 'protein_coding' ? '=' : $gene_type eq 'rna_coding' ? '!=' : die "ERROR: you must provide --gene_type <(protein_coding|rna_coding)> on the command line\n";

die "ERROR: mercatorOutputDir '$mercatorOutputDir' not found\n" unless -d "$mercatorOutputDir/alignments";
die "ERROR: $cndSrcBin '$cndSrcBin' not found\n" unless -f "$cndSrcBin/sliceAlignment";

my $gusconfig = GUS::Supported::GusConfig->new($gusConfigFile);

my $db = GUS::ObjRelP::DbiDatabase->new($gusconfig->getDbiDsn(),
                                        $gusconfig->getDatabaseLogin(),
                                        $gusconfig->getDatabasePassword(),
                                        $verbose,0,1,
                                        $gusconfig->getCoreSchemaName());

my $dbh = $db->getQueryHandle();

my $align = ApiCommonData::Load::MultAlignMercatorMavid->new();
$align->initialize($dbh,$mercatorOutputDir,$cndSrcBin);

#my $loc = $align->getAlignmentLocations('TGG_995291',4025,5000,'+');

#foreach my $l (@$loc){
#  print join(": ",@$l)."\n";
#}

## my $idQueryProt = "select gf.source_id,s.source_id as sequence_source_id,l.start_min,l.end_max,decode(l.is_reversed,0,'+',1,'-') as strand from dots.GENEFEATURE gf, dots.NALOCATION l,dots.externalnasequence s,sres.sequenceontology so where gf.external_database_release_id in ($extDbRelIds) and so.sequence_ontology_id = gf.sequence_ontology_id and so.term_name $type 'protein_coding' and l.na_feature_id = gf.na_feature_id and s.na_sequence_id = gf.na_sequence_id order by s.source_id,l.start_min";

my $idQueryProt = "select gf.source_id,s.source_id as sequence_source_id,
CASE WHEN min(ef.coding_start) is null THEN l.start_min 
ELSE least(min(ef.coding_start),min(ef.coding_end)) END as start_min, 
CASE WHEN min(ef.coding_start) is null THEN l.end_max 
ELSE  greatest(max(ef.coding_end),max(ef.coding_start)) END as end_max,
decode(l.is_reversed,0,'+',1,'-') as strand 
from dots.GENEFEATURE gf, dots.NALOCATION l,dots.externalnasequence s,sres.sequenceontology so,dots.exonfeature ef 
where gf.external_database_release_id in ($extDbRelIds) 
and so.sequence_ontology_id = gf.sequence_ontology_id 
and so.term_name $type 'protein_coding' 
and l.na_feature_id = gf.na_feature_id 
and s.na_sequence_id = gf.na_sequence_id
and ef.parent_id = gf.na_feature_id
group by gf.source_id,s.source_id,l.is_reversed,l.start_min,l.end_max
order by s.source_id,l.start_min";

##for running after virtual sequences created ...
$idQueryProt = "select gf.source_id,fl.sequence_source_id as sequence_source_id,
CASE WHEN min(fle.coding_start) is null THEN fl.start_min 
ELSE least(min(fle.coding_start),min(fle.coding_end)) END as start_min, 
CASE WHEN min(fle.coding_start) is null THEN fl.end_max 
ELSE  greatest(max(fle.coding_end),max(fle.coding_start)) END as end_max,
decode(fl.is_reversed,0,'+',1,'-') as strand 
from apidb.geneattributes gf, apidb.featurelocation fl, apidb.featurelocation fle
where gf.so_term_name $type 'protein_coding' 
and fl.na_feature_id = gf.na_feature_id 
and fl.is_top_level = 1
and fle.parent_id = gf.na_feature_id
and fle.na_sequence_id = fl.na_sequence_id
and fl.external_database_release_id in ($extDbRelIds)
group by gf.source_id,fl.sequence_source_id,fl.is_reversed,fl.start_min,fl.end_max
order by fl.sequence_source_id,fl.start_min" if $useGeneAttributes;

my $idStmt = $dbh->prepare($idQueryProt);

## note that the following seems to run pretty slowly ... query once above and do in perl
#my $geneQuery = "select gf.source_id
#from dots.EXTERNALNASEQUENCE s, dots.GENEFEATURE gf, dots.NALOCATION l
#where s.source_id = 'TGG_995291'
#and gf.na_sequence_id = s.na_sequence_id
#and gf.na_feature_id = l.na_feature_id
#and gf.external_database_release_id in (69,55,70)
#and l.end_max >= 4025
#and l.start_min <= 5000";

my %seqGenes;
my $ct = 0;

print STDERR "Retrieving all gene instances from the database\n";
$idStmt->execute();
while(my($source_id,$seq_source_id,$start,$end,$strand) = $idStmt->fetchrow_array()){
  $ct++;
  push(@{$seqGenes{$seq_source_id}},[$source_id,$start,$end,$strand]);
  print "GENE_LOC: $source_id\t$seq_source_id\t$start\t$end\t$strand\n" if $verbose;
  print STDERR "Retrieved $ct gene instances\n" if $ct % 1000 == 0;
#  last if $ct % 100 == 0;
}

print STDERR "Retrieved a total of $ct gene instances to group into genes\n";

my %rel;  ##how genes overlap

## now loop through and identify all that are overlapping ...
$ct = 0;
foreach my $seq_id (keys%seqGenes){
#  last if $ct > 100;
  foreach my $loc (@{$seqGenes{$seq_id}}){
    $ct++;
    print STDERR "Processing $ct: $seq_id, $loc->[1]-$loc->[2]\n" if $ct % 100 == 0;
    my $l = $align->getAlignmentLocations($seq_id,$loc->[1],$loc->[2],$loc->[3]);
    my $selfStrand = &getSelfStrand($seq_id,$l);
    my $res;
    if($l){
      my @genes;
      foreach my $a (@$l){
        print "LOCATIONS: $loc->[0]: ".join("\t",@$a)."\n" if $verbose;
        push(@genes, &getOverlapping($selfStrand,$loc->[3],$a->[0],$a->[1],$a->[2],$a->[3]));
      }
      $res = @genes ? \@genes : [$loc->[0]];
    }else{
      $res = [$loc->[0]];
    }
    foreach my $i (@$res){
      $rel{$loc->[0]}->{$i} = 1;
    }
    print "GENES: $loc->[0]: (".join(", ",@$res).")\n" if $verbose;
  }
}

## now do the transitive closure ...
my %seen;
my $cluster = 1;
foreach my $g (keys%rel){
  next if $seen{$g};
  my $genes = {};
  $genes->{$g} = 1; ##always matches self
  $genes = &getGenes($g,$genes);
  print "cluster_$cluster: [".scalar(keys%$genes)."] (".join(", ",keys%$genes).")\n";
  $cluster++;
}

sub getSelfStrand {
  my($seq_id,$loc) = @_;
  foreach my $l (@$loc){
    return $l->[3] if $l->[0] eq $seq_id;
  }
}

sub getGenes {
  my($id,$genes) = @_;
  return $genes if $seen{$id};
  $seen{$id} = 1;
  foreach my $a (keys%{$rel{$id}}){
    if($rel{$a}->{$id}){
      $genes->{$a} = 1;
      $genes = &getGenes($a,$genes);
    }
  }
  return $genes;
}

sub getOverlapping {
  my($selfStrand,$geneStrand,$seqid,$start,$end,$strand) = @_;
  print STDERR "ERROR: $seqid not found\n" unless $seqGenes{$seqid};
  my @genes;
  foreach my $g (@{$seqGenes{$seqid}}){
    last if $g->[1] >= $end;
    push(@genes,$g->[0]) if $g->[2] >= $start && 
      (($selfStrand eq $strand && $geneStrand eq $g->[3]) ||
       ($selfStrand ne $strand && $geneStrand ne $g->[3]));
  }
  return @genes;
}

$dbh->disconnect();
$db->logout();
